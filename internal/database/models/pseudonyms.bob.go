// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"time"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// Pseudonym is an object representing the database table.
type Pseudonym struct {
	PseudonymID         string              `db:"pseudonym_id,pk" scan:"pseudonym_id" json:"pseudonym_id"`
	DisplayName         string              `db:"display_name" scan:"display_name" json:"display_name"`
	KarmaScore          sql.Null[int32]     `db:"karma_score" scan:"karma_score" json:"karma_score"`
	CreatedAt           sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	LastActiveAt        sql.Null[time.Time] `db:"last_active_at" scan:"last_active_at" json:"last_active_at"`
	IsActive            sql.Null[bool]      `db:"is_active" scan:"is_active" json:"is_active"`
	Bio                 sql.Null[string]    `db:"bio" scan:"bio" json:"bio"`
	AvatarURL           sql.Null[string]    `db:"avatar_url" scan:"avatar_url" json:"avatar_url"`
	WebsiteURL          sql.Null[string]    `db:"website_url" scan:"website_url" json:"website_url"`
	ShowKarma           sql.Null[bool]      `db:"show_karma" scan:"show_karma" json:"show_karma"`
	AllowDirectMessages sql.Null[bool]      `db:"allow_direct_messages" scan:"allow_direct_messages" json:"allow_direct_messages"`
	IsDefault           bool                `db:"is_default" scan:"is_default" json:"is_default"`

	R pseudonymR `db:"-" scan:"rel" json:"rel"`
}

// PseudonymSlice is an alias for a slice of pointers to Pseudonym.
// This should almost always be used instead of []*Pseudonym.
type PseudonymSlice []*Pseudonym

// Pseudonyms contains methods to work with the pseudonyms table
var Pseudonyms = psql.NewTablex[*Pseudonym, PseudonymSlice, *PseudonymSetter]("", "pseudonyms")

// PseudonymsQuery is a query on the pseudonyms table
type PseudonymsQuery = *psql.ViewQuery[*Pseudonym, PseudonymSlice]

// pseudonymR is where relationships are stored.
type pseudonymR struct {
	APIKeys                             APIKeySlice               `scan:"APIKeys" json:"APIKeys"`                                                         // api_keys.fk_api_keys_pseudonym
	Comments                            CommentSlice              `scan:"Comments" json:"Comments"`                                                       // comments.comments_pseudonym_id_fkey
	RemovedByPseudonymComments          CommentSlice              `scan:"RemovedByPseudonymComments" json:"RemovedByPseudonymComments"`                   // comments.comments_removed_by_pseudonym_id_fkey
	CorrelationAudits                   CorrelationAuditSlice     `scan:"CorrelationAudits" json:"CorrelationAudits"`                                     // correlation_audit.correlation_audit_pseudonym_id_fkey
	RecipientPseudonymDirectMessages    DirectMessageSlice        `scan:"RecipientPseudonymDirectMessages" json:"RecipientPseudonymDirectMessages"`       // direct_messages.direct_messages_recipient_pseudonym_id_fkey
	SenderPseudonymDirectMessages       DirectMessageSlice        `scan:"SenderPseudonymDirectMessages" json:"SenderPseudonymDirectMessages"`             // direct_messages.direct_messages_sender_pseudonym_id_fkey
	ModeratorPseudonymModerationActions ModerationActionSlice     `scan:"ModeratorPseudonymModerationActions" json:"ModeratorPseudonymModerationActions"` // moderation_actions.moderation_actions_moderator_pseudonym_id_fkey
	PollVotes                           PollVoteSlice             `scan:"PollVotes" json:"PollVotes"`                                                     // poll_votes.poll_votes_pseudonym_id_fkey
	Posts                               PostSlice                 `scan:"Posts" json:"Posts"`                                                             // posts.posts_pseudonym_id_fkey
	RemovedByPseudonymPosts             PostSlice                 `scan:"RemovedByPseudonymPosts" json:"RemovedByPseudonymPosts"`                         // posts.posts_removed_by_pseudonym_id_fkey
	ReportedPseudonymReports            ReportSlice               `scan:"ReportedPseudonymReports" json:"ReportedPseudonymReports"`                       // reports.reports_reported_pseudonym_id_fkey
	ReporterPseudonymReports            ReportSlice               `scan:"ReporterPseudonymReports" json:"ReporterPseudonymReports"`                       // reports.reports_reporter_pseudonym_id_fkey
	ResolvedByPseudonymReports          ReportSlice               `scan:"ResolvedByPseudonymReports" json:"ResolvedByPseudonymReports"`                   // reports.reports_resolved_by_pseudonym_id_fkey
	SubforumModerators                  SubforumModeratorSlice    `scan:"SubforumModerators" json:"SubforumModerators"`                                   // subforum_moderators.subforum_moderators_pseudonym_id_fkey
	SubforumSubscriptions               SubforumSubscriptionSlice `scan:"SubforumSubscriptions" json:"SubforumSubscriptions"`                             // subforum_subscriptions.subforum_subscriptions_pseudonym_id_fkey
	BannedByPseudonymUserBans           UserBanSlice              `scan:"BannedByPseudonymUserBans" json:"BannedByPseudonymUserBans"`                     // user_bans.user_bans_banned_by_pseudonym_id_fkey
	BlockedPseudonymUserBlocks          UserBlockSlice            `scan:"BlockedPseudonymUserBlocks" json:"BlockedPseudonymUserBlocks"`                   // user_blocks.user_blocks_blocked_pseudonym_id_fkey
	BlockerPseudonymUserBlocks          UserBlockSlice            `scan:"BlockerPseudonymUserBlocks" json:"BlockerPseudonymUserBlocks"`                   // user_blocks.user_blocks_blocker_pseudonym_id_fkey
	Votes                               VoteSlice                 `scan:"Votes" json:"Votes"`                                                             // votes.votes_pseudonym_id_fkey
}

type pseudonymColumnNames struct {
	PseudonymID         string
	DisplayName         string
	KarmaScore          string
	CreatedAt           string
	LastActiveAt        string
	IsActive            string
	Bio                 string
	AvatarURL           string
	WebsiteURL          string
	ShowKarma           string
	AllowDirectMessages string
	IsDefault           string
}

var PseudonymColumns = buildPseudonymColumns("pseudonyms")

type pseudonymColumns struct {
	tableAlias          string
	PseudonymID         psql.Expression
	DisplayName         psql.Expression
	KarmaScore          psql.Expression
	CreatedAt           psql.Expression
	LastActiveAt        psql.Expression
	IsActive            psql.Expression
	Bio                 psql.Expression
	AvatarURL           psql.Expression
	WebsiteURL          psql.Expression
	ShowKarma           psql.Expression
	AllowDirectMessages psql.Expression
	IsDefault           psql.Expression
}

func (c pseudonymColumns) Alias() string {
	return c.tableAlias
}

func (pseudonymColumns) AliasedAs(alias string) pseudonymColumns {
	return buildPseudonymColumns(alias)
}

func buildPseudonymColumns(alias string) pseudonymColumns {
	return pseudonymColumns{
		tableAlias:          alias,
		PseudonymID:         psql.Quote(alias, "pseudonym_id"),
		DisplayName:         psql.Quote(alias, "display_name"),
		KarmaScore:          psql.Quote(alias, "karma_score"),
		CreatedAt:           psql.Quote(alias, "created_at"),
		LastActiveAt:        psql.Quote(alias, "last_active_at"),
		IsActive:            psql.Quote(alias, "is_active"),
		Bio:                 psql.Quote(alias, "bio"),
		AvatarURL:           psql.Quote(alias, "avatar_url"),
		WebsiteURL:          psql.Quote(alias, "website_url"),
		ShowKarma:           psql.Quote(alias, "show_karma"),
		AllowDirectMessages: psql.Quote(alias, "allow_direct_messages"),
		IsDefault:           psql.Quote(alias, "is_default"),
	}
}

type pseudonymWhere[Q psql.Filterable] struct {
	PseudonymID         psql.WhereMod[Q, string]
	DisplayName         psql.WhereMod[Q, string]
	KarmaScore          psql.WhereNullMod[Q, int32]
	CreatedAt           psql.WhereNullMod[Q, time.Time]
	LastActiveAt        psql.WhereNullMod[Q, time.Time]
	IsActive            psql.WhereNullMod[Q, bool]
	Bio                 psql.WhereNullMod[Q, string]
	AvatarURL           psql.WhereNullMod[Q, string]
	WebsiteURL          psql.WhereNullMod[Q, string]
	ShowKarma           psql.WhereNullMod[Q, bool]
	AllowDirectMessages psql.WhereNullMod[Q, bool]
	IsDefault           psql.WhereMod[Q, bool]
}

func (pseudonymWhere[Q]) AliasedAs(alias string) pseudonymWhere[Q] {
	return buildPseudonymWhere[Q](buildPseudonymColumns(alias))
}

func buildPseudonymWhere[Q psql.Filterable](cols pseudonymColumns) pseudonymWhere[Q] {
	return pseudonymWhere[Q]{
		PseudonymID:         psql.Where[Q, string](cols.PseudonymID),
		DisplayName:         psql.Where[Q, string](cols.DisplayName),
		KarmaScore:          psql.WhereNull[Q, int32](cols.KarmaScore),
		CreatedAt:           psql.WhereNull[Q, time.Time](cols.CreatedAt),
		LastActiveAt:        psql.WhereNull[Q, time.Time](cols.LastActiveAt),
		IsActive:            psql.WhereNull[Q, bool](cols.IsActive),
		Bio:                 psql.WhereNull[Q, string](cols.Bio),
		AvatarURL:           psql.WhereNull[Q, string](cols.AvatarURL),
		WebsiteURL:          psql.WhereNull[Q, string](cols.WebsiteURL),
		ShowKarma:           psql.WhereNull[Q, bool](cols.ShowKarma),
		AllowDirectMessages: psql.WhereNull[Q, bool](cols.AllowDirectMessages),
		IsDefault:           psql.Where[Q, bool](cols.IsDefault),
	}
}

var PseudonymErrors = &pseudonymErrors{
	ErrUniquePseudonymsPkey: &UniqueConstraintError{
		schema:  "",
		table:   "pseudonyms",
		columns: []string{"pseudonym_id"},
		s:       "pseudonyms_pkey",
	},
}

type pseudonymErrors struct {
	ErrUniquePseudonymsPkey *UniqueConstraintError
}

// PseudonymSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type PseudonymSetter struct {
	PseudonymID         *string              `db:"pseudonym_id,pk" scan:"pseudonym_id" json:"pseudonym_id"`
	DisplayName         *string              `db:"display_name" scan:"display_name" json:"display_name"`
	KarmaScore          *sql.Null[int32]     `db:"karma_score" scan:"karma_score" json:"karma_score"`
	CreatedAt           *sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	LastActiveAt        *sql.Null[time.Time] `db:"last_active_at" scan:"last_active_at" json:"last_active_at"`
	IsActive            *sql.Null[bool]      `db:"is_active" scan:"is_active" json:"is_active"`
	Bio                 *sql.Null[string]    `db:"bio" scan:"bio" json:"bio"`
	AvatarURL           *sql.Null[string]    `db:"avatar_url" scan:"avatar_url" json:"avatar_url"`
	WebsiteURL          *sql.Null[string]    `db:"website_url" scan:"website_url" json:"website_url"`
	ShowKarma           *sql.Null[bool]      `db:"show_karma" scan:"show_karma" json:"show_karma"`
	AllowDirectMessages *sql.Null[bool]      `db:"allow_direct_messages" scan:"allow_direct_messages" json:"allow_direct_messages"`
	IsDefault           *bool                `db:"is_default" scan:"is_default" json:"is_default"`
}

func (s PseudonymSetter) SetColumns() []string {
	vals := make([]string, 0, 12)
	if s.PseudonymID != nil {
		vals = append(vals, "pseudonym_id")
	}

	if s.DisplayName != nil {
		vals = append(vals, "display_name")
	}

	if s.KarmaScore != nil {
		vals = append(vals, "karma_score")
	}

	if s.CreatedAt != nil {
		vals = append(vals, "created_at")
	}

	if s.LastActiveAt != nil {
		vals = append(vals, "last_active_at")
	}

	if s.IsActive != nil {
		vals = append(vals, "is_active")
	}

	if s.Bio != nil {
		vals = append(vals, "bio")
	}

	if s.AvatarURL != nil {
		vals = append(vals, "avatar_url")
	}

	if s.WebsiteURL != nil {
		vals = append(vals, "website_url")
	}

	if s.ShowKarma != nil {
		vals = append(vals, "show_karma")
	}

	if s.AllowDirectMessages != nil {
		vals = append(vals, "allow_direct_messages")
	}

	if s.IsDefault != nil {
		vals = append(vals, "is_default")
	}

	return vals
}

func (s PseudonymSetter) Overwrite(t *Pseudonym) {
	if s.PseudonymID != nil {
		t.PseudonymID = *s.PseudonymID
	}
	if s.DisplayName != nil {
		t.DisplayName = *s.DisplayName
	}
	if s.KarmaScore != nil {
		t.KarmaScore = *s.KarmaScore
	}
	if s.CreatedAt != nil {
		t.CreatedAt = *s.CreatedAt
	}
	if s.LastActiveAt != nil {
		t.LastActiveAt = *s.LastActiveAt
	}
	if s.IsActive != nil {
		t.IsActive = *s.IsActive
	}
	if s.Bio != nil {
		t.Bio = *s.Bio
	}
	if s.AvatarURL != nil {
		t.AvatarURL = *s.AvatarURL
	}
	if s.WebsiteURL != nil {
		t.WebsiteURL = *s.WebsiteURL
	}
	if s.ShowKarma != nil {
		t.ShowKarma = *s.ShowKarma
	}
	if s.AllowDirectMessages != nil {
		t.AllowDirectMessages = *s.AllowDirectMessages
	}
	if s.IsDefault != nil {
		t.IsDefault = *s.IsDefault
	}
}

func (s *PseudonymSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Pseudonyms.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 12)
		if s.PseudonymID != nil {
			vals[0] = psql.Arg(*s.PseudonymID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.DisplayName != nil {
			vals[1] = psql.Arg(*s.DisplayName)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.KarmaScore != nil {
			vals[2] = psql.Arg(*s.KarmaScore)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt != nil {
			vals[3] = psql.Arg(*s.CreatedAt)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.LastActiveAt != nil {
			vals[4] = psql.Arg(*s.LastActiveAt)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.IsActive != nil {
			vals[5] = psql.Arg(*s.IsActive)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.Bio != nil {
			vals[6] = psql.Arg(*s.Bio)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.AvatarURL != nil {
			vals[7] = psql.Arg(*s.AvatarURL)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.WebsiteURL != nil {
			vals[8] = psql.Arg(*s.WebsiteURL)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.ShowKarma != nil {
			vals[9] = psql.Arg(*s.ShowKarma)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.AllowDirectMessages != nil {
			vals[10] = psql.Arg(*s.AllowDirectMessages)
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.IsDefault != nil {
			vals[11] = psql.Arg(*s.IsDefault)
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s PseudonymSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s PseudonymSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 12)

	if s.PseudonymID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "pseudonym_id")...),
			psql.Arg(s.PseudonymID),
		}})
	}

	if s.DisplayName != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "display_name")...),
			psql.Arg(s.DisplayName),
		}})
	}

	if s.KarmaScore != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "karma_score")...),
			psql.Arg(s.KarmaScore),
		}})
	}

	if s.CreatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.LastActiveAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_active_at")...),
			psql.Arg(s.LastActiveAt),
		}})
	}

	if s.IsActive != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_active")...),
			psql.Arg(s.IsActive),
		}})
	}

	if s.Bio != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "bio")...),
			psql.Arg(s.Bio),
		}})
	}

	if s.AvatarURL != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "avatar_url")...),
			psql.Arg(s.AvatarURL),
		}})
	}

	if s.WebsiteURL != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "website_url")...),
			psql.Arg(s.WebsiteURL),
		}})
	}

	if s.ShowKarma != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "show_karma")...),
			psql.Arg(s.ShowKarma),
		}})
	}

	if s.AllowDirectMessages != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "allow_direct_messages")...),
			psql.Arg(s.AllowDirectMessages),
		}})
	}

	if s.IsDefault != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_default")...),
			psql.Arg(s.IsDefault),
		}})
	}

	return exprs
}

// FindPseudonym retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindPseudonym(ctx context.Context, exec bob.Executor, PseudonymIDPK string, cols ...string) (*Pseudonym, error) {
	if len(cols) == 0 {
		return Pseudonyms.Query(
			SelectWhere.Pseudonyms.PseudonymID.EQ(PseudonymIDPK),
		).One(ctx, exec)
	}

	return Pseudonyms.Query(
		SelectWhere.Pseudonyms.PseudonymID.EQ(PseudonymIDPK),
		sm.Columns(Pseudonyms.Columns().Only(cols...)),
	).One(ctx, exec)
}

// PseudonymExists checks the presence of a single record by primary key
func PseudonymExists(ctx context.Context, exec bob.Executor, PseudonymIDPK string) (bool, error) {
	return Pseudonyms.Query(
		SelectWhere.Pseudonyms.PseudonymID.EQ(PseudonymIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Pseudonym is retrieved from the database
func (o *Pseudonym) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Pseudonyms.AfterSelectHooks.RunHooks(ctx, exec, PseudonymSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Pseudonyms.AfterInsertHooks.RunHooks(ctx, exec, PseudonymSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Pseudonyms.AfterUpdateHooks.RunHooks(ctx, exec, PseudonymSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Pseudonyms.AfterDeleteHooks.RunHooks(ctx, exec, PseudonymSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Pseudonym
func (o *Pseudonym) primaryKeyVals() bob.Expression {
	return psql.Arg(o.PseudonymID)
}

func (o *Pseudonym) pkEQ() dialect.Expression {
	return psql.Quote("pseudonyms", "pseudonym_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Pseudonym
func (o *Pseudonym) Update(ctx context.Context, exec bob.Executor, s *PseudonymSetter) error {
	v, err := Pseudonyms.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Pseudonym record with an executor
func (o *Pseudonym) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Pseudonyms.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Pseudonym using the executor
func (o *Pseudonym) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Pseudonyms.Query(
		SelectWhere.Pseudonyms.PseudonymID.EQ(o.PseudonymID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after PseudonymSlice is retrieved from the database
func (o PseudonymSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Pseudonyms.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Pseudonyms.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Pseudonyms.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Pseudonyms.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o PseudonymSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("pseudonyms", "pseudonym_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o PseudonymSlice) copyMatchingRows(from ...*Pseudonym) {
	for i, old := range o {
		for _, new := range from {
			if new.PseudonymID != old.PseudonymID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o PseudonymSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Pseudonyms.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Pseudonym:
				o.copyMatchingRows(retrieved)
			case []*Pseudonym:
				o.copyMatchingRows(retrieved...)
			case PseudonymSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Pseudonym or a slice of Pseudonym
				// then run the AfterUpdateHooks on the slice
				_, err = Pseudonyms.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o PseudonymSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Pseudonyms.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Pseudonym:
				o.copyMatchingRows(retrieved)
			case []*Pseudonym:
				o.copyMatchingRows(retrieved...)
			case PseudonymSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Pseudonym or a slice of Pseudonym
				// then run the AfterDeleteHooks on the slice
				_, err = Pseudonyms.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o PseudonymSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals PseudonymSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Pseudonyms.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o PseudonymSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Pseudonyms.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o PseudonymSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Pseudonyms.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type pseudonymJoins[Q dialect.Joinable] struct {
	typ                                 string
	APIKeys                             modAs[Q, apiKeyColumns]
	Comments                            modAs[Q, commentColumns]
	RemovedByPseudonymComments          modAs[Q, commentColumns]
	CorrelationAudits                   modAs[Q, correlationAuditColumns]
	RecipientPseudonymDirectMessages    modAs[Q, directMessageColumns]
	SenderPseudonymDirectMessages       modAs[Q, directMessageColumns]
	ModeratorPseudonymModerationActions modAs[Q, moderationActionColumns]
	PollVotes                           modAs[Q, pollVoteColumns]
	Posts                               modAs[Q, postColumns]
	RemovedByPseudonymPosts             modAs[Q, postColumns]
	ReportedPseudonymReports            modAs[Q, reportColumns]
	ReporterPseudonymReports            modAs[Q, reportColumns]
	ResolvedByPseudonymReports          modAs[Q, reportColumns]
	SubforumModerators                  modAs[Q, subforumModeratorColumns]
	SubforumSubscriptions               modAs[Q, subforumSubscriptionColumns]
	BannedByPseudonymUserBans           modAs[Q, userBanColumns]
	BlockedPseudonymUserBlocks          modAs[Q, userBlockColumns]
	BlockerPseudonymUserBlocks          modAs[Q, userBlockColumns]
	Votes                               modAs[Q, voteColumns]
}

func (j pseudonymJoins[Q]) aliasedAs(alias string) pseudonymJoins[Q] {
	return buildPseudonymJoins[Q](buildPseudonymColumns(alias), j.typ)
}

func buildPseudonymJoins[Q dialect.Joinable](cols pseudonymColumns, typ string) pseudonymJoins[Q] {
	return pseudonymJoins[Q]{
		typ: typ,
		APIKeys: modAs[Q, apiKeyColumns]{
			c: APIKeyColumns,
			f: func(to apiKeyColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, APIKeys.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		Comments: modAs[Q, commentColumns]{
			c: CommentColumns,
			f: func(to commentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Comments.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		RemovedByPseudonymComments: modAs[Q, commentColumns]{
			c: CommentColumns,
			f: func(to commentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Comments.Name().As(to.Alias())).On(
						to.RemovedByPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		CorrelationAudits: modAs[Q, correlationAuditColumns]{
			c: CorrelationAuditColumns,
			f: func(to correlationAuditColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CorrelationAudits.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		RecipientPseudonymDirectMessages: modAs[Q, directMessageColumns]{
			c: DirectMessageColumns,
			f: func(to directMessageColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, DirectMessages.Name().As(to.Alias())).On(
						to.RecipientPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		SenderPseudonymDirectMessages: modAs[Q, directMessageColumns]{
			c: DirectMessageColumns,
			f: func(to directMessageColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, DirectMessages.Name().As(to.Alias())).On(
						to.SenderPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		ModeratorPseudonymModerationActions: modAs[Q, moderationActionColumns]{
			c: ModerationActionColumns,
			f: func(to moderationActionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ModerationActions.Name().As(to.Alias())).On(
						to.ModeratorPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		PollVotes: modAs[Q, pollVoteColumns]{
			c: PollVoteColumns,
			f: func(to pollVoteColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, PollVotes.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		Posts: modAs[Q, postColumns]{
			c: PostColumns,
			f: func(to postColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Posts.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		RemovedByPseudonymPosts: modAs[Q, postColumns]{
			c: PostColumns,
			f: func(to postColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Posts.Name().As(to.Alias())).On(
						to.RemovedByPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		ReportedPseudonymReports: modAs[Q, reportColumns]{
			c: ReportColumns,
			f: func(to reportColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Reports.Name().As(to.Alias())).On(
						to.ReportedPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		ReporterPseudonymReports: modAs[Q, reportColumns]{
			c: ReportColumns,
			f: func(to reportColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Reports.Name().As(to.Alias())).On(
						to.ReporterPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		ResolvedByPseudonymReports: modAs[Q, reportColumns]{
			c: ReportColumns,
			f: func(to reportColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Reports.Name().As(to.Alias())).On(
						to.ResolvedByPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		SubforumModerators: modAs[Q, subforumModeratorColumns]{
			c: SubforumModeratorColumns,
			f: func(to subforumModeratorColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, SubforumModerators.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		SubforumSubscriptions: modAs[Q, subforumSubscriptionColumns]{
			c: SubforumSubscriptionColumns,
			f: func(to subforumSubscriptionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, SubforumSubscriptions.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		BannedByPseudonymUserBans: modAs[Q, userBanColumns]{
			c: UserBanColumns,
			f: func(to userBanColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserBans.Name().As(to.Alias())).On(
						to.BannedByPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		BlockedPseudonymUserBlocks: modAs[Q, userBlockColumns]{
			c: UserBlockColumns,
			f: func(to userBlockColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserBlocks.Name().As(to.Alias())).On(
						to.BlockedPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		BlockerPseudonymUserBlocks: modAs[Q, userBlockColumns]{
			c: UserBlockColumns,
			f: func(to userBlockColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserBlocks.Name().As(to.Alias())).On(
						to.BlockerPseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		Votes: modAs[Q, voteColumns]{
			c: VoteColumns,
			f: func(to voteColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Votes.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
	}
}

// APIKeys starts a query for related objects on api_keys
func (o *Pseudonym) APIKeys(mods ...bob.Mod[*dialect.SelectQuery]) APIKeysQuery {
	return APIKeys.Query(append(mods,
		sm.Where(APIKeyColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) APIKeys(mods ...bob.Mod[*dialect.SelectQuery]) APIKeysQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return APIKeys.Query(append(mods,
		sm.Where(psql.Group(APIKeyColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// Comments starts a query for related objects on comments
func (o *Pseudonym) Comments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	return Comments.Query(append(mods,
		sm.Where(CommentColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) Comments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Comments.Query(append(mods,
		sm.Where(psql.Group(CommentColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// RemovedByPseudonymComments starts a query for related objects on comments
func (o *Pseudonym) RemovedByPseudonymComments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	return Comments.Query(append(mods,
		sm.Where(CommentColumns.RemovedByPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) RemovedByPseudonymComments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Comments.Query(append(mods,
		sm.Where(psql.Group(CommentColumns.RemovedByPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// CorrelationAudits starts a query for related objects on correlation_audit
func (o *Pseudonym) CorrelationAudits(mods ...bob.Mod[*dialect.SelectQuery]) CorrelationAuditsQuery {
	return CorrelationAudits.Query(append(mods,
		sm.Where(CorrelationAuditColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) CorrelationAudits(mods ...bob.Mod[*dialect.SelectQuery]) CorrelationAuditsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return CorrelationAudits.Query(append(mods,
		sm.Where(psql.Group(CorrelationAuditColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// RecipientPseudonymDirectMessages starts a query for related objects on direct_messages
func (o *Pseudonym) RecipientPseudonymDirectMessages(mods ...bob.Mod[*dialect.SelectQuery]) DirectMessagesQuery {
	return DirectMessages.Query(append(mods,
		sm.Where(DirectMessageColumns.RecipientPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) RecipientPseudonymDirectMessages(mods ...bob.Mod[*dialect.SelectQuery]) DirectMessagesQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return DirectMessages.Query(append(mods,
		sm.Where(psql.Group(DirectMessageColumns.RecipientPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// SenderPseudonymDirectMessages starts a query for related objects on direct_messages
func (o *Pseudonym) SenderPseudonymDirectMessages(mods ...bob.Mod[*dialect.SelectQuery]) DirectMessagesQuery {
	return DirectMessages.Query(append(mods,
		sm.Where(DirectMessageColumns.SenderPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) SenderPseudonymDirectMessages(mods ...bob.Mod[*dialect.SelectQuery]) DirectMessagesQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return DirectMessages.Query(append(mods,
		sm.Where(psql.Group(DirectMessageColumns.SenderPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// ModeratorPseudonymModerationActions starts a query for related objects on moderation_actions
func (o *Pseudonym) ModeratorPseudonymModerationActions(mods ...bob.Mod[*dialect.SelectQuery]) ModerationActionsQuery {
	return ModerationActions.Query(append(mods,
		sm.Where(ModerationActionColumns.ModeratorPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) ModeratorPseudonymModerationActions(mods ...bob.Mod[*dialect.SelectQuery]) ModerationActionsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return ModerationActions.Query(append(mods,
		sm.Where(psql.Group(ModerationActionColumns.ModeratorPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// PollVotes starts a query for related objects on poll_votes
func (o *Pseudonym) PollVotes(mods ...bob.Mod[*dialect.SelectQuery]) PollVotesQuery {
	return PollVotes.Query(append(mods,
		sm.Where(PollVoteColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) PollVotes(mods ...bob.Mod[*dialect.SelectQuery]) PollVotesQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return PollVotes.Query(append(mods,
		sm.Where(psql.Group(PollVoteColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// Posts starts a query for related objects on posts
func (o *Pseudonym) Posts(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	return Posts.Query(append(mods,
		sm.Where(PostColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) Posts(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Posts.Query(append(mods,
		sm.Where(psql.Group(PostColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// RemovedByPseudonymPosts starts a query for related objects on posts
func (o *Pseudonym) RemovedByPseudonymPosts(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	return Posts.Query(append(mods,
		sm.Where(PostColumns.RemovedByPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) RemovedByPseudonymPosts(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Posts.Query(append(mods,
		sm.Where(psql.Group(PostColumns.RemovedByPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// ReportedPseudonymReports starts a query for related objects on reports
func (o *Pseudonym) ReportedPseudonymReports(mods ...bob.Mod[*dialect.SelectQuery]) ReportsQuery {
	return Reports.Query(append(mods,
		sm.Where(ReportColumns.ReportedPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) ReportedPseudonymReports(mods ...bob.Mod[*dialect.SelectQuery]) ReportsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Reports.Query(append(mods,
		sm.Where(psql.Group(ReportColumns.ReportedPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// ReporterPseudonymReports starts a query for related objects on reports
func (o *Pseudonym) ReporterPseudonymReports(mods ...bob.Mod[*dialect.SelectQuery]) ReportsQuery {
	return Reports.Query(append(mods,
		sm.Where(ReportColumns.ReporterPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) ReporterPseudonymReports(mods ...bob.Mod[*dialect.SelectQuery]) ReportsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Reports.Query(append(mods,
		sm.Where(psql.Group(ReportColumns.ReporterPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// ResolvedByPseudonymReports starts a query for related objects on reports
func (o *Pseudonym) ResolvedByPseudonymReports(mods ...bob.Mod[*dialect.SelectQuery]) ReportsQuery {
	return Reports.Query(append(mods,
		sm.Where(ReportColumns.ResolvedByPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) ResolvedByPseudonymReports(mods ...bob.Mod[*dialect.SelectQuery]) ReportsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Reports.Query(append(mods,
		sm.Where(psql.Group(ReportColumns.ResolvedByPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// SubforumModerators starts a query for related objects on subforum_moderators
func (o *Pseudonym) SubforumModerators(mods ...bob.Mod[*dialect.SelectQuery]) SubforumModeratorsQuery {
	return SubforumModerators.Query(append(mods,
		sm.Where(SubforumModeratorColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) SubforumModerators(mods ...bob.Mod[*dialect.SelectQuery]) SubforumModeratorsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return SubforumModerators.Query(append(mods,
		sm.Where(psql.Group(SubforumModeratorColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// SubforumSubscriptions starts a query for related objects on subforum_subscriptions
func (o *Pseudonym) SubforumSubscriptions(mods ...bob.Mod[*dialect.SelectQuery]) SubforumSubscriptionsQuery {
	return SubforumSubscriptions.Query(append(mods,
		sm.Where(SubforumSubscriptionColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) SubforumSubscriptions(mods ...bob.Mod[*dialect.SelectQuery]) SubforumSubscriptionsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return SubforumSubscriptions.Query(append(mods,
		sm.Where(psql.Group(SubforumSubscriptionColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// BannedByPseudonymUserBans starts a query for related objects on user_bans
func (o *Pseudonym) BannedByPseudonymUserBans(mods ...bob.Mod[*dialect.SelectQuery]) UserBansQuery {
	return UserBans.Query(append(mods,
		sm.Where(UserBanColumns.BannedByPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) BannedByPseudonymUserBans(mods ...bob.Mod[*dialect.SelectQuery]) UserBansQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return UserBans.Query(append(mods,
		sm.Where(psql.Group(UserBanColumns.BannedByPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// BlockedPseudonymUserBlocks starts a query for related objects on user_blocks
func (o *Pseudonym) BlockedPseudonymUserBlocks(mods ...bob.Mod[*dialect.SelectQuery]) UserBlocksQuery {
	return UserBlocks.Query(append(mods,
		sm.Where(UserBlockColumns.BlockedPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) BlockedPseudonymUserBlocks(mods ...bob.Mod[*dialect.SelectQuery]) UserBlocksQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return UserBlocks.Query(append(mods,
		sm.Where(psql.Group(UserBlockColumns.BlockedPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// BlockerPseudonymUserBlocks starts a query for related objects on user_blocks
func (o *Pseudonym) BlockerPseudonymUserBlocks(mods ...bob.Mod[*dialect.SelectQuery]) UserBlocksQuery {
	return UserBlocks.Query(append(mods,
		sm.Where(UserBlockColumns.BlockerPseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) BlockerPseudonymUserBlocks(mods ...bob.Mod[*dialect.SelectQuery]) UserBlocksQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return UserBlocks.Query(append(mods,
		sm.Where(psql.Group(UserBlockColumns.BlockerPseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// Votes starts a query for related objects on votes
func (o *Pseudonym) Votes(mods ...bob.Mod[*dialect.SelectQuery]) VotesQuery {
	return Votes.Query(append(mods,
		sm.Where(VoteColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PseudonymSlice) Votes(mods ...bob.Mod[*dialect.SelectQuery]) VotesQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Votes.Query(append(mods,
		sm.Where(psql.Group(VoteColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

func (o *Pseudonym) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "APIKeys":
		rels, ok := retrieved.(APIKeySlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.APIKeys = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Pseudonym = o
			}
		}
		return nil
	case "Comments":
		rels, ok := retrieved.(CommentSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.Comments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Pseudonym = o
			}
		}
		return nil
	case "RemovedByPseudonymComments":
		rels, ok := retrieved.(CommentSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.RemovedByPseudonymComments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.RemovedByPseudonymPseudonym = o
			}
		}
		return nil
	case "CorrelationAudits":
		rels, ok := retrieved.(CorrelationAuditSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.CorrelationAudits = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Pseudonym = o
			}
		}
		return nil
	case "RecipientPseudonymDirectMessages":
		rels, ok := retrieved.(DirectMessageSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.RecipientPseudonymDirectMessages = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.RecipientPseudonymPseudonym = o
			}
		}
		return nil
	case "SenderPseudonymDirectMessages":
		rels, ok := retrieved.(DirectMessageSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.SenderPseudonymDirectMessages = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.SenderPseudonymPseudonym = o
			}
		}
		return nil
	case "ModeratorPseudonymModerationActions":
		rels, ok := retrieved.(ModerationActionSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.ModeratorPseudonymModerationActions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ModeratorPseudonymPseudonym = o
			}
		}
		return nil
	case "PollVotes":
		rels, ok := retrieved.(PollVoteSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.PollVotes = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Pseudonym = o
			}
		}
		return nil
	case "Posts":
		rels, ok := retrieved.(PostSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.Posts = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Pseudonym = o
			}
		}
		return nil
	case "RemovedByPseudonymPosts":
		rels, ok := retrieved.(PostSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.RemovedByPseudonymPosts = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.RemovedByPseudonymPseudonym = o
			}
		}
		return nil
	case "ReportedPseudonymReports":
		rels, ok := retrieved.(ReportSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.ReportedPseudonymReports = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ReportedPseudonymPseudonym = o
			}
		}
		return nil
	case "ReporterPseudonymReports":
		rels, ok := retrieved.(ReportSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.ReporterPseudonymReports = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ReporterPseudonymPseudonym = o
			}
		}
		return nil
	case "ResolvedByPseudonymReports":
		rels, ok := retrieved.(ReportSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.ResolvedByPseudonymReports = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ResolvedByPseudonymPseudonym = o
			}
		}
		return nil
	case "SubforumModerators":
		rels, ok := retrieved.(SubforumModeratorSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.SubforumModerators = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Pseudonym = o
			}
		}
		return nil
	case "SubforumSubscriptions":
		rels, ok := retrieved.(SubforumSubscriptionSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.SubforumSubscriptions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Pseudonym = o
			}
		}
		return nil
	case "BannedByPseudonymUserBans":
		rels, ok := retrieved.(UserBanSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.BannedByPseudonymUserBans = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.BannedByPseudonymPseudonym = o
			}
		}
		return nil
	case "BlockedPseudonymUserBlocks":
		rels, ok := retrieved.(UserBlockSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.BlockedPseudonymUserBlocks = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.BlockedPseudonymPseudonym = o
			}
		}
		return nil
	case "BlockerPseudonymUserBlocks":
		rels, ok := retrieved.(UserBlockSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.BlockerPseudonymUserBlocks = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.BlockerPseudonymPseudonym = o
			}
		}
		return nil
	case "Votes":
		rels, ok := retrieved.(VoteSlice)
		if !ok {
			return fmt.Errorf("pseudonym cannot load %T as %q", retrieved, name)
		}

		o.R.Votes = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Pseudonym = o
			}
		}
		return nil
	default:
		return fmt.Errorf("pseudonym has no relationship %q", name)
	}
}

type pseudonymPreloader struct{}

func buildPseudonymPreloader() pseudonymPreloader {
	return pseudonymPreloader{}
}

type pseudonymThenLoader[Q orm.Loadable] struct {
	APIKeys                             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Comments                            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RemovedByPseudonymComments          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CorrelationAudits                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RecipientPseudonymDirectMessages    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	SenderPseudonymDirectMessages       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ModeratorPseudonymModerationActions func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	PollVotes                           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Posts                               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RemovedByPseudonymPosts             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ReportedPseudonymReports            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ReporterPseudonymReports            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ResolvedByPseudonymReports          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	SubforumModerators                  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	SubforumSubscriptions               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	BannedByPseudonymUserBans           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	BlockedPseudonymUserBlocks          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	BlockerPseudonymUserBlocks          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Votes                               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildPseudonymThenLoader[Q orm.Loadable]() pseudonymThenLoader[Q] {
	type APIKeysLoadInterface interface {
		LoadAPIKeys(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CommentsLoadInterface interface {
		LoadComments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RemovedByPseudonymCommentsLoadInterface interface {
		LoadRemovedByPseudonymComments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CorrelationAuditsLoadInterface interface {
		LoadCorrelationAudits(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RecipientPseudonymDirectMessagesLoadInterface interface {
		LoadRecipientPseudonymDirectMessages(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SenderPseudonymDirectMessagesLoadInterface interface {
		LoadSenderPseudonymDirectMessages(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ModeratorPseudonymModerationActionsLoadInterface interface {
		LoadModeratorPseudonymModerationActions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PollVotesLoadInterface interface {
		LoadPollVotes(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PostsLoadInterface interface {
		LoadPosts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RemovedByPseudonymPostsLoadInterface interface {
		LoadRemovedByPseudonymPosts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ReportedPseudonymReportsLoadInterface interface {
		LoadReportedPseudonymReports(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ReporterPseudonymReportsLoadInterface interface {
		LoadReporterPseudonymReports(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ResolvedByPseudonymReportsLoadInterface interface {
		LoadResolvedByPseudonymReports(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SubforumModeratorsLoadInterface interface {
		LoadSubforumModerators(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SubforumSubscriptionsLoadInterface interface {
		LoadSubforumSubscriptions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type BannedByPseudonymUserBansLoadInterface interface {
		LoadBannedByPseudonymUserBans(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type BlockedPseudonymUserBlocksLoadInterface interface {
		LoadBlockedPseudonymUserBlocks(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type BlockerPseudonymUserBlocksLoadInterface interface {
		LoadBlockerPseudonymUserBlocks(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type VotesLoadInterface interface {
		LoadVotes(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return pseudonymThenLoader[Q]{
		APIKeys: thenLoadBuilder[Q](
			"APIKeys",
			func(ctx context.Context, exec bob.Executor, retrieved APIKeysLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadAPIKeys(ctx, exec, mods...)
			},
		),
		Comments: thenLoadBuilder[Q](
			"Comments",
			func(ctx context.Context, exec bob.Executor, retrieved CommentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadComments(ctx, exec, mods...)
			},
		),
		RemovedByPseudonymComments: thenLoadBuilder[Q](
			"RemovedByPseudonymComments",
			func(ctx context.Context, exec bob.Executor, retrieved RemovedByPseudonymCommentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRemovedByPseudonymComments(ctx, exec, mods...)
			},
		),
		CorrelationAudits: thenLoadBuilder[Q](
			"CorrelationAudits",
			func(ctx context.Context, exec bob.Executor, retrieved CorrelationAuditsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCorrelationAudits(ctx, exec, mods...)
			},
		),
		RecipientPseudonymDirectMessages: thenLoadBuilder[Q](
			"RecipientPseudonymDirectMessages",
			func(ctx context.Context, exec bob.Executor, retrieved RecipientPseudonymDirectMessagesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRecipientPseudonymDirectMessages(ctx, exec, mods...)
			},
		),
		SenderPseudonymDirectMessages: thenLoadBuilder[Q](
			"SenderPseudonymDirectMessages",
			func(ctx context.Context, exec bob.Executor, retrieved SenderPseudonymDirectMessagesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSenderPseudonymDirectMessages(ctx, exec, mods...)
			},
		),
		ModeratorPseudonymModerationActions: thenLoadBuilder[Q](
			"ModeratorPseudonymModerationActions",
			func(ctx context.Context, exec bob.Executor, retrieved ModeratorPseudonymModerationActionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadModeratorPseudonymModerationActions(ctx, exec, mods...)
			},
		),
		PollVotes: thenLoadBuilder[Q](
			"PollVotes",
			func(ctx context.Context, exec bob.Executor, retrieved PollVotesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPollVotes(ctx, exec, mods...)
			},
		),
		Posts: thenLoadBuilder[Q](
			"Posts",
			func(ctx context.Context, exec bob.Executor, retrieved PostsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPosts(ctx, exec, mods...)
			},
		),
		RemovedByPseudonymPosts: thenLoadBuilder[Q](
			"RemovedByPseudonymPosts",
			func(ctx context.Context, exec bob.Executor, retrieved RemovedByPseudonymPostsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRemovedByPseudonymPosts(ctx, exec, mods...)
			},
		),
		ReportedPseudonymReports: thenLoadBuilder[Q](
			"ReportedPseudonymReports",
			func(ctx context.Context, exec bob.Executor, retrieved ReportedPseudonymReportsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadReportedPseudonymReports(ctx, exec, mods...)
			},
		),
		ReporterPseudonymReports: thenLoadBuilder[Q](
			"ReporterPseudonymReports",
			func(ctx context.Context, exec bob.Executor, retrieved ReporterPseudonymReportsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadReporterPseudonymReports(ctx, exec, mods...)
			},
		),
		ResolvedByPseudonymReports: thenLoadBuilder[Q](
			"ResolvedByPseudonymReports",
			func(ctx context.Context, exec bob.Executor, retrieved ResolvedByPseudonymReportsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadResolvedByPseudonymReports(ctx, exec, mods...)
			},
		),
		SubforumModerators: thenLoadBuilder[Q](
			"SubforumModerators",
			func(ctx context.Context, exec bob.Executor, retrieved SubforumModeratorsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSubforumModerators(ctx, exec, mods...)
			},
		),
		SubforumSubscriptions: thenLoadBuilder[Q](
			"SubforumSubscriptions",
			func(ctx context.Context, exec bob.Executor, retrieved SubforumSubscriptionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSubforumSubscriptions(ctx, exec, mods...)
			},
		),
		BannedByPseudonymUserBans: thenLoadBuilder[Q](
			"BannedByPseudonymUserBans",
			func(ctx context.Context, exec bob.Executor, retrieved BannedByPseudonymUserBansLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadBannedByPseudonymUserBans(ctx, exec, mods...)
			},
		),
		BlockedPseudonymUserBlocks: thenLoadBuilder[Q](
			"BlockedPseudonymUserBlocks",
			func(ctx context.Context, exec bob.Executor, retrieved BlockedPseudonymUserBlocksLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadBlockedPseudonymUserBlocks(ctx, exec, mods...)
			},
		),
		BlockerPseudonymUserBlocks: thenLoadBuilder[Q](
			"BlockerPseudonymUserBlocks",
			func(ctx context.Context, exec bob.Executor, retrieved BlockerPseudonymUserBlocksLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadBlockerPseudonymUserBlocks(ctx, exec, mods...)
			},
		),
		Votes: thenLoadBuilder[Q](
			"Votes",
			func(ctx context.Context, exec bob.Executor, retrieved VotesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadVotes(ctx, exec, mods...)
			},
		),
	}
}

// LoadAPIKeys loads the pseudonym's APIKeys into the .R struct
func (o *Pseudonym) LoadAPIKeys(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.APIKeys = nil

	related, err := o.APIKeys(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Pseudonym = o
	}

	o.R.APIKeys = related
	return nil
}

// LoadAPIKeys loads the pseudonym's APIKeys into the .R struct
func (os PseudonymSlice) LoadAPIKeys(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	apiKeys, err := os.APIKeys(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.APIKeys = nil
	}

	for _, o := range os {
		for _, rel := range apiKeys {
			if o.PseudonymID != rel.PseudonymID.V {
				continue
			}

			rel.R.Pseudonym = o

			o.R.APIKeys = append(o.R.APIKeys, rel)
		}
	}

	return nil
}

// LoadComments loads the pseudonym's Comments into the .R struct
func (o *Pseudonym) LoadComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Comments = nil

	related, err := o.Comments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Pseudonym = o
	}

	o.R.Comments = related
	return nil
}

// LoadComments loads the pseudonym's Comments into the .R struct
func (os PseudonymSlice) LoadComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	comments, err := os.Comments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Comments = nil
	}

	for _, o := range os {
		for _, rel := range comments {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.Pseudonym = o

			o.R.Comments = append(o.R.Comments, rel)
		}
	}

	return nil
}

// LoadRemovedByPseudonymComments loads the pseudonym's RemovedByPseudonymComments into the .R struct
func (o *Pseudonym) LoadRemovedByPseudonymComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RemovedByPseudonymComments = nil

	related, err := o.RemovedByPseudonymComments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.RemovedByPseudonymPseudonym = o
	}

	o.R.RemovedByPseudonymComments = related
	return nil
}

// LoadRemovedByPseudonymComments loads the pseudonym's RemovedByPseudonymComments into the .R struct
func (os PseudonymSlice) LoadRemovedByPseudonymComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	comments, err := os.RemovedByPseudonymComments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.RemovedByPseudonymComments = nil
	}

	for _, o := range os {
		for _, rel := range comments {
			if o.PseudonymID != rel.RemovedByPseudonymID.V {
				continue
			}

			rel.R.RemovedByPseudonymPseudonym = o

			o.R.RemovedByPseudonymComments = append(o.R.RemovedByPseudonymComments, rel)
		}
	}

	return nil
}

// LoadCorrelationAudits loads the pseudonym's CorrelationAudits into the .R struct
func (o *Pseudonym) LoadCorrelationAudits(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CorrelationAudits = nil

	related, err := o.CorrelationAudits(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Pseudonym = o
	}

	o.R.CorrelationAudits = related
	return nil
}

// LoadCorrelationAudits loads the pseudonym's CorrelationAudits into the .R struct
func (os PseudonymSlice) LoadCorrelationAudits(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	correlationAudits, err := os.CorrelationAudits(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CorrelationAudits = nil
	}

	for _, o := range os {
		for _, rel := range correlationAudits {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.Pseudonym = o

			o.R.CorrelationAudits = append(o.R.CorrelationAudits, rel)
		}
	}

	return nil
}

// LoadRecipientPseudonymDirectMessages loads the pseudonym's RecipientPseudonymDirectMessages into the .R struct
func (o *Pseudonym) LoadRecipientPseudonymDirectMessages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RecipientPseudonymDirectMessages = nil

	related, err := o.RecipientPseudonymDirectMessages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.RecipientPseudonymPseudonym = o
	}

	o.R.RecipientPseudonymDirectMessages = related
	return nil
}

// LoadRecipientPseudonymDirectMessages loads the pseudonym's RecipientPseudonymDirectMessages into the .R struct
func (os PseudonymSlice) LoadRecipientPseudonymDirectMessages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	directMessages, err := os.RecipientPseudonymDirectMessages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.RecipientPseudonymDirectMessages = nil
	}

	for _, o := range os {
		for _, rel := range directMessages {
			if o.PseudonymID != rel.RecipientPseudonymID {
				continue
			}

			rel.R.RecipientPseudonymPseudonym = o

			o.R.RecipientPseudonymDirectMessages = append(o.R.RecipientPseudonymDirectMessages, rel)
		}
	}

	return nil
}

// LoadSenderPseudonymDirectMessages loads the pseudonym's SenderPseudonymDirectMessages into the .R struct
func (o *Pseudonym) LoadSenderPseudonymDirectMessages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.SenderPseudonymDirectMessages = nil

	related, err := o.SenderPseudonymDirectMessages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.SenderPseudonymPseudonym = o
	}

	o.R.SenderPseudonymDirectMessages = related
	return nil
}

// LoadSenderPseudonymDirectMessages loads the pseudonym's SenderPseudonymDirectMessages into the .R struct
func (os PseudonymSlice) LoadSenderPseudonymDirectMessages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	directMessages, err := os.SenderPseudonymDirectMessages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.SenderPseudonymDirectMessages = nil
	}

	for _, o := range os {
		for _, rel := range directMessages {
			if o.PseudonymID != rel.SenderPseudonymID {
				continue
			}

			rel.R.SenderPseudonymPseudonym = o

			o.R.SenderPseudonymDirectMessages = append(o.R.SenderPseudonymDirectMessages, rel)
		}
	}

	return nil
}

// LoadModeratorPseudonymModerationActions loads the pseudonym's ModeratorPseudonymModerationActions into the .R struct
func (o *Pseudonym) LoadModeratorPseudonymModerationActions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ModeratorPseudonymModerationActions = nil

	related, err := o.ModeratorPseudonymModerationActions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ModeratorPseudonymPseudonym = o
	}

	o.R.ModeratorPseudonymModerationActions = related
	return nil
}

// LoadModeratorPseudonymModerationActions loads the pseudonym's ModeratorPseudonymModerationActions into the .R struct
func (os PseudonymSlice) LoadModeratorPseudonymModerationActions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	moderationActions, err := os.ModeratorPseudonymModerationActions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ModeratorPseudonymModerationActions = nil
	}

	for _, o := range os {
		for _, rel := range moderationActions {
			if o.PseudonymID != rel.ModeratorPseudonymID {
				continue
			}

			rel.R.ModeratorPseudonymPseudonym = o

			o.R.ModeratorPseudonymModerationActions = append(o.R.ModeratorPseudonymModerationActions, rel)
		}
	}

	return nil
}

// LoadPollVotes loads the pseudonym's PollVotes into the .R struct
func (o *Pseudonym) LoadPollVotes(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.PollVotes = nil

	related, err := o.PollVotes(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Pseudonym = o
	}

	o.R.PollVotes = related
	return nil
}

// LoadPollVotes loads the pseudonym's PollVotes into the .R struct
func (os PseudonymSlice) LoadPollVotes(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pollVotes, err := os.PollVotes(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.PollVotes = nil
	}

	for _, o := range os {
		for _, rel := range pollVotes {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.Pseudonym = o

			o.R.PollVotes = append(o.R.PollVotes, rel)
		}
	}

	return nil
}

// LoadPosts loads the pseudonym's Posts into the .R struct
func (o *Pseudonym) LoadPosts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Posts = nil

	related, err := o.Posts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Pseudonym = o
	}

	o.R.Posts = related
	return nil
}

// LoadPosts loads the pseudonym's Posts into the .R struct
func (os PseudonymSlice) LoadPosts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	posts, err := os.Posts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Posts = nil
	}

	for _, o := range os {
		for _, rel := range posts {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.Pseudonym = o

			o.R.Posts = append(o.R.Posts, rel)
		}
	}

	return nil
}

// LoadRemovedByPseudonymPosts loads the pseudonym's RemovedByPseudonymPosts into the .R struct
func (o *Pseudonym) LoadRemovedByPseudonymPosts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RemovedByPseudonymPosts = nil

	related, err := o.RemovedByPseudonymPosts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.RemovedByPseudonymPseudonym = o
	}

	o.R.RemovedByPseudonymPosts = related
	return nil
}

// LoadRemovedByPseudonymPosts loads the pseudonym's RemovedByPseudonymPosts into the .R struct
func (os PseudonymSlice) LoadRemovedByPseudonymPosts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	posts, err := os.RemovedByPseudonymPosts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.RemovedByPseudonymPosts = nil
	}

	for _, o := range os {
		for _, rel := range posts {
			if o.PseudonymID != rel.RemovedByPseudonymID.V {
				continue
			}

			rel.R.RemovedByPseudonymPseudonym = o

			o.R.RemovedByPseudonymPosts = append(o.R.RemovedByPseudonymPosts, rel)
		}
	}

	return nil
}

// LoadReportedPseudonymReports loads the pseudonym's ReportedPseudonymReports into the .R struct
func (o *Pseudonym) LoadReportedPseudonymReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ReportedPseudonymReports = nil

	related, err := o.ReportedPseudonymReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ReportedPseudonymPseudonym = o
	}

	o.R.ReportedPseudonymReports = related
	return nil
}

// LoadReportedPseudonymReports loads the pseudonym's ReportedPseudonymReports into the .R struct
func (os PseudonymSlice) LoadReportedPseudonymReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	reports, err := os.ReportedPseudonymReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ReportedPseudonymReports = nil
	}

	for _, o := range os {
		for _, rel := range reports {
			if o.PseudonymID != rel.ReportedPseudonymID.V {
				continue
			}

			rel.R.ReportedPseudonymPseudonym = o

			o.R.ReportedPseudonymReports = append(o.R.ReportedPseudonymReports, rel)
		}
	}

	return nil
}

// LoadReporterPseudonymReports loads the pseudonym's ReporterPseudonymReports into the .R struct
func (o *Pseudonym) LoadReporterPseudonymReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ReporterPseudonymReports = nil

	related, err := o.ReporterPseudonymReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ReporterPseudonymPseudonym = o
	}

	o.R.ReporterPseudonymReports = related
	return nil
}

// LoadReporterPseudonymReports loads the pseudonym's ReporterPseudonymReports into the .R struct
func (os PseudonymSlice) LoadReporterPseudonymReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	reports, err := os.ReporterPseudonymReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ReporterPseudonymReports = nil
	}

	for _, o := range os {
		for _, rel := range reports {
			if o.PseudonymID != rel.ReporterPseudonymID {
				continue
			}

			rel.R.ReporterPseudonymPseudonym = o

			o.R.ReporterPseudonymReports = append(o.R.ReporterPseudonymReports, rel)
		}
	}

	return nil
}

// LoadResolvedByPseudonymReports loads the pseudonym's ResolvedByPseudonymReports into the .R struct
func (o *Pseudonym) LoadResolvedByPseudonymReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ResolvedByPseudonymReports = nil

	related, err := o.ResolvedByPseudonymReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ResolvedByPseudonymPseudonym = o
	}

	o.R.ResolvedByPseudonymReports = related
	return nil
}

// LoadResolvedByPseudonymReports loads the pseudonym's ResolvedByPseudonymReports into the .R struct
func (os PseudonymSlice) LoadResolvedByPseudonymReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	reports, err := os.ResolvedByPseudonymReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ResolvedByPseudonymReports = nil
	}

	for _, o := range os {
		for _, rel := range reports {
			if o.PseudonymID != rel.ResolvedByPseudonymID.V {
				continue
			}

			rel.R.ResolvedByPseudonymPseudonym = o

			o.R.ResolvedByPseudonymReports = append(o.R.ResolvedByPseudonymReports, rel)
		}
	}

	return nil
}

// LoadSubforumModerators loads the pseudonym's SubforumModerators into the .R struct
func (o *Pseudonym) LoadSubforumModerators(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.SubforumModerators = nil

	related, err := o.SubforumModerators(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Pseudonym = o
	}

	o.R.SubforumModerators = related
	return nil
}

// LoadSubforumModerators loads the pseudonym's SubforumModerators into the .R struct
func (os PseudonymSlice) LoadSubforumModerators(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	subforumModerators, err := os.SubforumModerators(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.SubforumModerators = nil
	}

	for _, o := range os {
		for _, rel := range subforumModerators {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.Pseudonym = o

			o.R.SubforumModerators = append(o.R.SubforumModerators, rel)
		}
	}

	return nil
}

// LoadSubforumSubscriptions loads the pseudonym's SubforumSubscriptions into the .R struct
func (o *Pseudonym) LoadSubforumSubscriptions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.SubforumSubscriptions = nil

	related, err := o.SubforumSubscriptions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Pseudonym = o
	}

	o.R.SubforumSubscriptions = related
	return nil
}

// LoadSubforumSubscriptions loads the pseudonym's SubforumSubscriptions into the .R struct
func (os PseudonymSlice) LoadSubforumSubscriptions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	subforumSubscriptions, err := os.SubforumSubscriptions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.SubforumSubscriptions = nil
	}

	for _, o := range os {
		for _, rel := range subforumSubscriptions {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.Pseudonym = o

			o.R.SubforumSubscriptions = append(o.R.SubforumSubscriptions, rel)
		}
	}

	return nil
}

// LoadBannedByPseudonymUserBans loads the pseudonym's BannedByPseudonymUserBans into the .R struct
func (o *Pseudonym) LoadBannedByPseudonymUserBans(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.BannedByPseudonymUserBans = nil

	related, err := o.BannedByPseudonymUserBans(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.BannedByPseudonymPseudonym = o
	}

	o.R.BannedByPseudonymUserBans = related
	return nil
}

// LoadBannedByPseudonymUserBans loads the pseudonym's BannedByPseudonymUserBans into the .R struct
func (os PseudonymSlice) LoadBannedByPseudonymUserBans(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userBans, err := os.BannedByPseudonymUserBans(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.BannedByPseudonymUserBans = nil
	}

	for _, o := range os {
		for _, rel := range userBans {
			if o.PseudonymID != rel.BannedByPseudonymID {
				continue
			}

			rel.R.BannedByPseudonymPseudonym = o

			o.R.BannedByPseudonymUserBans = append(o.R.BannedByPseudonymUserBans, rel)
		}
	}

	return nil
}

// LoadBlockedPseudonymUserBlocks loads the pseudonym's BlockedPseudonymUserBlocks into the .R struct
func (o *Pseudonym) LoadBlockedPseudonymUserBlocks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.BlockedPseudonymUserBlocks = nil

	related, err := o.BlockedPseudonymUserBlocks(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.BlockedPseudonymPseudonym = o
	}

	o.R.BlockedPseudonymUserBlocks = related
	return nil
}

// LoadBlockedPseudonymUserBlocks loads the pseudonym's BlockedPseudonymUserBlocks into the .R struct
func (os PseudonymSlice) LoadBlockedPseudonymUserBlocks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userBlocks, err := os.BlockedPseudonymUserBlocks(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.BlockedPseudonymUserBlocks = nil
	}

	for _, o := range os {
		for _, rel := range userBlocks {
			if o.PseudonymID != rel.BlockedPseudonymID.V {
				continue
			}

			rel.R.BlockedPseudonymPseudonym = o

			o.R.BlockedPseudonymUserBlocks = append(o.R.BlockedPseudonymUserBlocks, rel)
		}
	}

	return nil
}

// LoadBlockerPseudonymUserBlocks loads the pseudonym's BlockerPseudonymUserBlocks into the .R struct
func (o *Pseudonym) LoadBlockerPseudonymUserBlocks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.BlockerPseudonymUserBlocks = nil

	related, err := o.BlockerPseudonymUserBlocks(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.BlockerPseudonymPseudonym = o
	}

	o.R.BlockerPseudonymUserBlocks = related
	return nil
}

// LoadBlockerPseudonymUserBlocks loads the pseudonym's BlockerPseudonymUserBlocks into the .R struct
func (os PseudonymSlice) LoadBlockerPseudonymUserBlocks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userBlocks, err := os.BlockerPseudonymUserBlocks(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.BlockerPseudonymUserBlocks = nil
	}

	for _, o := range os {
		for _, rel := range userBlocks {
			if o.PseudonymID != rel.BlockerPseudonymID {
				continue
			}

			rel.R.BlockerPseudonymPseudonym = o

			o.R.BlockerPseudonymUserBlocks = append(o.R.BlockerPseudonymUserBlocks, rel)
		}
	}

	return nil
}

// LoadVotes loads the pseudonym's Votes into the .R struct
func (o *Pseudonym) LoadVotes(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Votes = nil

	related, err := o.Votes(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Pseudonym = o
	}

	o.R.Votes = related
	return nil
}

// LoadVotes loads the pseudonym's Votes into the .R struct
func (os PseudonymSlice) LoadVotes(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	votes, err := os.Votes(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Votes = nil
	}

	for _, o := range os {
		for _, rel := range votes {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.Pseudonym = o

			o.R.Votes = append(o.R.Votes, rel)
		}
	}

	return nil
}

func insertPseudonymAPIKeys0(ctx context.Context, exec bob.Executor, apiKeys1 []*APIKeySetter, pseudonym0 *Pseudonym) (APIKeySlice, error) {
	for i := range apiKeys1 {
		apiKeys1[i].PseudonymID = func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}()
	}

	ret, err := APIKeys.Insert(bob.ToMods(apiKeys1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymAPIKeys0: %w", err)
	}

	return ret, nil
}

func attachPseudonymAPIKeys0(ctx context.Context, exec bob.Executor, count int, apiKeys1 APIKeySlice, pseudonym0 *Pseudonym) (APIKeySlice, error) {
	setter := &APIKeySetter{
		PseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := apiKeys1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymAPIKeys0: %w", err)
	}

	return apiKeys1, nil
}

func (pseudonym0 *Pseudonym) InsertAPIKeys(ctx context.Context, exec bob.Executor, related ...*APIKeySetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	apiKeys1, err := insertPseudonymAPIKeys0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.APIKeys = append(pseudonym0.R.APIKeys, apiKeys1...)

	for _, rel := range apiKeys1 {
		rel.R.Pseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachAPIKeys(ctx context.Context, exec bob.Executor, related ...*APIKey) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	apiKeys1 := APIKeySlice(related)

	_, err = attachPseudonymAPIKeys0(ctx, exec, len(related), apiKeys1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.APIKeys = append(pseudonym0.R.APIKeys, apiKeys1...)

	for _, rel := range related {
		rel.R.Pseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymComments0(ctx context.Context, exec bob.Executor, comments1 []*CommentSetter, pseudonym0 *Pseudonym) (CommentSlice, error) {
	for i := range comments1 {
		comments1[i].PseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := Comments.Insert(bob.ToMods(comments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymComments0: %w", err)
	}

	return ret, nil
}

func attachPseudonymComments0(ctx context.Context, exec bob.Executor, count int, comments1 CommentSlice, pseudonym0 *Pseudonym) (CommentSlice, error) {
	setter := &CommentSetter{
		PseudonymID: &pseudonym0.PseudonymID,
	}

	err := comments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymComments0: %w", err)
	}

	return comments1, nil
}

func (pseudonym0 *Pseudonym) InsertComments(ctx context.Context, exec bob.Executor, related ...*CommentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	comments1, err := insertPseudonymComments0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.Comments = append(pseudonym0.R.Comments, comments1...)

	for _, rel := range comments1 {
		rel.R.Pseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachComments(ctx context.Context, exec bob.Executor, related ...*Comment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	comments1 := CommentSlice(related)

	_, err = attachPseudonymComments0(ctx, exec, len(related), comments1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.Comments = append(pseudonym0.R.Comments, comments1...)

	for _, rel := range related {
		rel.R.Pseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymRemovedByPseudonymComments0(ctx context.Context, exec bob.Executor, comments1 []*CommentSetter, pseudonym0 *Pseudonym) (CommentSlice, error) {
	for i := range comments1 {
		comments1[i].RemovedByPseudonymID = func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}()
	}

	ret, err := Comments.Insert(bob.ToMods(comments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymRemovedByPseudonymComments0: %w", err)
	}

	return ret, nil
}

func attachPseudonymRemovedByPseudonymComments0(ctx context.Context, exec bob.Executor, count int, comments1 CommentSlice, pseudonym0 *Pseudonym) (CommentSlice, error) {
	setter := &CommentSetter{
		RemovedByPseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := comments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymRemovedByPseudonymComments0: %w", err)
	}

	return comments1, nil
}

func (pseudonym0 *Pseudonym) InsertRemovedByPseudonymComments(ctx context.Context, exec bob.Executor, related ...*CommentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	comments1, err := insertPseudonymRemovedByPseudonymComments0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.RemovedByPseudonymComments = append(pseudonym0.R.RemovedByPseudonymComments, comments1...)

	for _, rel := range comments1 {
		rel.R.RemovedByPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachRemovedByPseudonymComments(ctx context.Context, exec bob.Executor, related ...*Comment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	comments1 := CommentSlice(related)

	_, err = attachPseudonymRemovedByPseudonymComments0(ctx, exec, len(related), comments1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.RemovedByPseudonymComments = append(pseudonym0.R.RemovedByPseudonymComments, comments1...)

	for _, rel := range related {
		rel.R.RemovedByPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymCorrelationAudits0(ctx context.Context, exec bob.Executor, correlationAudits1 []*CorrelationAuditSetter, pseudonym0 *Pseudonym) (CorrelationAuditSlice, error) {
	for i := range correlationAudits1 {
		correlationAudits1[i].PseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := CorrelationAudits.Insert(bob.ToMods(correlationAudits1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymCorrelationAudits0: %w", err)
	}

	return ret, nil
}

func attachPseudonymCorrelationAudits0(ctx context.Context, exec bob.Executor, count int, correlationAudits1 CorrelationAuditSlice, pseudonym0 *Pseudonym) (CorrelationAuditSlice, error) {
	setter := &CorrelationAuditSetter{
		PseudonymID: &pseudonym0.PseudonymID,
	}

	err := correlationAudits1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymCorrelationAudits0: %w", err)
	}

	return correlationAudits1, nil
}

func (pseudonym0 *Pseudonym) InsertCorrelationAudits(ctx context.Context, exec bob.Executor, related ...*CorrelationAuditSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	correlationAudits1, err := insertPseudonymCorrelationAudits0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.CorrelationAudits = append(pseudonym0.R.CorrelationAudits, correlationAudits1...)

	for _, rel := range correlationAudits1 {
		rel.R.Pseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachCorrelationAudits(ctx context.Context, exec bob.Executor, related ...*CorrelationAudit) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	correlationAudits1 := CorrelationAuditSlice(related)

	_, err = attachPseudonymCorrelationAudits0(ctx, exec, len(related), correlationAudits1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.CorrelationAudits = append(pseudonym0.R.CorrelationAudits, correlationAudits1...)

	for _, rel := range related {
		rel.R.Pseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymRecipientPseudonymDirectMessages0(ctx context.Context, exec bob.Executor, directMessages1 []*DirectMessageSetter, pseudonym0 *Pseudonym) (DirectMessageSlice, error) {
	for i := range directMessages1 {
		directMessages1[i].RecipientPseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := DirectMessages.Insert(bob.ToMods(directMessages1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymRecipientPseudonymDirectMessages0: %w", err)
	}

	return ret, nil
}

func attachPseudonymRecipientPseudonymDirectMessages0(ctx context.Context, exec bob.Executor, count int, directMessages1 DirectMessageSlice, pseudonym0 *Pseudonym) (DirectMessageSlice, error) {
	setter := &DirectMessageSetter{
		RecipientPseudonymID: &pseudonym0.PseudonymID,
	}

	err := directMessages1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymRecipientPseudonymDirectMessages0: %w", err)
	}

	return directMessages1, nil
}

func (pseudonym0 *Pseudonym) InsertRecipientPseudonymDirectMessages(ctx context.Context, exec bob.Executor, related ...*DirectMessageSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	directMessages1, err := insertPseudonymRecipientPseudonymDirectMessages0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.RecipientPseudonymDirectMessages = append(pseudonym0.R.RecipientPseudonymDirectMessages, directMessages1...)

	for _, rel := range directMessages1 {
		rel.R.RecipientPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachRecipientPseudonymDirectMessages(ctx context.Context, exec bob.Executor, related ...*DirectMessage) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	directMessages1 := DirectMessageSlice(related)

	_, err = attachPseudonymRecipientPseudonymDirectMessages0(ctx, exec, len(related), directMessages1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.RecipientPseudonymDirectMessages = append(pseudonym0.R.RecipientPseudonymDirectMessages, directMessages1...)

	for _, rel := range related {
		rel.R.RecipientPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymSenderPseudonymDirectMessages0(ctx context.Context, exec bob.Executor, directMessages1 []*DirectMessageSetter, pseudonym0 *Pseudonym) (DirectMessageSlice, error) {
	for i := range directMessages1 {
		directMessages1[i].SenderPseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := DirectMessages.Insert(bob.ToMods(directMessages1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymSenderPseudonymDirectMessages0: %w", err)
	}

	return ret, nil
}

func attachPseudonymSenderPseudonymDirectMessages0(ctx context.Context, exec bob.Executor, count int, directMessages1 DirectMessageSlice, pseudonym0 *Pseudonym) (DirectMessageSlice, error) {
	setter := &DirectMessageSetter{
		SenderPseudonymID: &pseudonym0.PseudonymID,
	}

	err := directMessages1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymSenderPseudonymDirectMessages0: %w", err)
	}

	return directMessages1, nil
}

func (pseudonym0 *Pseudonym) InsertSenderPseudonymDirectMessages(ctx context.Context, exec bob.Executor, related ...*DirectMessageSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	directMessages1, err := insertPseudonymSenderPseudonymDirectMessages0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.SenderPseudonymDirectMessages = append(pseudonym0.R.SenderPseudonymDirectMessages, directMessages1...)

	for _, rel := range directMessages1 {
		rel.R.SenderPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachSenderPseudonymDirectMessages(ctx context.Context, exec bob.Executor, related ...*DirectMessage) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	directMessages1 := DirectMessageSlice(related)

	_, err = attachPseudonymSenderPseudonymDirectMessages0(ctx, exec, len(related), directMessages1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.SenderPseudonymDirectMessages = append(pseudonym0.R.SenderPseudonymDirectMessages, directMessages1...)

	for _, rel := range related {
		rel.R.SenderPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymModeratorPseudonymModerationActions0(ctx context.Context, exec bob.Executor, moderationActions1 []*ModerationActionSetter, pseudonym0 *Pseudonym) (ModerationActionSlice, error) {
	for i := range moderationActions1 {
		moderationActions1[i].ModeratorPseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := ModerationActions.Insert(bob.ToMods(moderationActions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymModeratorPseudonymModerationActions0: %w", err)
	}

	return ret, nil
}

func attachPseudonymModeratorPseudonymModerationActions0(ctx context.Context, exec bob.Executor, count int, moderationActions1 ModerationActionSlice, pseudonym0 *Pseudonym) (ModerationActionSlice, error) {
	setter := &ModerationActionSetter{
		ModeratorPseudonymID: &pseudonym0.PseudonymID,
	}

	err := moderationActions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymModeratorPseudonymModerationActions0: %w", err)
	}

	return moderationActions1, nil
}

func (pseudonym0 *Pseudonym) InsertModeratorPseudonymModerationActions(ctx context.Context, exec bob.Executor, related ...*ModerationActionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	moderationActions1, err := insertPseudonymModeratorPseudonymModerationActions0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.ModeratorPseudonymModerationActions = append(pseudonym0.R.ModeratorPseudonymModerationActions, moderationActions1...)

	for _, rel := range moderationActions1 {
		rel.R.ModeratorPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachModeratorPseudonymModerationActions(ctx context.Context, exec bob.Executor, related ...*ModerationAction) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	moderationActions1 := ModerationActionSlice(related)

	_, err = attachPseudonymModeratorPseudonymModerationActions0(ctx, exec, len(related), moderationActions1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.ModeratorPseudonymModerationActions = append(pseudonym0.R.ModeratorPseudonymModerationActions, moderationActions1...)

	for _, rel := range related {
		rel.R.ModeratorPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymPollVotes0(ctx context.Context, exec bob.Executor, pollVotes1 []*PollVoteSetter, pseudonym0 *Pseudonym) (PollVoteSlice, error) {
	for i := range pollVotes1 {
		pollVotes1[i].PseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := PollVotes.Insert(bob.ToMods(pollVotes1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymPollVotes0: %w", err)
	}

	return ret, nil
}

func attachPseudonymPollVotes0(ctx context.Context, exec bob.Executor, count int, pollVotes1 PollVoteSlice, pseudonym0 *Pseudonym) (PollVoteSlice, error) {
	setter := &PollVoteSetter{
		PseudonymID: &pseudonym0.PseudonymID,
	}

	err := pollVotes1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymPollVotes0: %w", err)
	}

	return pollVotes1, nil
}

func (pseudonym0 *Pseudonym) InsertPollVotes(ctx context.Context, exec bob.Executor, related ...*PollVoteSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	pollVotes1, err := insertPseudonymPollVotes0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.PollVotes = append(pseudonym0.R.PollVotes, pollVotes1...)

	for _, rel := range pollVotes1 {
		rel.R.Pseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachPollVotes(ctx context.Context, exec bob.Executor, related ...*PollVote) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	pollVotes1 := PollVoteSlice(related)

	_, err = attachPseudonymPollVotes0(ctx, exec, len(related), pollVotes1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.PollVotes = append(pseudonym0.R.PollVotes, pollVotes1...)

	for _, rel := range related {
		rel.R.Pseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymPosts0(ctx context.Context, exec bob.Executor, posts1 []*PostSetter, pseudonym0 *Pseudonym) (PostSlice, error) {
	for i := range posts1 {
		posts1[i].PseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := Posts.Insert(bob.ToMods(posts1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymPosts0: %w", err)
	}

	return ret, nil
}

func attachPseudonymPosts0(ctx context.Context, exec bob.Executor, count int, posts1 PostSlice, pseudonym0 *Pseudonym) (PostSlice, error) {
	setter := &PostSetter{
		PseudonymID: &pseudonym0.PseudonymID,
	}

	err := posts1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymPosts0: %w", err)
	}

	return posts1, nil
}

func (pseudonym0 *Pseudonym) InsertPosts(ctx context.Context, exec bob.Executor, related ...*PostSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	posts1, err := insertPseudonymPosts0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.Posts = append(pseudonym0.R.Posts, posts1...)

	for _, rel := range posts1 {
		rel.R.Pseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachPosts(ctx context.Context, exec bob.Executor, related ...*Post) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	posts1 := PostSlice(related)

	_, err = attachPseudonymPosts0(ctx, exec, len(related), posts1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.Posts = append(pseudonym0.R.Posts, posts1...)

	for _, rel := range related {
		rel.R.Pseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymRemovedByPseudonymPosts0(ctx context.Context, exec bob.Executor, posts1 []*PostSetter, pseudonym0 *Pseudonym) (PostSlice, error) {
	for i := range posts1 {
		posts1[i].RemovedByPseudonymID = func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}()
	}

	ret, err := Posts.Insert(bob.ToMods(posts1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymRemovedByPseudonymPosts0: %w", err)
	}

	return ret, nil
}

func attachPseudonymRemovedByPseudonymPosts0(ctx context.Context, exec bob.Executor, count int, posts1 PostSlice, pseudonym0 *Pseudonym) (PostSlice, error) {
	setter := &PostSetter{
		RemovedByPseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := posts1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymRemovedByPseudonymPosts0: %w", err)
	}

	return posts1, nil
}

func (pseudonym0 *Pseudonym) InsertRemovedByPseudonymPosts(ctx context.Context, exec bob.Executor, related ...*PostSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	posts1, err := insertPseudonymRemovedByPseudonymPosts0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.RemovedByPseudonymPosts = append(pseudonym0.R.RemovedByPseudonymPosts, posts1...)

	for _, rel := range posts1 {
		rel.R.RemovedByPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachRemovedByPseudonymPosts(ctx context.Context, exec bob.Executor, related ...*Post) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	posts1 := PostSlice(related)

	_, err = attachPseudonymRemovedByPseudonymPosts0(ctx, exec, len(related), posts1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.RemovedByPseudonymPosts = append(pseudonym0.R.RemovedByPseudonymPosts, posts1...)

	for _, rel := range related {
		rel.R.RemovedByPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymReportedPseudonymReports0(ctx context.Context, exec bob.Executor, reports1 []*ReportSetter, pseudonym0 *Pseudonym) (ReportSlice, error) {
	for i := range reports1 {
		reports1[i].ReportedPseudonymID = func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}()
	}

	ret, err := Reports.Insert(bob.ToMods(reports1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymReportedPseudonymReports0: %w", err)
	}

	return ret, nil
}

func attachPseudonymReportedPseudonymReports0(ctx context.Context, exec bob.Executor, count int, reports1 ReportSlice, pseudonym0 *Pseudonym) (ReportSlice, error) {
	setter := &ReportSetter{
		ReportedPseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := reports1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymReportedPseudonymReports0: %w", err)
	}

	return reports1, nil
}

func (pseudonym0 *Pseudonym) InsertReportedPseudonymReports(ctx context.Context, exec bob.Executor, related ...*ReportSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	reports1, err := insertPseudonymReportedPseudonymReports0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.ReportedPseudonymReports = append(pseudonym0.R.ReportedPseudonymReports, reports1...)

	for _, rel := range reports1 {
		rel.R.ReportedPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachReportedPseudonymReports(ctx context.Context, exec bob.Executor, related ...*Report) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	reports1 := ReportSlice(related)

	_, err = attachPseudonymReportedPseudonymReports0(ctx, exec, len(related), reports1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.ReportedPseudonymReports = append(pseudonym0.R.ReportedPseudonymReports, reports1...)

	for _, rel := range related {
		rel.R.ReportedPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymReporterPseudonymReports0(ctx context.Context, exec bob.Executor, reports1 []*ReportSetter, pseudonym0 *Pseudonym) (ReportSlice, error) {
	for i := range reports1 {
		reports1[i].ReporterPseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := Reports.Insert(bob.ToMods(reports1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymReporterPseudonymReports0: %w", err)
	}

	return ret, nil
}

func attachPseudonymReporterPseudonymReports0(ctx context.Context, exec bob.Executor, count int, reports1 ReportSlice, pseudonym0 *Pseudonym) (ReportSlice, error) {
	setter := &ReportSetter{
		ReporterPseudonymID: &pseudonym0.PseudonymID,
	}

	err := reports1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymReporterPseudonymReports0: %w", err)
	}

	return reports1, nil
}

func (pseudonym0 *Pseudonym) InsertReporterPseudonymReports(ctx context.Context, exec bob.Executor, related ...*ReportSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	reports1, err := insertPseudonymReporterPseudonymReports0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.ReporterPseudonymReports = append(pseudonym0.R.ReporterPseudonymReports, reports1...)

	for _, rel := range reports1 {
		rel.R.ReporterPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachReporterPseudonymReports(ctx context.Context, exec bob.Executor, related ...*Report) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	reports1 := ReportSlice(related)

	_, err = attachPseudonymReporterPseudonymReports0(ctx, exec, len(related), reports1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.ReporterPseudonymReports = append(pseudonym0.R.ReporterPseudonymReports, reports1...)

	for _, rel := range related {
		rel.R.ReporterPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymResolvedByPseudonymReports0(ctx context.Context, exec bob.Executor, reports1 []*ReportSetter, pseudonym0 *Pseudonym) (ReportSlice, error) {
	for i := range reports1 {
		reports1[i].ResolvedByPseudonymID = func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}()
	}

	ret, err := Reports.Insert(bob.ToMods(reports1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymResolvedByPseudonymReports0: %w", err)
	}

	return ret, nil
}

func attachPseudonymResolvedByPseudonymReports0(ctx context.Context, exec bob.Executor, count int, reports1 ReportSlice, pseudonym0 *Pseudonym) (ReportSlice, error) {
	setter := &ReportSetter{
		ResolvedByPseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := reports1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymResolvedByPseudonymReports0: %w", err)
	}

	return reports1, nil
}

func (pseudonym0 *Pseudonym) InsertResolvedByPseudonymReports(ctx context.Context, exec bob.Executor, related ...*ReportSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	reports1, err := insertPseudonymResolvedByPseudonymReports0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.ResolvedByPseudonymReports = append(pseudonym0.R.ResolvedByPseudonymReports, reports1...)

	for _, rel := range reports1 {
		rel.R.ResolvedByPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachResolvedByPseudonymReports(ctx context.Context, exec bob.Executor, related ...*Report) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	reports1 := ReportSlice(related)

	_, err = attachPseudonymResolvedByPseudonymReports0(ctx, exec, len(related), reports1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.ResolvedByPseudonymReports = append(pseudonym0.R.ResolvedByPseudonymReports, reports1...)

	for _, rel := range related {
		rel.R.ResolvedByPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymSubforumModerators0(ctx context.Context, exec bob.Executor, subforumModerators1 []*SubforumModeratorSetter, pseudonym0 *Pseudonym) (SubforumModeratorSlice, error) {
	for i := range subforumModerators1 {
		subforumModerators1[i].PseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := SubforumModerators.Insert(bob.ToMods(subforumModerators1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymSubforumModerators0: %w", err)
	}

	return ret, nil
}

func attachPseudonymSubforumModerators0(ctx context.Context, exec bob.Executor, count int, subforumModerators1 SubforumModeratorSlice, pseudonym0 *Pseudonym) (SubforumModeratorSlice, error) {
	setter := &SubforumModeratorSetter{
		PseudonymID: &pseudonym0.PseudonymID,
	}

	err := subforumModerators1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymSubforumModerators0: %w", err)
	}

	return subforumModerators1, nil
}

func (pseudonym0 *Pseudonym) InsertSubforumModerators(ctx context.Context, exec bob.Executor, related ...*SubforumModeratorSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	subforumModerators1, err := insertPseudonymSubforumModerators0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.SubforumModerators = append(pseudonym0.R.SubforumModerators, subforumModerators1...)

	for _, rel := range subforumModerators1 {
		rel.R.Pseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachSubforumModerators(ctx context.Context, exec bob.Executor, related ...*SubforumModerator) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	subforumModerators1 := SubforumModeratorSlice(related)

	_, err = attachPseudonymSubforumModerators0(ctx, exec, len(related), subforumModerators1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.SubforumModerators = append(pseudonym0.R.SubforumModerators, subforumModerators1...)

	for _, rel := range related {
		rel.R.Pseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymSubforumSubscriptions0(ctx context.Context, exec bob.Executor, subforumSubscriptions1 []*SubforumSubscriptionSetter, pseudonym0 *Pseudonym) (SubforumSubscriptionSlice, error) {
	for i := range subforumSubscriptions1 {
		subforumSubscriptions1[i].PseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := SubforumSubscriptions.Insert(bob.ToMods(subforumSubscriptions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymSubforumSubscriptions0: %w", err)
	}

	return ret, nil
}

func attachPseudonymSubforumSubscriptions0(ctx context.Context, exec bob.Executor, count int, subforumSubscriptions1 SubforumSubscriptionSlice, pseudonym0 *Pseudonym) (SubforumSubscriptionSlice, error) {
	setter := &SubforumSubscriptionSetter{
		PseudonymID: &pseudonym0.PseudonymID,
	}

	err := subforumSubscriptions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymSubforumSubscriptions0: %w", err)
	}

	return subforumSubscriptions1, nil
}

func (pseudonym0 *Pseudonym) InsertSubforumSubscriptions(ctx context.Context, exec bob.Executor, related ...*SubforumSubscriptionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	subforumSubscriptions1, err := insertPseudonymSubforumSubscriptions0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.SubforumSubscriptions = append(pseudonym0.R.SubforumSubscriptions, subforumSubscriptions1...)

	for _, rel := range subforumSubscriptions1 {
		rel.R.Pseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachSubforumSubscriptions(ctx context.Context, exec bob.Executor, related ...*SubforumSubscription) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	subforumSubscriptions1 := SubforumSubscriptionSlice(related)

	_, err = attachPseudonymSubforumSubscriptions0(ctx, exec, len(related), subforumSubscriptions1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.SubforumSubscriptions = append(pseudonym0.R.SubforumSubscriptions, subforumSubscriptions1...)

	for _, rel := range related {
		rel.R.Pseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymBannedByPseudonymUserBans0(ctx context.Context, exec bob.Executor, userBans1 []*UserBanSetter, pseudonym0 *Pseudonym) (UserBanSlice, error) {
	for i := range userBans1 {
		userBans1[i].BannedByPseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := UserBans.Insert(bob.ToMods(userBans1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymBannedByPseudonymUserBans0: %w", err)
	}

	return ret, nil
}

func attachPseudonymBannedByPseudonymUserBans0(ctx context.Context, exec bob.Executor, count int, userBans1 UserBanSlice, pseudonym0 *Pseudonym) (UserBanSlice, error) {
	setter := &UserBanSetter{
		BannedByPseudonymID: &pseudonym0.PseudonymID,
	}

	err := userBans1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymBannedByPseudonymUserBans0: %w", err)
	}

	return userBans1, nil
}

func (pseudonym0 *Pseudonym) InsertBannedByPseudonymUserBans(ctx context.Context, exec bob.Executor, related ...*UserBanSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	userBans1, err := insertPseudonymBannedByPseudonymUserBans0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.BannedByPseudonymUserBans = append(pseudonym0.R.BannedByPseudonymUserBans, userBans1...)

	for _, rel := range userBans1 {
		rel.R.BannedByPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachBannedByPseudonymUserBans(ctx context.Context, exec bob.Executor, related ...*UserBan) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	userBans1 := UserBanSlice(related)

	_, err = attachPseudonymBannedByPseudonymUserBans0(ctx, exec, len(related), userBans1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.BannedByPseudonymUserBans = append(pseudonym0.R.BannedByPseudonymUserBans, userBans1...)

	for _, rel := range related {
		rel.R.BannedByPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymBlockedPseudonymUserBlocks0(ctx context.Context, exec bob.Executor, userBlocks1 []*UserBlockSetter, pseudonym0 *Pseudonym) (UserBlockSlice, error) {
	for i := range userBlocks1 {
		userBlocks1[i].BlockedPseudonymID = func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}()
	}

	ret, err := UserBlocks.Insert(bob.ToMods(userBlocks1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymBlockedPseudonymUserBlocks0: %w", err)
	}

	return ret, nil
}

func attachPseudonymBlockedPseudonymUserBlocks0(ctx context.Context, exec bob.Executor, count int, userBlocks1 UserBlockSlice, pseudonym0 *Pseudonym) (UserBlockSlice, error) {
	setter := &UserBlockSetter{
		BlockedPseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym0.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := userBlocks1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymBlockedPseudonymUserBlocks0: %w", err)
	}

	return userBlocks1, nil
}

func (pseudonym0 *Pseudonym) InsertBlockedPseudonymUserBlocks(ctx context.Context, exec bob.Executor, related ...*UserBlockSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	userBlocks1, err := insertPseudonymBlockedPseudonymUserBlocks0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.BlockedPseudonymUserBlocks = append(pseudonym0.R.BlockedPseudonymUserBlocks, userBlocks1...)

	for _, rel := range userBlocks1 {
		rel.R.BlockedPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachBlockedPseudonymUserBlocks(ctx context.Context, exec bob.Executor, related ...*UserBlock) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	userBlocks1 := UserBlockSlice(related)

	_, err = attachPseudonymBlockedPseudonymUserBlocks0(ctx, exec, len(related), userBlocks1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.BlockedPseudonymUserBlocks = append(pseudonym0.R.BlockedPseudonymUserBlocks, userBlocks1...)

	for _, rel := range related {
		rel.R.BlockedPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymBlockerPseudonymUserBlocks0(ctx context.Context, exec bob.Executor, userBlocks1 []*UserBlockSetter, pseudonym0 *Pseudonym) (UserBlockSlice, error) {
	for i := range userBlocks1 {
		userBlocks1[i].BlockerPseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := UserBlocks.Insert(bob.ToMods(userBlocks1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymBlockerPseudonymUserBlocks0: %w", err)
	}

	return ret, nil
}

func attachPseudonymBlockerPseudonymUserBlocks0(ctx context.Context, exec bob.Executor, count int, userBlocks1 UserBlockSlice, pseudonym0 *Pseudonym) (UserBlockSlice, error) {
	setter := &UserBlockSetter{
		BlockerPseudonymID: &pseudonym0.PseudonymID,
	}

	err := userBlocks1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymBlockerPseudonymUserBlocks0: %w", err)
	}

	return userBlocks1, nil
}

func (pseudonym0 *Pseudonym) InsertBlockerPseudonymUserBlocks(ctx context.Context, exec bob.Executor, related ...*UserBlockSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	userBlocks1, err := insertPseudonymBlockerPseudonymUserBlocks0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.BlockerPseudonymUserBlocks = append(pseudonym0.R.BlockerPseudonymUserBlocks, userBlocks1...)

	for _, rel := range userBlocks1 {
		rel.R.BlockerPseudonymPseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachBlockerPseudonymUserBlocks(ctx context.Context, exec bob.Executor, related ...*UserBlock) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	userBlocks1 := UserBlockSlice(related)

	_, err = attachPseudonymBlockerPseudonymUserBlocks0(ctx, exec, len(related), userBlocks1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.BlockerPseudonymUserBlocks = append(pseudonym0.R.BlockerPseudonymUserBlocks, userBlocks1...)

	for _, rel := range related {
		rel.R.BlockerPseudonymPseudonym = pseudonym0
	}

	return nil
}

func insertPseudonymVotes0(ctx context.Context, exec bob.Executor, votes1 []*VoteSetter, pseudonym0 *Pseudonym) (VoteSlice, error) {
	for i := range votes1 {
		votes1[i].PseudonymID = &pseudonym0.PseudonymID
	}

	ret, err := Votes.Insert(bob.ToMods(votes1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPseudonymVotes0: %w", err)
	}

	return ret, nil
}

func attachPseudonymVotes0(ctx context.Context, exec bob.Executor, count int, votes1 VoteSlice, pseudonym0 *Pseudonym) (VoteSlice, error) {
	setter := &VoteSetter{
		PseudonymID: &pseudonym0.PseudonymID,
	}

	err := votes1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPseudonymVotes0: %w", err)
	}

	return votes1, nil
}

func (pseudonym0 *Pseudonym) InsertVotes(ctx context.Context, exec bob.Executor, related ...*VoteSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	votes1, err := insertPseudonymVotes0(ctx, exec, related, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.Votes = append(pseudonym0.R.Votes, votes1...)

	for _, rel := range votes1 {
		rel.R.Pseudonym = pseudonym0
	}
	return nil
}

func (pseudonym0 *Pseudonym) AttachVotes(ctx context.Context, exec bob.Executor, related ...*Vote) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	votes1 := VoteSlice(related)

	_, err = attachPseudonymVotes0(ctx, exec, len(related), votes1, pseudonym0)
	if err != nil {
		return err
	}

	pseudonym0.R.Votes = append(pseudonym0.R.Votes, votes1...)

	for _, rel := range related {
		rel.R.Pseudonym = pseudonym0
	}

	return nil
}
