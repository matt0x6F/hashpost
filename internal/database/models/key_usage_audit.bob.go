// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// KeyUsageAudit is an object representing the database table.
type KeyUsageAudit struct {
	UsageID           uuid.UUID              `db:"usage_id,pk" scan:"usage_id" json:"usage_id"`
	KeyID             uuid.UUID              `db:"key_id" scan:"key_id" json:"key_id"`
	UserID            int64                  `db:"user_id" scan:"user_id" json:"user_id"`
	OperationType     string                 `db:"operation_type" scan:"operation_type" json:"operation_type"`
	TargetFingerprint sql.Null[string]       `db:"target_fingerprint" scan:"target_fingerprint" json:"target_fingerprint"`
	TargetPseudonym   sql.Null[string]       `db:"target_pseudonym" scan:"target_pseudonym" json:"target_pseudonym"`
	Success           bool                   `db:"success" scan:"success" json:"success"`
	ErrorMessage      sql.Null[string]       `db:"error_message" scan:"error_message" json:"error_message"`
	Timestamp         sql.Null[time.Time]    `db:"timestamp" scan:"timestamp" json:"timestamp"`
	IPAddress         sql.Null[pgtypes.Inet] `db:"ip_address" scan:"ip_address" json:"ip_address"`
	UserAgent         sql.Null[string]       `db:"user_agent" scan:"user_agent" json:"user_agent"`

	R keyUsageAuditR `db:"-" scan:"rel" json:"rel"`
}

// KeyUsageAuditSlice is an alias for a slice of pointers to KeyUsageAudit.
// This should almost always be used instead of []*KeyUsageAudit.
type KeyUsageAuditSlice []*KeyUsageAudit

// KeyUsageAudits contains methods to work with the key_usage_audit table
var KeyUsageAudits = psql.NewTablex[*KeyUsageAudit, KeyUsageAuditSlice, *KeyUsageAuditSetter]("", "key_usage_audit")

// KeyUsageAuditsQuery is a query on the key_usage_audit table
type KeyUsageAuditsQuery = *psql.ViewQuery[*KeyUsageAudit, KeyUsageAuditSlice]

// keyUsageAuditR is where relationships are stored.
type keyUsageAuditR struct {
	KeyRoleKey *RoleKey `scan:"KeyRoleKey" json:"KeyRoleKey"` // key_usage_audit.key_usage_audit_key_id_fkey
	User       *User    `scan:"User" json:"User"`             // key_usage_audit.key_usage_audit_user_id_fkey
}

type keyUsageAuditColumnNames struct {
	UsageID           string
	KeyID             string
	UserID            string
	OperationType     string
	TargetFingerprint string
	TargetPseudonym   string
	Success           string
	ErrorMessage      string
	Timestamp         string
	IPAddress         string
	UserAgent         string
}

var KeyUsageAuditColumns = buildKeyUsageAuditColumns("key_usage_audit")

type keyUsageAuditColumns struct {
	tableAlias        string
	UsageID           psql.Expression
	KeyID             psql.Expression
	UserID            psql.Expression
	OperationType     psql.Expression
	TargetFingerprint psql.Expression
	TargetPseudonym   psql.Expression
	Success           psql.Expression
	ErrorMessage      psql.Expression
	Timestamp         psql.Expression
	IPAddress         psql.Expression
	UserAgent         psql.Expression
}

func (c keyUsageAuditColumns) Alias() string {
	return c.tableAlias
}

func (keyUsageAuditColumns) AliasedAs(alias string) keyUsageAuditColumns {
	return buildKeyUsageAuditColumns(alias)
}

func buildKeyUsageAuditColumns(alias string) keyUsageAuditColumns {
	return keyUsageAuditColumns{
		tableAlias:        alias,
		UsageID:           psql.Quote(alias, "usage_id"),
		KeyID:             psql.Quote(alias, "key_id"),
		UserID:            psql.Quote(alias, "user_id"),
		OperationType:     psql.Quote(alias, "operation_type"),
		TargetFingerprint: psql.Quote(alias, "target_fingerprint"),
		TargetPseudonym:   psql.Quote(alias, "target_pseudonym"),
		Success:           psql.Quote(alias, "success"),
		ErrorMessage:      psql.Quote(alias, "error_message"),
		Timestamp:         psql.Quote(alias, "timestamp"),
		IPAddress:         psql.Quote(alias, "ip_address"),
		UserAgent:         psql.Quote(alias, "user_agent"),
	}
}

type keyUsageAuditWhere[Q psql.Filterable] struct {
	UsageID           psql.WhereMod[Q, uuid.UUID]
	KeyID             psql.WhereMod[Q, uuid.UUID]
	UserID            psql.WhereMod[Q, int64]
	OperationType     psql.WhereMod[Q, string]
	TargetFingerprint psql.WhereNullMod[Q, string]
	TargetPseudonym   psql.WhereNullMod[Q, string]
	Success           psql.WhereMod[Q, bool]
	ErrorMessage      psql.WhereNullMod[Q, string]
	Timestamp         psql.WhereNullMod[Q, time.Time]
	IPAddress         psql.WhereNullMod[Q, pgtypes.Inet]
	UserAgent         psql.WhereNullMod[Q, string]
}

func (keyUsageAuditWhere[Q]) AliasedAs(alias string) keyUsageAuditWhere[Q] {
	return buildKeyUsageAuditWhere[Q](buildKeyUsageAuditColumns(alias))
}

func buildKeyUsageAuditWhere[Q psql.Filterable](cols keyUsageAuditColumns) keyUsageAuditWhere[Q] {
	return keyUsageAuditWhere[Q]{
		UsageID:           psql.Where[Q, uuid.UUID](cols.UsageID),
		KeyID:             psql.Where[Q, uuid.UUID](cols.KeyID),
		UserID:            psql.Where[Q, int64](cols.UserID),
		OperationType:     psql.Where[Q, string](cols.OperationType),
		TargetFingerprint: psql.WhereNull[Q, string](cols.TargetFingerprint),
		TargetPseudonym:   psql.WhereNull[Q, string](cols.TargetPseudonym),
		Success:           psql.Where[Q, bool](cols.Success),
		ErrorMessage:      psql.WhereNull[Q, string](cols.ErrorMessage),
		Timestamp:         psql.WhereNull[Q, time.Time](cols.Timestamp),
		IPAddress:         psql.WhereNull[Q, pgtypes.Inet](cols.IPAddress),
		UserAgent:         psql.WhereNull[Q, string](cols.UserAgent),
	}
}

var KeyUsageAuditErrors = &keyUsageAuditErrors{
	ErrUniqueKeyUsageAuditPkey: &UniqueConstraintError{
		schema:  "",
		table:   "key_usage_audit",
		columns: []string{"usage_id"},
		s:       "key_usage_audit_pkey",
	},
}

type keyUsageAuditErrors struct {
	ErrUniqueKeyUsageAuditPkey *UniqueConstraintError
}

// KeyUsageAuditSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type KeyUsageAuditSetter struct {
	UsageID           *uuid.UUID              `db:"usage_id,pk" scan:"usage_id" json:"usage_id"`
	KeyID             *uuid.UUID              `db:"key_id" scan:"key_id" json:"key_id"`
	UserID            *int64                  `db:"user_id" scan:"user_id" json:"user_id"`
	OperationType     *string                 `db:"operation_type" scan:"operation_type" json:"operation_type"`
	TargetFingerprint *sql.Null[string]       `db:"target_fingerprint" scan:"target_fingerprint" json:"target_fingerprint"`
	TargetPseudonym   *sql.Null[string]       `db:"target_pseudonym" scan:"target_pseudonym" json:"target_pseudonym"`
	Success           *bool                   `db:"success" scan:"success" json:"success"`
	ErrorMessage      *sql.Null[string]       `db:"error_message" scan:"error_message" json:"error_message"`
	Timestamp         *sql.Null[time.Time]    `db:"timestamp" scan:"timestamp" json:"timestamp"`
	IPAddress         *sql.Null[pgtypes.Inet] `db:"ip_address" scan:"ip_address" json:"ip_address"`
	UserAgent         *sql.Null[string]       `db:"user_agent" scan:"user_agent" json:"user_agent"`
}

func (s KeyUsageAuditSetter) SetColumns() []string {
	vals := make([]string, 0, 11)
	if s.UsageID != nil {
		vals = append(vals, "usage_id")
	}

	if s.KeyID != nil {
		vals = append(vals, "key_id")
	}

	if s.UserID != nil {
		vals = append(vals, "user_id")
	}

	if s.OperationType != nil {
		vals = append(vals, "operation_type")
	}

	if s.TargetFingerprint != nil {
		vals = append(vals, "target_fingerprint")
	}

	if s.TargetPseudonym != nil {
		vals = append(vals, "target_pseudonym")
	}

	if s.Success != nil {
		vals = append(vals, "success")
	}

	if s.ErrorMessage != nil {
		vals = append(vals, "error_message")
	}

	if s.Timestamp != nil {
		vals = append(vals, "timestamp")
	}

	if s.IPAddress != nil {
		vals = append(vals, "ip_address")
	}

	if s.UserAgent != nil {
		vals = append(vals, "user_agent")
	}

	return vals
}

func (s KeyUsageAuditSetter) Overwrite(t *KeyUsageAudit) {
	if s.UsageID != nil {
		t.UsageID = *s.UsageID
	}
	if s.KeyID != nil {
		t.KeyID = *s.KeyID
	}
	if s.UserID != nil {
		t.UserID = *s.UserID
	}
	if s.OperationType != nil {
		t.OperationType = *s.OperationType
	}
	if s.TargetFingerprint != nil {
		t.TargetFingerprint = *s.TargetFingerprint
	}
	if s.TargetPseudonym != nil {
		t.TargetPseudonym = *s.TargetPseudonym
	}
	if s.Success != nil {
		t.Success = *s.Success
	}
	if s.ErrorMessage != nil {
		t.ErrorMessage = *s.ErrorMessage
	}
	if s.Timestamp != nil {
		t.Timestamp = *s.Timestamp
	}
	if s.IPAddress != nil {
		t.IPAddress = *s.IPAddress
	}
	if s.UserAgent != nil {
		t.UserAgent = *s.UserAgent
	}
}

func (s *KeyUsageAuditSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return KeyUsageAudits.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 11)
		if s.UsageID != nil {
			vals[0] = psql.Arg(*s.UsageID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.KeyID != nil {
			vals[1] = psql.Arg(*s.KeyID)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.UserID != nil {
			vals[2] = psql.Arg(*s.UserID)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.OperationType != nil {
			vals[3] = psql.Arg(*s.OperationType)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.TargetFingerprint != nil {
			vals[4] = psql.Arg(*s.TargetFingerprint)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.TargetPseudonym != nil {
			vals[5] = psql.Arg(*s.TargetPseudonym)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.Success != nil {
			vals[6] = psql.Arg(*s.Success)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.ErrorMessage != nil {
			vals[7] = psql.Arg(*s.ErrorMessage)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.Timestamp != nil {
			vals[8] = psql.Arg(*s.Timestamp)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.IPAddress != nil {
			vals[9] = psql.Arg(*s.IPAddress)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.UserAgent != nil {
			vals[10] = psql.Arg(*s.UserAgent)
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s KeyUsageAuditSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s KeyUsageAuditSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 11)

	if s.UsageID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "usage_id")...),
			psql.Arg(s.UsageID),
		}})
	}

	if s.KeyID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "key_id")...),
			psql.Arg(s.KeyID),
		}})
	}

	if s.UserID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "user_id")...),
			psql.Arg(s.UserID),
		}})
	}

	if s.OperationType != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "operation_type")...),
			psql.Arg(s.OperationType),
		}})
	}

	if s.TargetFingerprint != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "target_fingerprint")...),
			psql.Arg(s.TargetFingerprint),
		}})
	}

	if s.TargetPseudonym != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "target_pseudonym")...),
			psql.Arg(s.TargetPseudonym),
		}})
	}

	if s.Success != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "success")...),
			psql.Arg(s.Success),
		}})
	}

	if s.ErrorMessage != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "error_message")...),
			psql.Arg(s.ErrorMessage),
		}})
	}

	if s.Timestamp != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "timestamp")...),
			psql.Arg(s.Timestamp),
		}})
	}

	if s.IPAddress != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "ip_address")...),
			psql.Arg(s.IPAddress),
		}})
	}

	if s.UserAgent != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "user_agent")...),
			psql.Arg(s.UserAgent),
		}})
	}

	return exprs
}

// FindKeyUsageAudit retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindKeyUsageAudit(ctx context.Context, exec bob.Executor, UsageIDPK uuid.UUID, cols ...string) (*KeyUsageAudit, error) {
	if len(cols) == 0 {
		return KeyUsageAudits.Query(
			SelectWhere.KeyUsageAudits.UsageID.EQ(UsageIDPK),
		).One(ctx, exec)
	}

	return KeyUsageAudits.Query(
		SelectWhere.KeyUsageAudits.UsageID.EQ(UsageIDPK),
		sm.Columns(KeyUsageAudits.Columns().Only(cols...)),
	).One(ctx, exec)
}

// KeyUsageAuditExists checks the presence of a single record by primary key
func KeyUsageAuditExists(ctx context.Context, exec bob.Executor, UsageIDPK uuid.UUID) (bool, error) {
	return KeyUsageAudits.Query(
		SelectWhere.KeyUsageAudits.UsageID.EQ(UsageIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after KeyUsageAudit is retrieved from the database
func (o *KeyUsageAudit) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = KeyUsageAudits.AfterSelectHooks.RunHooks(ctx, exec, KeyUsageAuditSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = KeyUsageAudits.AfterInsertHooks.RunHooks(ctx, exec, KeyUsageAuditSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = KeyUsageAudits.AfterUpdateHooks.RunHooks(ctx, exec, KeyUsageAuditSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = KeyUsageAudits.AfterDeleteHooks.RunHooks(ctx, exec, KeyUsageAuditSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the KeyUsageAudit
func (o *KeyUsageAudit) primaryKeyVals() bob.Expression {
	return psql.Arg(o.UsageID)
}

func (o *KeyUsageAudit) pkEQ() dialect.Expression {
	return psql.Quote("key_usage_audit", "usage_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the KeyUsageAudit
func (o *KeyUsageAudit) Update(ctx context.Context, exec bob.Executor, s *KeyUsageAuditSetter) error {
	v, err := KeyUsageAudits.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single KeyUsageAudit record with an executor
func (o *KeyUsageAudit) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := KeyUsageAudits.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the KeyUsageAudit using the executor
func (o *KeyUsageAudit) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := KeyUsageAudits.Query(
		SelectWhere.KeyUsageAudits.UsageID.EQ(o.UsageID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after KeyUsageAuditSlice is retrieved from the database
func (o KeyUsageAuditSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = KeyUsageAudits.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = KeyUsageAudits.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = KeyUsageAudits.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = KeyUsageAudits.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o KeyUsageAuditSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("key_usage_audit", "usage_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o KeyUsageAuditSlice) copyMatchingRows(from ...*KeyUsageAudit) {
	for i, old := range o {
		for _, new := range from {
			if new.UsageID != old.UsageID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o KeyUsageAuditSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return KeyUsageAudits.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *KeyUsageAudit:
				o.copyMatchingRows(retrieved)
			case []*KeyUsageAudit:
				o.copyMatchingRows(retrieved...)
			case KeyUsageAuditSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a KeyUsageAudit or a slice of KeyUsageAudit
				// then run the AfterUpdateHooks on the slice
				_, err = KeyUsageAudits.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o KeyUsageAuditSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return KeyUsageAudits.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *KeyUsageAudit:
				o.copyMatchingRows(retrieved)
			case []*KeyUsageAudit:
				o.copyMatchingRows(retrieved...)
			case KeyUsageAuditSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a KeyUsageAudit or a slice of KeyUsageAudit
				// then run the AfterDeleteHooks on the slice
				_, err = KeyUsageAudits.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o KeyUsageAuditSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals KeyUsageAuditSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := KeyUsageAudits.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o KeyUsageAuditSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := KeyUsageAudits.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o KeyUsageAuditSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := KeyUsageAudits.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type keyUsageAuditJoins[Q dialect.Joinable] struct {
	typ        string
	KeyRoleKey modAs[Q, roleKeyColumns]
	User       modAs[Q, userColumns]
}

func (j keyUsageAuditJoins[Q]) aliasedAs(alias string) keyUsageAuditJoins[Q] {
	return buildKeyUsageAuditJoins[Q](buildKeyUsageAuditColumns(alias), j.typ)
}

func buildKeyUsageAuditJoins[Q dialect.Joinable](cols keyUsageAuditColumns, typ string) keyUsageAuditJoins[Q] {
	return keyUsageAuditJoins[Q]{
		typ: typ,
		KeyRoleKey: modAs[Q, roleKeyColumns]{
			c: RoleKeyColumns,
			f: func(to roleKeyColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, RoleKeys.Name().As(to.Alias())).On(
						to.KeyID.EQ(cols.KeyID),
					))
				}

				return mods
			},
		},
		User: modAs[Q, userColumns]{
			c: UserColumns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
	}
}

// KeyRoleKey starts a query for related objects on role_keys
func (o *KeyUsageAudit) KeyRoleKey(mods ...bob.Mod[*dialect.SelectQuery]) RoleKeysQuery {
	return RoleKeys.Query(append(mods,
		sm.Where(RoleKeyColumns.KeyID.EQ(psql.Arg(o.KeyID))),
	)...)
}

func (os KeyUsageAuditSlice) KeyRoleKey(mods ...bob.Mod[*dialect.SelectQuery]) RoleKeysQuery {
	pkKeyID := make(pgtypes.Array[uuid.UUID], len(os))
	for i, o := range os {
		pkKeyID[i] = o.KeyID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkKeyID), "uuid[]")),
	))

	return RoleKeys.Query(append(mods,
		sm.Where(psql.Group(RoleKeyColumns.KeyID).OP("IN", PKArgExpr)),
	)...)
}

// User starts a query for related objects on users
func (o *KeyUsageAudit) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(UserColumns.UserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os KeyUsageAuditSlice) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(UserColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

func (o *KeyUsageAudit) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "KeyRoleKey":
		rel, ok := retrieved.(*RoleKey)
		if !ok {
			return fmt.Errorf("keyUsageAudit cannot load %T as %q", retrieved, name)
		}

		o.R.KeyRoleKey = rel

		if rel != nil {
			rel.R.KeyKeyUsageAudits = KeyUsageAuditSlice{o}
		}
		return nil
	case "User":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("keyUsageAudit cannot load %T as %q", retrieved, name)
		}

		o.R.User = rel

		if rel != nil {
			rel.R.KeyUsageAudits = KeyUsageAuditSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("keyUsageAudit has no relationship %q", name)
	}
}

type keyUsageAuditPreloader struct {
	KeyRoleKey func(...psql.PreloadOption) psql.Preloader
	User       func(...psql.PreloadOption) psql.Preloader
}

func buildKeyUsageAuditPreloader() keyUsageAuditPreloader {
	return keyUsageAuditPreloader{
		KeyRoleKey: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*RoleKey, RoleKeySlice](orm.Relationship{
				Name: "KeyRoleKey",
				Sides: []orm.RelSide{
					{
						From: TableNames.KeyUsageAudits,
						To:   TableNames.RoleKeys,
						FromColumns: []string{
							ColumnNames.KeyUsageAudits.KeyID,
						},
						ToColumns: []string{
							ColumnNames.RoleKeys.KeyID,
						},
					},
				},
			}, RoleKeys.Columns().Names(), opts...)
		},
		User: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](orm.Relationship{
				Name: "User",
				Sides: []orm.RelSide{
					{
						From: TableNames.KeyUsageAudits,
						To:   TableNames.Users,
						FromColumns: []string{
							ColumnNames.KeyUsageAudits.UserID,
						},
						ToColumns: []string{
							ColumnNames.Users.UserID,
						},
					},
				},
			}, Users.Columns().Names(), opts...)
		},
	}
}

type keyUsageAuditThenLoader[Q orm.Loadable] struct {
	KeyRoleKey func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	User       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildKeyUsageAuditThenLoader[Q orm.Loadable]() keyUsageAuditThenLoader[Q] {
	type KeyRoleKeyLoadInterface interface {
		LoadKeyRoleKey(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserLoadInterface interface {
		LoadUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return keyUsageAuditThenLoader[Q]{
		KeyRoleKey: thenLoadBuilder[Q](
			"KeyRoleKey",
			func(ctx context.Context, exec bob.Executor, retrieved KeyRoleKeyLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadKeyRoleKey(ctx, exec, mods...)
			},
		),
		User: thenLoadBuilder[Q](
			"User",
			func(ctx context.Context, exec bob.Executor, retrieved UserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadKeyRoleKey loads the keyUsageAudit's KeyRoleKey into the .R struct
func (o *KeyUsageAudit) LoadKeyRoleKey(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.KeyRoleKey = nil

	related, err := o.KeyRoleKey(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.KeyKeyUsageAudits = KeyUsageAuditSlice{o}

	o.R.KeyRoleKey = related
	return nil
}

// LoadKeyRoleKey loads the keyUsageAudit's KeyRoleKey into the .R struct
func (os KeyUsageAuditSlice) LoadKeyRoleKey(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	roleKeys, err := os.KeyRoleKey(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range roleKeys {
			if o.KeyID != rel.KeyID {
				continue
			}

			rel.R.KeyKeyUsageAudits = append(rel.R.KeyKeyUsageAudits, o)

			o.R.KeyRoleKey = rel
			break
		}
	}

	return nil
}

// LoadUser loads the keyUsageAudit's User into the .R struct
func (o *KeyUsageAudit) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.User = nil

	related, err := o.User(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.KeyUsageAudits = KeyUsageAuditSlice{o}

	o.R.User = related
	return nil
}

// LoadUser loads the keyUsageAudit's User into the .R struct
func (os KeyUsageAuditSlice) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.User(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range users {
			if o.UserID != rel.UserID {
				continue
			}

			rel.R.KeyUsageAudits = append(rel.R.KeyUsageAudits, o)

			o.R.User = rel
			break
		}
	}

	return nil
}

func attachKeyUsageAuditKeyRoleKey0(ctx context.Context, exec bob.Executor, count int, keyUsageAudit0 *KeyUsageAudit, roleKey1 *RoleKey) (*KeyUsageAudit, error) {
	setter := &KeyUsageAuditSetter{
		KeyID: &roleKey1.KeyID,
	}

	err := keyUsageAudit0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachKeyUsageAuditKeyRoleKey0: %w", err)
	}

	return keyUsageAudit0, nil
}

func (keyUsageAudit0 *KeyUsageAudit) InsertKeyRoleKey(ctx context.Context, exec bob.Executor, related *RoleKeySetter) error {
	roleKey1, err := RoleKeys.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachKeyUsageAuditKeyRoleKey0(ctx, exec, 1, keyUsageAudit0, roleKey1)
	if err != nil {
		return err
	}

	keyUsageAudit0.R.KeyRoleKey = roleKey1

	roleKey1.R.KeyKeyUsageAudits = append(roleKey1.R.KeyKeyUsageAudits, keyUsageAudit0)

	return nil
}

func (keyUsageAudit0 *KeyUsageAudit) AttachKeyRoleKey(ctx context.Context, exec bob.Executor, roleKey1 *RoleKey) error {
	var err error

	_, err = attachKeyUsageAuditKeyRoleKey0(ctx, exec, 1, keyUsageAudit0, roleKey1)
	if err != nil {
		return err
	}

	keyUsageAudit0.R.KeyRoleKey = roleKey1

	roleKey1.R.KeyKeyUsageAudits = append(roleKey1.R.KeyKeyUsageAudits, keyUsageAudit0)

	return nil
}

func attachKeyUsageAuditUser0(ctx context.Context, exec bob.Executor, count int, keyUsageAudit0 *KeyUsageAudit, user1 *User) (*KeyUsageAudit, error) {
	setter := &KeyUsageAuditSetter{
		UserID: &user1.UserID,
	}

	err := keyUsageAudit0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachKeyUsageAuditUser0: %w", err)
	}

	return keyUsageAudit0, nil
}

func (keyUsageAudit0 *KeyUsageAudit) InsertUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachKeyUsageAuditUser0(ctx, exec, 1, keyUsageAudit0, user1)
	if err != nil {
		return err
	}

	keyUsageAudit0.R.User = user1

	user1.R.KeyUsageAudits = append(user1.R.KeyUsageAudits, keyUsageAudit0)

	return nil
}

func (keyUsageAudit0 *KeyUsageAudit) AttachUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachKeyUsageAuditUser0(ctx, exec, 1, keyUsageAudit0, user1)
	if err != nil {
		return err
	}

	keyUsageAudit0.R.User = user1

	user1.R.KeyUsageAudits = append(user1.R.KeyUsageAudits, keyUsageAudit0)

	return nil
}
