// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"time"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// Comment is an object representing the database table.
type Comment struct {
	CommentID            int64               `db:"comment_id,pk" scan:"comment_id" json:"comment_id"`
	PostID               int64               `db:"post_id" scan:"post_id" json:"post_id"`
	ParentCommentID      sql.Null[int64]     `db:"parent_comment_id" scan:"parent_comment_id" json:"parent_comment_id"`
	Content              string              `db:"content" scan:"content" json:"content"`
	CreatedAt            sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	UpdatedAt            sql.Null[time.Time] `db:"updated_at" scan:"updated_at" json:"updated_at"`
	Score                sql.Null[int32]     `db:"score" scan:"score" json:"score"`
	Upvotes              sql.Null[int32]     `db:"upvotes" scan:"upvotes" json:"upvotes"`
	Downvotes            sql.Null[int32]     `db:"downvotes" scan:"downvotes" json:"downvotes"`
	IsEdited             sql.Null[bool]      `db:"is_edited" scan:"is_edited" json:"is_edited"`
	EditedAt             sql.Null[time.Time] `db:"edited_at" scan:"edited_at" json:"edited_at"`
	EditReason           sql.Null[string]    `db:"edit_reason" scan:"edit_reason" json:"edit_reason"`
	IsRemoved            sql.Null[bool]      `db:"is_removed" scan:"is_removed" json:"is_removed"`
	RemovedByUserID      sql.Null[int64]     `db:"removed_by_user_id" scan:"removed_by_user_id" json:"removed_by_user_id"`
	RemovedByPseudonymID sql.Null[string]    `db:"removed_by_pseudonym_id" scan:"removed_by_pseudonym_id" json:"removed_by_pseudonym_id"`
	RemovalReason        sql.Null[string]    `db:"removal_reason" scan:"removal_reason" json:"removal_reason"`
	RemovedAt            sql.Null[time.Time] `db:"removed_at" scan:"removed_at" json:"removed_at"`
	PseudonymID          string              `db:"pseudonym_id" scan:"pseudonym_id" json:"pseudonym_id"`

	R commentR `db:"-" scan:"rel" json:"rel"`
}

// CommentSlice is an alias for a slice of pointers to Comment.
// This should almost always be used instead of []*Comment.
type CommentSlice []*Comment

// Comments contains methods to work with the comments table
var Comments = psql.NewTablex[*Comment, CommentSlice, *CommentSetter]("", "comments")

// CommentsQuery is a query on the comments table
type CommentsQuery = *psql.ViewQuery[*Comment, CommentSlice]

// commentR is where relationships are stored.
type commentR struct {
	Comment                     *Comment     `scan:"Comment" json:"Comment"`                                         // comments.comments_parent_comment_id_fkey
	ReverseComments             CommentSlice `scan:"ReverseComments" json:"ReverseComments"`                         // comments.comments_parent_comment_id_fkey__self_join_reverse
	Post                        *Post        `scan:"Post" json:"Post"`                                               // comments.comments_post_id_fkey
	Pseudonym                   *Pseudonym   `scan:"Pseudonym" json:"Pseudonym"`                                     // comments.comments_pseudonym_id_fkey
	RemovedByPseudonymPseudonym *Pseudonym   `scan:"RemovedByPseudonymPseudonym" json:"RemovedByPseudonymPseudonym"` // comments.comments_removed_by_pseudonym_id_fkey
	RemovedByUserUser           *User        `scan:"RemovedByUserUser" json:"RemovedByUserUser"`                     // comments.comments_removed_by_user_id_fkey
}

type commentColumnNames struct {
	CommentID            string
	PostID               string
	ParentCommentID      string
	Content              string
	CreatedAt            string
	UpdatedAt            string
	Score                string
	Upvotes              string
	Downvotes            string
	IsEdited             string
	EditedAt             string
	EditReason           string
	IsRemoved            string
	RemovedByUserID      string
	RemovedByPseudonymID string
	RemovalReason        string
	RemovedAt            string
	PseudonymID          string
}

var CommentColumns = buildCommentColumns("comments")

type commentColumns struct {
	tableAlias           string
	CommentID            psql.Expression
	PostID               psql.Expression
	ParentCommentID      psql.Expression
	Content              psql.Expression
	CreatedAt            psql.Expression
	UpdatedAt            psql.Expression
	Score                psql.Expression
	Upvotes              psql.Expression
	Downvotes            psql.Expression
	IsEdited             psql.Expression
	EditedAt             psql.Expression
	EditReason           psql.Expression
	IsRemoved            psql.Expression
	RemovedByUserID      psql.Expression
	RemovedByPseudonymID psql.Expression
	RemovalReason        psql.Expression
	RemovedAt            psql.Expression
	PseudonymID          psql.Expression
}

func (c commentColumns) Alias() string {
	return c.tableAlias
}

func (commentColumns) AliasedAs(alias string) commentColumns {
	return buildCommentColumns(alias)
}

func buildCommentColumns(alias string) commentColumns {
	return commentColumns{
		tableAlias:           alias,
		CommentID:            psql.Quote(alias, "comment_id"),
		PostID:               psql.Quote(alias, "post_id"),
		ParentCommentID:      psql.Quote(alias, "parent_comment_id"),
		Content:              psql.Quote(alias, "content"),
		CreatedAt:            psql.Quote(alias, "created_at"),
		UpdatedAt:            psql.Quote(alias, "updated_at"),
		Score:                psql.Quote(alias, "score"),
		Upvotes:              psql.Quote(alias, "upvotes"),
		Downvotes:            psql.Quote(alias, "downvotes"),
		IsEdited:             psql.Quote(alias, "is_edited"),
		EditedAt:             psql.Quote(alias, "edited_at"),
		EditReason:           psql.Quote(alias, "edit_reason"),
		IsRemoved:            psql.Quote(alias, "is_removed"),
		RemovedByUserID:      psql.Quote(alias, "removed_by_user_id"),
		RemovedByPseudonymID: psql.Quote(alias, "removed_by_pseudonym_id"),
		RemovalReason:        psql.Quote(alias, "removal_reason"),
		RemovedAt:            psql.Quote(alias, "removed_at"),
		PseudonymID:          psql.Quote(alias, "pseudonym_id"),
	}
}

type commentWhere[Q psql.Filterable] struct {
	CommentID            psql.WhereMod[Q, int64]
	PostID               psql.WhereMod[Q, int64]
	ParentCommentID      psql.WhereNullMod[Q, int64]
	Content              psql.WhereMod[Q, string]
	CreatedAt            psql.WhereNullMod[Q, time.Time]
	UpdatedAt            psql.WhereNullMod[Q, time.Time]
	Score                psql.WhereNullMod[Q, int32]
	Upvotes              psql.WhereNullMod[Q, int32]
	Downvotes            psql.WhereNullMod[Q, int32]
	IsEdited             psql.WhereNullMod[Q, bool]
	EditedAt             psql.WhereNullMod[Q, time.Time]
	EditReason           psql.WhereNullMod[Q, string]
	IsRemoved            psql.WhereNullMod[Q, bool]
	RemovedByUserID      psql.WhereNullMod[Q, int64]
	RemovedByPseudonymID psql.WhereNullMod[Q, string]
	RemovalReason        psql.WhereNullMod[Q, string]
	RemovedAt            psql.WhereNullMod[Q, time.Time]
	PseudonymID          psql.WhereMod[Q, string]
}

func (commentWhere[Q]) AliasedAs(alias string) commentWhere[Q] {
	return buildCommentWhere[Q](buildCommentColumns(alias))
}

func buildCommentWhere[Q psql.Filterable](cols commentColumns) commentWhere[Q] {
	return commentWhere[Q]{
		CommentID:            psql.Where[Q, int64](cols.CommentID),
		PostID:               psql.Where[Q, int64](cols.PostID),
		ParentCommentID:      psql.WhereNull[Q, int64](cols.ParentCommentID),
		Content:              psql.Where[Q, string](cols.Content),
		CreatedAt:            psql.WhereNull[Q, time.Time](cols.CreatedAt),
		UpdatedAt:            psql.WhereNull[Q, time.Time](cols.UpdatedAt),
		Score:                psql.WhereNull[Q, int32](cols.Score),
		Upvotes:              psql.WhereNull[Q, int32](cols.Upvotes),
		Downvotes:            psql.WhereNull[Q, int32](cols.Downvotes),
		IsEdited:             psql.WhereNull[Q, bool](cols.IsEdited),
		EditedAt:             psql.WhereNull[Q, time.Time](cols.EditedAt),
		EditReason:           psql.WhereNull[Q, string](cols.EditReason),
		IsRemoved:            psql.WhereNull[Q, bool](cols.IsRemoved),
		RemovedByUserID:      psql.WhereNull[Q, int64](cols.RemovedByUserID),
		RemovedByPseudonymID: psql.WhereNull[Q, string](cols.RemovedByPseudonymID),
		RemovalReason:        psql.WhereNull[Q, string](cols.RemovalReason),
		RemovedAt:            psql.WhereNull[Q, time.Time](cols.RemovedAt),
		PseudonymID:          psql.Where[Q, string](cols.PseudonymID),
	}
}

var CommentErrors = &commentErrors{
	ErrUniqueCommentsPkey: &UniqueConstraintError{
		schema:  "",
		table:   "comments",
		columns: []string{"comment_id"},
		s:       "comments_pkey",
	},
}

type commentErrors struct {
	ErrUniqueCommentsPkey *UniqueConstraintError
}

// CommentSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type CommentSetter struct {
	CommentID            *int64               `db:"comment_id,pk" scan:"comment_id" json:"comment_id"`
	PostID               *int64               `db:"post_id" scan:"post_id" json:"post_id"`
	ParentCommentID      *sql.Null[int64]     `db:"parent_comment_id" scan:"parent_comment_id" json:"parent_comment_id"`
	Content              *string              `db:"content" scan:"content" json:"content"`
	CreatedAt            *sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	UpdatedAt            *sql.Null[time.Time] `db:"updated_at" scan:"updated_at" json:"updated_at"`
	Score                *sql.Null[int32]     `db:"score" scan:"score" json:"score"`
	Upvotes              *sql.Null[int32]     `db:"upvotes" scan:"upvotes" json:"upvotes"`
	Downvotes            *sql.Null[int32]     `db:"downvotes" scan:"downvotes" json:"downvotes"`
	IsEdited             *sql.Null[bool]      `db:"is_edited" scan:"is_edited" json:"is_edited"`
	EditedAt             *sql.Null[time.Time] `db:"edited_at" scan:"edited_at" json:"edited_at"`
	EditReason           *sql.Null[string]    `db:"edit_reason" scan:"edit_reason" json:"edit_reason"`
	IsRemoved            *sql.Null[bool]      `db:"is_removed" scan:"is_removed" json:"is_removed"`
	RemovedByUserID      *sql.Null[int64]     `db:"removed_by_user_id" scan:"removed_by_user_id" json:"removed_by_user_id"`
	RemovedByPseudonymID *sql.Null[string]    `db:"removed_by_pseudonym_id" scan:"removed_by_pseudonym_id" json:"removed_by_pseudonym_id"`
	RemovalReason        *sql.Null[string]    `db:"removal_reason" scan:"removal_reason" json:"removal_reason"`
	RemovedAt            *sql.Null[time.Time] `db:"removed_at" scan:"removed_at" json:"removed_at"`
	PseudonymID          *string              `db:"pseudonym_id" scan:"pseudonym_id" json:"pseudonym_id"`
}

func (s CommentSetter) SetColumns() []string {
	vals := make([]string, 0, 18)
	if s.CommentID != nil {
		vals = append(vals, "comment_id")
	}

	if s.PostID != nil {
		vals = append(vals, "post_id")
	}

	if s.ParentCommentID != nil {
		vals = append(vals, "parent_comment_id")
	}

	if s.Content != nil {
		vals = append(vals, "content")
	}

	if s.CreatedAt != nil {
		vals = append(vals, "created_at")
	}

	if s.UpdatedAt != nil {
		vals = append(vals, "updated_at")
	}

	if s.Score != nil {
		vals = append(vals, "score")
	}

	if s.Upvotes != nil {
		vals = append(vals, "upvotes")
	}

	if s.Downvotes != nil {
		vals = append(vals, "downvotes")
	}

	if s.IsEdited != nil {
		vals = append(vals, "is_edited")
	}

	if s.EditedAt != nil {
		vals = append(vals, "edited_at")
	}

	if s.EditReason != nil {
		vals = append(vals, "edit_reason")
	}

	if s.IsRemoved != nil {
		vals = append(vals, "is_removed")
	}

	if s.RemovedByUserID != nil {
		vals = append(vals, "removed_by_user_id")
	}

	if s.RemovedByPseudonymID != nil {
		vals = append(vals, "removed_by_pseudonym_id")
	}

	if s.RemovalReason != nil {
		vals = append(vals, "removal_reason")
	}

	if s.RemovedAt != nil {
		vals = append(vals, "removed_at")
	}

	if s.PseudonymID != nil {
		vals = append(vals, "pseudonym_id")
	}

	return vals
}

func (s CommentSetter) Overwrite(t *Comment) {
	if s.CommentID != nil {
		t.CommentID = *s.CommentID
	}
	if s.PostID != nil {
		t.PostID = *s.PostID
	}
	if s.ParentCommentID != nil {
		t.ParentCommentID = *s.ParentCommentID
	}
	if s.Content != nil {
		t.Content = *s.Content
	}
	if s.CreatedAt != nil {
		t.CreatedAt = *s.CreatedAt
	}
	if s.UpdatedAt != nil {
		t.UpdatedAt = *s.UpdatedAt
	}
	if s.Score != nil {
		t.Score = *s.Score
	}
	if s.Upvotes != nil {
		t.Upvotes = *s.Upvotes
	}
	if s.Downvotes != nil {
		t.Downvotes = *s.Downvotes
	}
	if s.IsEdited != nil {
		t.IsEdited = *s.IsEdited
	}
	if s.EditedAt != nil {
		t.EditedAt = *s.EditedAt
	}
	if s.EditReason != nil {
		t.EditReason = *s.EditReason
	}
	if s.IsRemoved != nil {
		t.IsRemoved = *s.IsRemoved
	}
	if s.RemovedByUserID != nil {
		t.RemovedByUserID = *s.RemovedByUserID
	}
	if s.RemovedByPseudonymID != nil {
		t.RemovedByPseudonymID = *s.RemovedByPseudonymID
	}
	if s.RemovalReason != nil {
		t.RemovalReason = *s.RemovalReason
	}
	if s.RemovedAt != nil {
		t.RemovedAt = *s.RemovedAt
	}
	if s.PseudonymID != nil {
		t.PseudonymID = *s.PseudonymID
	}
}

func (s *CommentSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Comments.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 18)
		if s.CommentID != nil {
			vals[0] = psql.Arg(*s.CommentID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.PostID != nil {
			vals[1] = psql.Arg(*s.PostID)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.ParentCommentID != nil {
			vals[2] = psql.Arg(*s.ParentCommentID)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.Content != nil {
			vals[3] = psql.Arg(*s.Content)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt != nil {
			vals[4] = psql.Arg(*s.CreatedAt)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.UpdatedAt != nil {
			vals[5] = psql.Arg(*s.UpdatedAt)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.Score != nil {
			vals[6] = psql.Arg(*s.Score)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.Upvotes != nil {
			vals[7] = psql.Arg(*s.Upvotes)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.Downvotes != nil {
			vals[8] = psql.Arg(*s.Downvotes)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.IsEdited != nil {
			vals[9] = psql.Arg(*s.IsEdited)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.EditedAt != nil {
			vals[10] = psql.Arg(*s.EditedAt)
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.EditReason != nil {
			vals[11] = psql.Arg(*s.EditReason)
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.IsRemoved != nil {
			vals[12] = psql.Arg(*s.IsRemoved)
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.RemovedByUserID != nil {
			vals[13] = psql.Arg(*s.RemovedByUserID)
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.RemovedByPseudonymID != nil {
			vals[14] = psql.Arg(*s.RemovedByPseudonymID)
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.RemovalReason != nil {
			vals[15] = psql.Arg(*s.RemovalReason)
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if s.RemovedAt != nil {
			vals[16] = psql.Arg(*s.RemovedAt)
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if s.PseudonymID != nil {
			vals[17] = psql.Arg(*s.PseudonymID)
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s CommentSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s CommentSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 18)

	if s.CommentID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comment_id")...),
			psql.Arg(s.CommentID),
		}})
	}

	if s.PostID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "post_id")...),
			psql.Arg(s.PostID),
		}})
	}

	if s.ParentCommentID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "parent_comment_id")...),
			psql.Arg(s.ParentCommentID),
		}})
	}

	if s.Content != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "content")...),
			psql.Arg(s.Content),
		}})
	}

	if s.CreatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.UpdatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated_at")...),
			psql.Arg(s.UpdatedAt),
		}})
	}

	if s.Score != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "score")...),
			psql.Arg(s.Score),
		}})
	}

	if s.Upvotes != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "upvotes")...),
			psql.Arg(s.Upvotes),
		}})
	}

	if s.Downvotes != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "downvotes")...),
			psql.Arg(s.Downvotes),
		}})
	}

	if s.IsEdited != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_edited")...),
			psql.Arg(s.IsEdited),
		}})
	}

	if s.EditedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "edited_at")...),
			psql.Arg(s.EditedAt),
		}})
	}

	if s.EditReason != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "edit_reason")...),
			psql.Arg(s.EditReason),
		}})
	}

	if s.IsRemoved != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_removed")...),
			psql.Arg(s.IsRemoved),
		}})
	}

	if s.RemovedByUserID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "removed_by_user_id")...),
			psql.Arg(s.RemovedByUserID),
		}})
	}

	if s.RemovedByPseudonymID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "removed_by_pseudonym_id")...),
			psql.Arg(s.RemovedByPseudonymID),
		}})
	}

	if s.RemovalReason != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "removal_reason")...),
			psql.Arg(s.RemovalReason),
		}})
	}

	if s.RemovedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "removed_at")...),
			psql.Arg(s.RemovedAt),
		}})
	}

	if s.PseudonymID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "pseudonym_id")...),
			psql.Arg(s.PseudonymID),
		}})
	}

	return exprs
}

// FindComment retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindComment(ctx context.Context, exec bob.Executor, CommentIDPK int64, cols ...string) (*Comment, error) {
	if len(cols) == 0 {
		return Comments.Query(
			SelectWhere.Comments.CommentID.EQ(CommentIDPK),
		).One(ctx, exec)
	}

	return Comments.Query(
		SelectWhere.Comments.CommentID.EQ(CommentIDPK),
		sm.Columns(Comments.Columns().Only(cols...)),
	).One(ctx, exec)
}

// CommentExists checks the presence of a single record by primary key
func CommentExists(ctx context.Context, exec bob.Executor, CommentIDPK int64) (bool, error) {
	return Comments.Query(
		SelectWhere.Comments.CommentID.EQ(CommentIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Comment is retrieved from the database
func (o *Comment) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Comments.AfterSelectHooks.RunHooks(ctx, exec, CommentSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Comments.AfterInsertHooks.RunHooks(ctx, exec, CommentSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Comments.AfterUpdateHooks.RunHooks(ctx, exec, CommentSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Comments.AfterDeleteHooks.RunHooks(ctx, exec, CommentSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Comment
func (o *Comment) primaryKeyVals() bob.Expression {
	return psql.Arg(o.CommentID)
}

func (o *Comment) pkEQ() dialect.Expression {
	return psql.Quote("comments", "comment_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Comment
func (o *Comment) Update(ctx context.Context, exec bob.Executor, s *CommentSetter) error {
	v, err := Comments.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Comment record with an executor
func (o *Comment) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Comments.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Comment using the executor
func (o *Comment) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Comments.Query(
		SelectWhere.Comments.CommentID.EQ(o.CommentID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after CommentSlice is retrieved from the database
func (o CommentSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Comments.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Comments.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Comments.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Comments.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o CommentSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("comments", "comment_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o CommentSlice) copyMatchingRows(from ...*Comment) {
	for i, old := range o {
		for _, new := range from {
			if new.CommentID != old.CommentID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o CommentSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Comments.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Comment:
				o.copyMatchingRows(retrieved)
			case []*Comment:
				o.copyMatchingRows(retrieved...)
			case CommentSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Comment or a slice of Comment
				// then run the AfterUpdateHooks on the slice
				_, err = Comments.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o CommentSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Comments.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Comment:
				o.copyMatchingRows(retrieved)
			case []*Comment:
				o.copyMatchingRows(retrieved...)
			case CommentSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Comment or a slice of Comment
				// then run the AfterDeleteHooks on the slice
				_, err = Comments.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o CommentSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals CommentSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Comments.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o CommentSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Comments.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o CommentSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Comments.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type commentJoins[Q dialect.Joinable] struct {
	typ                         string
	Comment                     modAs[Q, commentColumns]
	ReverseComments             modAs[Q, commentColumns]
	Post                        modAs[Q, postColumns]
	Pseudonym                   modAs[Q, pseudonymColumns]
	RemovedByPseudonymPseudonym modAs[Q, pseudonymColumns]
	RemovedByUserUser           modAs[Q, userColumns]
}

func (j commentJoins[Q]) aliasedAs(alias string) commentJoins[Q] {
	return buildCommentJoins[Q](buildCommentColumns(alias), j.typ)
}

func buildCommentJoins[Q dialect.Joinable](cols commentColumns, typ string) commentJoins[Q] {
	return commentJoins[Q]{
		typ: typ,
		Comment: modAs[Q, commentColumns]{
			c: CommentColumns,
			f: func(to commentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Comments.Name().As(to.Alias())).On(
						to.CommentID.EQ(cols.ParentCommentID),
					))
				}

				return mods
			},
		},
		ReverseComments: modAs[Q, commentColumns]{
			c: CommentColumns,
			f: func(to commentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Comments.Name().As(to.Alias())).On(
						to.ParentCommentID.EQ(cols.CommentID),
					))
				}

				return mods
			},
		},
		Post: modAs[Q, postColumns]{
			c: PostColumns,
			f: func(to postColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Posts.Name().As(to.Alias())).On(
						to.PostID.EQ(cols.PostID),
					))
				}

				return mods
			},
		},
		Pseudonym: modAs[Q, pseudonymColumns]{
			c: PseudonymColumns,
			f: func(to pseudonymColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pseudonyms.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		RemovedByPseudonymPseudonym: modAs[Q, pseudonymColumns]{
			c: PseudonymColumns,
			f: func(to pseudonymColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pseudonyms.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.RemovedByPseudonymID),
					))
				}

				return mods
			},
		},
		RemovedByUserUser: modAs[Q, userColumns]{
			c: UserColumns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.RemovedByUserID),
					))
				}

				return mods
			},
		},
	}
}

// Comment starts a query for related objects on comments
func (o *Comment) Comment(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	return Comments.Query(append(mods,
		sm.Where(CommentColumns.CommentID.EQ(psql.Arg(o.ParentCommentID))),
	)...)
}

func (os CommentSlice) Comment(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	pkParentCommentID := make(pgtypes.Array[sql.Null[int64]], len(os))
	for i, o := range os {
		pkParentCommentID[i] = o.ParentCommentID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkParentCommentID), "bigint[]")),
	))

	return Comments.Query(append(mods,
		sm.Where(psql.Group(CommentColumns.CommentID).OP("IN", PKArgExpr)),
	)...)
}

// ReverseComments starts a query for related objects on comments
func (o *Comment) ReverseComments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	return Comments.Query(append(mods,
		sm.Where(CommentColumns.ParentCommentID.EQ(psql.Arg(o.CommentID))),
	)...)
}

func (os CommentSlice) ReverseComments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	pkCommentID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkCommentID[i] = o.CommentID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkCommentID), "bigint[]")),
	))

	return Comments.Query(append(mods,
		sm.Where(psql.Group(CommentColumns.ParentCommentID).OP("IN", PKArgExpr)),
	)...)
}

// Post starts a query for related objects on posts
func (o *Comment) Post(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	return Posts.Query(append(mods,
		sm.Where(PostColumns.PostID.EQ(psql.Arg(o.PostID))),
	)...)
}

func (os CommentSlice) Post(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	pkPostID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkPostID[i] = o.PostID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPostID), "bigint[]")),
	))

	return Posts.Query(append(mods,
		sm.Where(psql.Group(PostColumns.PostID).OP("IN", PKArgExpr)),
	)...)
}

// Pseudonym starts a query for related objects on pseudonyms
func (o *Comment) Pseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	return Pseudonyms.Query(append(mods,
		sm.Where(PseudonymColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os CommentSlice) Pseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Pseudonyms.Query(append(mods,
		sm.Where(psql.Group(PseudonymColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// RemovedByPseudonymPseudonym starts a query for related objects on pseudonyms
func (o *Comment) RemovedByPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	return Pseudonyms.Query(append(mods,
		sm.Where(PseudonymColumns.PseudonymID.EQ(psql.Arg(o.RemovedByPseudonymID))),
	)...)
}

func (os CommentSlice) RemovedByPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	pkRemovedByPseudonymID := make(pgtypes.Array[sql.Null[string]], len(os))
	for i, o := range os {
		pkRemovedByPseudonymID[i] = o.RemovedByPseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkRemovedByPseudonymID), "character varying[]")),
	))

	return Pseudonyms.Query(append(mods,
		sm.Where(psql.Group(PseudonymColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// RemovedByUserUser starts a query for related objects on users
func (o *Comment) RemovedByUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(UserColumns.UserID.EQ(psql.Arg(o.RemovedByUserID))),
	)...)
}

func (os CommentSlice) RemovedByUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkRemovedByUserID := make(pgtypes.Array[sql.Null[int64]], len(os))
	for i, o := range os {
		pkRemovedByUserID[i] = o.RemovedByUserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkRemovedByUserID), "bigint[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(UserColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

func (o *Comment) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Comment":
		rel, ok := retrieved.(*Comment)
		if !ok {
			return fmt.Errorf("comment cannot load %T as %q", retrieved, name)
		}

		o.R.Comment = rel

		if rel != nil {
			rel.R.Comment = o
		}
		return nil
	case "ReverseComments":
		rels, ok := retrieved.(CommentSlice)
		if !ok {
			return fmt.Errorf("comment cannot load %T as %q", retrieved, name)
		}

		o.R.ReverseComments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ReverseComments = CommentSlice{o}
			}
		}
		return nil
	case "Post":
		rel, ok := retrieved.(*Post)
		if !ok {
			return fmt.Errorf("comment cannot load %T as %q", retrieved, name)
		}

		o.R.Post = rel

		if rel != nil {
			rel.R.Comments = CommentSlice{o}
		}
		return nil
	case "Pseudonym":
		rel, ok := retrieved.(*Pseudonym)
		if !ok {
			return fmt.Errorf("comment cannot load %T as %q", retrieved, name)
		}

		o.R.Pseudonym = rel

		if rel != nil {
			rel.R.Comments = CommentSlice{o}
		}
		return nil
	case "RemovedByPseudonymPseudonym":
		rel, ok := retrieved.(*Pseudonym)
		if !ok {
			return fmt.Errorf("comment cannot load %T as %q", retrieved, name)
		}

		o.R.RemovedByPseudonymPseudonym = rel

		if rel != nil {
			rel.R.RemovedByPseudonymComments = CommentSlice{o}
		}
		return nil
	case "RemovedByUserUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("comment cannot load %T as %q", retrieved, name)
		}

		o.R.RemovedByUserUser = rel

		if rel != nil {
			rel.R.RemovedByUserComments = CommentSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("comment has no relationship %q", name)
	}
}

type commentPreloader struct {
	Comment                     func(...psql.PreloadOption) psql.Preloader
	Post                        func(...psql.PreloadOption) psql.Preloader
	Pseudonym                   func(...psql.PreloadOption) psql.Preloader
	RemovedByPseudonymPseudonym func(...psql.PreloadOption) psql.Preloader
	RemovedByUserUser           func(...psql.PreloadOption) psql.Preloader
}

func buildCommentPreloader() commentPreloader {
	return commentPreloader{
		Comment: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Comment, CommentSlice](orm.Relationship{
				Name: "Comment",
				Sides: []orm.RelSide{
					{
						From: TableNames.Comments,
						To:   TableNames.Comments,
						FromColumns: []string{
							ColumnNames.Comments.ParentCommentID,
						},
						ToColumns: []string{
							ColumnNames.Comments.CommentID,
						},
					},
				},
			}, Comments.Columns().Names(), opts...)
		},
		Post: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Post, PostSlice](orm.Relationship{
				Name: "Post",
				Sides: []orm.RelSide{
					{
						From: TableNames.Comments,
						To:   TableNames.Posts,
						FromColumns: []string{
							ColumnNames.Comments.PostID,
						},
						ToColumns: []string{
							ColumnNames.Posts.PostID,
						},
					},
				},
			}, Posts.Columns().Names(), opts...)
		},
		Pseudonym: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Pseudonym, PseudonymSlice](orm.Relationship{
				Name: "Pseudonym",
				Sides: []orm.RelSide{
					{
						From: TableNames.Comments,
						To:   TableNames.Pseudonyms,
						FromColumns: []string{
							ColumnNames.Comments.PseudonymID,
						},
						ToColumns: []string{
							ColumnNames.Pseudonyms.PseudonymID,
						},
					},
				},
			}, Pseudonyms.Columns().Names(), opts...)
		},
		RemovedByPseudonymPseudonym: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Pseudonym, PseudonymSlice](orm.Relationship{
				Name: "RemovedByPseudonymPseudonym",
				Sides: []orm.RelSide{
					{
						From: TableNames.Comments,
						To:   TableNames.Pseudonyms,
						FromColumns: []string{
							ColumnNames.Comments.RemovedByPseudonymID,
						},
						ToColumns: []string{
							ColumnNames.Pseudonyms.PseudonymID,
						},
					},
				},
			}, Pseudonyms.Columns().Names(), opts...)
		},
		RemovedByUserUser: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](orm.Relationship{
				Name: "RemovedByUserUser",
				Sides: []orm.RelSide{
					{
						From: TableNames.Comments,
						To:   TableNames.Users,
						FromColumns: []string{
							ColumnNames.Comments.RemovedByUserID,
						},
						ToColumns: []string{
							ColumnNames.Users.UserID,
						},
					},
				},
			}, Users.Columns().Names(), opts...)
		},
	}
}

type commentThenLoader[Q orm.Loadable] struct {
	Comment                     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ReverseComments             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Post                        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pseudonym                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RemovedByPseudonymPseudonym func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RemovedByUserUser           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildCommentThenLoader[Q orm.Loadable]() commentThenLoader[Q] {
	type CommentLoadInterface interface {
		LoadComment(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ReverseCommentsLoadInterface interface {
		LoadReverseComments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PostLoadInterface interface {
		LoadPost(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PseudonymLoadInterface interface {
		LoadPseudonym(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RemovedByPseudonymPseudonymLoadInterface interface {
		LoadRemovedByPseudonymPseudonym(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RemovedByUserUserLoadInterface interface {
		LoadRemovedByUserUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return commentThenLoader[Q]{
		Comment: thenLoadBuilder[Q](
			"Comment",
			func(ctx context.Context, exec bob.Executor, retrieved CommentLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadComment(ctx, exec, mods...)
			},
		),
		ReverseComments: thenLoadBuilder[Q](
			"ReverseComments",
			func(ctx context.Context, exec bob.Executor, retrieved ReverseCommentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadReverseComments(ctx, exec, mods...)
			},
		),
		Post: thenLoadBuilder[Q](
			"Post",
			func(ctx context.Context, exec bob.Executor, retrieved PostLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPost(ctx, exec, mods...)
			},
		),
		Pseudonym: thenLoadBuilder[Q](
			"Pseudonym",
			func(ctx context.Context, exec bob.Executor, retrieved PseudonymLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPseudonym(ctx, exec, mods...)
			},
		),
		RemovedByPseudonymPseudonym: thenLoadBuilder[Q](
			"RemovedByPseudonymPseudonym",
			func(ctx context.Context, exec bob.Executor, retrieved RemovedByPseudonymPseudonymLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRemovedByPseudonymPseudonym(ctx, exec, mods...)
			},
		),
		RemovedByUserUser: thenLoadBuilder[Q](
			"RemovedByUserUser",
			func(ctx context.Context, exec bob.Executor, retrieved RemovedByUserUserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRemovedByUserUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadComment loads the comment's Comment into the .R struct
func (o *Comment) LoadComment(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Comment = nil

	related, err := o.Comment(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Comment = o

	o.R.Comment = related
	return nil
}

// LoadComment loads the comment's Comment into the .R struct
func (os CommentSlice) LoadComment(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	comments, err := os.Comment(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range comments {
			if o.ParentCommentID.V != rel.CommentID {
				continue
			}

			rel.R.Comment = o

			o.R.Comment = rel
			break
		}
	}

	return nil
}

// LoadReverseComments loads the comment's ReverseComments into the .R struct
func (o *Comment) LoadReverseComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ReverseComments = nil

	related, err := o.ReverseComments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ReverseComments = CommentSlice{o}
	}

	o.R.ReverseComments = related
	return nil
}

// LoadReverseComments loads the comment's ReverseComments into the .R struct
func (os CommentSlice) LoadReverseComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	comments, err := os.ReverseComments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ReverseComments = nil
	}

	for _, o := range os {
		for _, rel := range comments {
			if o.CommentID != rel.ParentCommentID.V {
				continue
			}

			rel.R.ReverseComments = append(rel.R.ReverseComments, o)

			o.R.ReverseComments = append(o.R.ReverseComments, rel)
		}
	}

	return nil
}

// LoadPost loads the comment's Post into the .R struct
func (o *Comment) LoadPost(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Post = nil

	related, err := o.Post(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Comments = CommentSlice{o}

	o.R.Post = related
	return nil
}

// LoadPost loads the comment's Post into the .R struct
func (os CommentSlice) LoadPost(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	posts, err := os.Post(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range posts {
			if o.PostID != rel.PostID {
				continue
			}

			rel.R.Comments = append(rel.R.Comments, o)

			o.R.Post = rel
			break
		}
	}

	return nil
}

// LoadPseudonym loads the comment's Pseudonym into the .R struct
func (o *Comment) LoadPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Pseudonym = nil

	related, err := o.Pseudonym(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Comments = CommentSlice{o}

	o.R.Pseudonym = related
	return nil
}

// LoadPseudonym loads the comment's Pseudonym into the .R struct
func (os CommentSlice) LoadPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pseudonyms, err := os.Pseudonym(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range pseudonyms {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.Comments = append(rel.R.Comments, o)

			o.R.Pseudonym = rel
			break
		}
	}

	return nil
}

// LoadRemovedByPseudonymPseudonym loads the comment's RemovedByPseudonymPseudonym into the .R struct
func (o *Comment) LoadRemovedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RemovedByPseudonymPseudonym = nil

	related, err := o.RemovedByPseudonymPseudonym(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.RemovedByPseudonymComments = CommentSlice{o}

	o.R.RemovedByPseudonymPseudonym = related
	return nil
}

// LoadRemovedByPseudonymPseudonym loads the comment's RemovedByPseudonymPseudonym into the .R struct
func (os CommentSlice) LoadRemovedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pseudonyms, err := os.RemovedByPseudonymPseudonym(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range pseudonyms {
			if o.RemovedByPseudonymID.V != rel.PseudonymID {
				continue
			}

			rel.R.RemovedByPseudonymComments = append(rel.R.RemovedByPseudonymComments, o)

			o.R.RemovedByPseudonymPseudonym = rel
			break
		}
	}

	return nil
}

// LoadRemovedByUserUser loads the comment's RemovedByUserUser into the .R struct
func (o *Comment) LoadRemovedByUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RemovedByUserUser = nil

	related, err := o.RemovedByUserUser(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.RemovedByUserComments = CommentSlice{o}

	o.R.RemovedByUserUser = related
	return nil
}

// LoadRemovedByUserUser loads the comment's RemovedByUserUser into the .R struct
func (os CommentSlice) LoadRemovedByUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.RemovedByUserUser(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range users {
			if o.RemovedByUserID.V != rel.UserID {
				continue
			}

			rel.R.RemovedByUserComments = append(rel.R.RemovedByUserComments, o)

			o.R.RemovedByUserUser = rel
			break
		}
	}

	return nil
}

func attachCommentComment0(ctx context.Context, exec bob.Executor, count int, comment0 *Comment, comment1 *Comment) (*Comment, error) {
	setter := &CommentSetter{
		ParentCommentID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: comment1.CommentID, Valid: true}
			return &v
		}(),
	}

	err := comment0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachCommentComment0: %w", err)
	}

	return comment0, nil
}

func (comment0 *Comment) InsertComment(ctx context.Context, exec bob.Executor, related *CommentSetter) error {
	comment1, err := Comments.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachCommentComment0(ctx, exec, 1, comment0, comment1)
	if err != nil {
		return err
	}

	comment0.R.Comment = comment1

	comment1.R.Comment = comment0

	return nil
}

func (comment0 *Comment) AttachComment(ctx context.Context, exec bob.Executor, comment1 *Comment) error {
	var err error

	_, err = attachCommentComment0(ctx, exec, 1, comment0, comment1)
	if err != nil {
		return err
	}

	comment0.R.Comment = comment1

	comment1.R.Comment = comment0

	return nil
}

func insertCommentReverseComments0(ctx context.Context, exec bob.Executor, comments1 []*CommentSetter, comment0 *Comment) (CommentSlice, error) {
	for i := range comments1 {
		comments1[i].ParentCommentID = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: comment0.CommentID, Valid: true}
			return &v
		}()
	}

	ret, err := Comments.Insert(bob.ToMods(comments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertCommentReverseComments0: %w", err)
	}

	return ret, nil
}

func attachCommentReverseComments0(ctx context.Context, exec bob.Executor, count int, comments1 CommentSlice, comment0 *Comment) (CommentSlice, error) {
	setter := &CommentSetter{
		ParentCommentID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: comment0.CommentID, Valid: true}
			return &v
		}(),
	}

	err := comments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachCommentReverseComments0: %w", err)
	}

	return comments1, nil
}

func (comment0 *Comment) InsertReverseComments(ctx context.Context, exec bob.Executor, related ...*CommentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	comments1, err := insertCommentReverseComments0(ctx, exec, related, comment0)
	if err != nil {
		return err
	}

	comment0.R.ReverseComments = append(comment0.R.ReverseComments, comments1...)

	for _, rel := range comments1 {
		rel.R.ReverseComments = append(rel.R.ReverseComments, comment0)
	}
	return nil
}

func (comment0 *Comment) AttachReverseComments(ctx context.Context, exec bob.Executor, related ...*Comment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	comments1 := CommentSlice(related)

	_, err = attachCommentReverseComments0(ctx, exec, len(related), comments1, comment0)
	if err != nil {
		return err
	}

	comment0.R.ReverseComments = append(comment0.R.ReverseComments, comments1...)

	for _, rel := range related {
		rel.R.ReverseComments = append(rel.R.ReverseComments, comment0)
	}

	return nil
}

func attachCommentPost0(ctx context.Context, exec bob.Executor, count int, comment0 *Comment, post1 *Post) (*Comment, error) {
	setter := &CommentSetter{
		PostID: &post1.PostID,
	}

	err := comment0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachCommentPost0: %w", err)
	}

	return comment0, nil
}

func (comment0 *Comment) InsertPost(ctx context.Context, exec bob.Executor, related *PostSetter) error {
	post1, err := Posts.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachCommentPost0(ctx, exec, 1, comment0, post1)
	if err != nil {
		return err
	}

	comment0.R.Post = post1

	post1.R.Comments = append(post1.R.Comments, comment0)

	return nil
}

func (comment0 *Comment) AttachPost(ctx context.Context, exec bob.Executor, post1 *Post) error {
	var err error

	_, err = attachCommentPost0(ctx, exec, 1, comment0, post1)
	if err != nil {
		return err
	}

	comment0.R.Post = post1

	post1.R.Comments = append(post1.R.Comments, comment0)

	return nil
}

func attachCommentPseudonym0(ctx context.Context, exec bob.Executor, count int, comment0 *Comment, pseudonym1 *Pseudonym) (*Comment, error) {
	setter := &CommentSetter{
		PseudonymID: &pseudonym1.PseudonymID,
	}

	err := comment0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachCommentPseudonym0: %w", err)
	}

	return comment0, nil
}

func (comment0 *Comment) InsertPseudonym(ctx context.Context, exec bob.Executor, related *PseudonymSetter) error {
	pseudonym1, err := Pseudonyms.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachCommentPseudonym0(ctx, exec, 1, comment0, pseudonym1)
	if err != nil {
		return err
	}

	comment0.R.Pseudonym = pseudonym1

	pseudonym1.R.Comments = append(pseudonym1.R.Comments, comment0)

	return nil
}

func (comment0 *Comment) AttachPseudonym(ctx context.Context, exec bob.Executor, pseudonym1 *Pseudonym) error {
	var err error

	_, err = attachCommentPseudonym0(ctx, exec, 1, comment0, pseudonym1)
	if err != nil {
		return err
	}

	comment0.R.Pseudonym = pseudonym1

	pseudonym1.R.Comments = append(pseudonym1.R.Comments, comment0)

	return nil
}

func attachCommentRemovedByPseudonymPseudonym0(ctx context.Context, exec bob.Executor, count int, comment0 *Comment, pseudonym1 *Pseudonym) (*Comment, error) {
	setter := &CommentSetter{
		RemovedByPseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym1.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := comment0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachCommentRemovedByPseudonymPseudonym0: %w", err)
	}

	return comment0, nil
}

func (comment0 *Comment) InsertRemovedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, related *PseudonymSetter) error {
	pseudonym1, err := Pseudonyms.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachCommentRemovedByPseudonymPseudonym0(ctx, exec, 1, comment0, pseudonym1)
	if err != nil {
		return err
	}

	comment0.R.RemovedByPseudonymPseudonym = pseudonym1

	pseudonym1.R.RemovedByPseudonymComments = append(pseudonym1.R.RemovedByPseudonymComments, comment0)

	return nil
}

func (comment0 *Comment) AttachRemovedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, pseudonym1 *Pseudonym) error {
	var err error

	_, err = attachCommentRemovedByPseudonymPseudonym0(ctx, exec, 1, comment0, pseudonym1)
	if err != nil {
		return err
	}

	comment0.R.RemovedByPseudonymPseudonym = pseudonym1

	pseudonym1.R.RemovedByPseudonymComments = append(pseudonym1.R.RemovedByPseudonymComments, comment0)

	return nil
}

func attachCommentRemovedByUserUser0(ctx context.Context, exec bob.Executor, count int, comment0 *Comment, user1 *User) (*Comment, error) {
	setter := &CommentSetter{
		RemovedByUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user1.UserID, Valid: true}
			return &v
		}(),
	}

	err := comment0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachCommentRemovedByUserUser0: %w", err)
	}

	return comment0, nil
}

func (comment0 *Comment) InsertRemovedByUserUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachCommentRemovedByUserUser0(ctx, exec, 1, comment0, user1)
	if err != nil {
		return err
	}

	comment0.R.RemovedByUserUser = user1

	user1.R.RemovedByUserComments = append(user1.R.RemovedByUserComments, comment0)

	return nil
}

func (comment0 *Comment) AttachRemovedByUserUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachCommentRemovedByUserUser0(ctx, exec, 1, comment0, user1)
	if err != nil {
		return err
	}

	comment0.R.RemovedByUserUser = user1

	user1.R.RemovedByUserComments = append(user1.R.RemovedByUserComments, comment0)

	return nil
}
