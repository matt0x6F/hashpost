// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"database/sql"
	"encoding/json"
	"testing"
	"time"

	"github.com/jaswdr/faker/v2"
	models "github.com/matt0x6f/hashpost/internal/database/models"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/types"
)

type UserMod interface {
	Apply(context.Context, *UserTemplate)
}

type UserModFunc func(context.Context, *UserTemplate)

func (f UserModFunc) Apply(ctx context.Context, n *UserTemplate) {
	f(ctx, n)
}

type UserModSlice []UserMod

func (mods UserModSlice) Apply(ctx context.Context, n *UserTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// UserTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type UserTemplate struct {
	UserID              func() int64
	Email               func() string
	PasswordHash        func() string
	CreatedAt           func() sql.Null[time.Time]
	LastActiveAt        func() sql.Null[time.Time]
	IsActive            func() sql.Null[bool]
	IsSuspended         func() sql.Null[bool]
	SuspensionReason    func() sql.Null[string]
	SuspensionExpiresAt func() sql.Null[time.Time]
	Roles               func() sql.Null[types.JSON[json.RawMessage]]
	Capabilities        func() sql.Null[types.JSON[json.RawMessage]]
	AdminUsername       func() sql.Null[string]
	AdminPasswordHash   func() sql.Null[string]
	MfaEnabled          func() sql.Null[bool]
	MfaSecret           func() sql.Null[string]
	ModeratedSubforums  func() sql.Null[types.JSON[json.RawMessage]]
	AdminScope          func() sql.Null[string]
	UpdatedAt           func() sql.Null[time.Time]

	r userR
	f *Factory
}

type userR struct {
	RemovedByUserComments          []*userRRemovedByUserCommentsR
	AssignedUserComplianceReports  []*userRAssignedUserComplianceReportsR
	CorrelationAudits              []*userRCorrelationAuditsR
	IdentityMappings               []*userRIdentityMappingsR
	KeyUsageAudits                 []*userRKeyUsageAuditsR
	ModeratorUserModerationActions []*userRModeratorUserModerationActionsR
	TargetUserModerationActions    []*userRTargetUserModerationActionsR
	RemovedByUserPosts             []*userRRemovedByUserPostsR
	Pseudonyms                     []*userRPseudonymsR
	ResolvedByUserReports          []*userRResolvedByUserReportsR
	CreatedByRoleKeys              []*userRCreatedByRoleKeysR
	AddedByUserSubforumModerators  []*userRAddedByUserSubforumModeratorsR
	SubforumModerators             []*userRSubforumModeratorsR
	CreatedByUserSubforums         []*userRCreatedByUserSubforumsR
	UpdatedBySystemSettings        []*userRUpdatedBySystemSettingsR
	BannedByUserUserBans           []*userRBannedByUserUserBansR
	BannedUserUserBans             []*userRBannedUserUserBansR
	BlockedUserUserBlocks          []*userRBlockedUserUserBlocksR
	UserPreference                 *userRUserPreferenceR
}

type userRRemovedByUserCommentsR struct {
	number int
	o      *CommentTemplate
}
type userRAssignedUserComplianceReportsR struct {
	number int
	o      *ComplianceReportTemplate
}
type userRCorrelationAuditsR struct {
	number int
	o      *CorrelationAuditTemplate
}
type userRIdentityMappingsR struct {
	number int
	o      *IdentityMappingTemplate
}
type userRKeyUsageAuditsR struct {
	number int
	o      *KeyUsageAuditTemplate
}
type userRModeratorUserModerationActionsR struct {
	number int
	o      *ModerationActionTemplate
}
type userRTargetUserModerationActionsR struct {
	number int
	o      *ModerationActionTemplate
}
type userRRemovedByUserPostsR struct {
	number int
	o      *PostTemplate
}
type userRPseudonymsR struct {
	number int
	o      *PseudonymTemplate
}
type userRResolvedByUserReportsR struct {
	number int
	o      *ReportTemplate
}
type userRCreatedByRoleKeysR struct {
	number int
	o      *RoleKeyTemplate
}
type userRAddedByUserSubforumModeratorsR struct {
	number int
	o      *SubforumModeratorTemplate
}
type userRSubforumModeratorsR struct {
	number int
	o      *SubforumModeratorTemplate
}
type userRCreatedByUserSubforumsR struct {
	number int
	o      *SubforumTemplate
}
type userRUpdatedBySystemSettingsR struct {
	number int
	o      *SystemSettingTemplate
}
type userRBannedByUserUserBansR struct {
	number int
	o      *UserBanTemplate
}
type userRBannedUserUserBansR struct {
	number int
	o      *UserBanTemplate
}
type userRBlockedUserUserBlocksR struct {
	number int
	o      *UserBlockTemplate
}
type userRUserPreferenceR struct {
	o *UserPreferenceTemplate
}

// Apply mods to the UserTemplate
func (o *UserTemplate) Apply(ctx context.Context, mods ...UserMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// setModelRels creates and sets the relationships on *models.User
// according to the relationships in the template. Nothing is inserted into the db
func (t UserTemplate) setModelRels(o *models.User) {
	if t.r.RemovedByUserComments != nil {
		rel := models.CommentSlice{}
		for _, r := range t.r.RemovedByUserComments {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.RemovedByUserID = sql.Null[int64]{V: o.UserID, Valid: true} // h2
				rel.R.RemovedByUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.RemovedByUserComments = rel
	}

	if t.r.AssignedUserComplianceReports != nil {
		rel := models.ComplianceReportSlice{}
		for _, r := range t.r.AssignedUserComplianceReports {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.AssignedUserID = sql.Null[int64]{V: o.UserID, Valid: true} // h2
				rel.R.AssignedUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.AssignedUserComplianceReports = rel
	}

	if t.r.CorrelationAudits != nil {
		rel := models.CorrelationAuditSlice{}
		for _, r := range t.r.CorrelationAudits {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.UserID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.CorrelationAudits = rel
	}

	if t.r.IdentityMappings != nil {
		rel := models.IdentityMappingSlice{}
		for _, r := range t.r.IdentityMappings {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.UserID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.IdentityMappings = rel
	}

	if t.r.KeyUsageAudits != nil {
		rel := models.KeyUsageAuditSlice{}
		for _, r := range t.r.KeyUsageAudits {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.UserID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.KeyUsageAudits = rel
	}

	if t.r.ModeratorUserModerationActions != nil {
		rel := models.ModerationActionSlice{}
		for _, r := range t.r.ModeratorUserModerationActions {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.ModeratorUserID = o.UserID // h2
				rel.R.ModeratorUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.ModeratorUserModerationActions = rel
	}

	if t.r.TargetUserModerationActions != nil {
		rel := models.ModerationActionSlice{}
		for _, r := range t.r.TargetUserModerationActions {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.TargetUserID = sql.Null[int64]{V: o.UserID, Valid: true} // h2
				rel.R.TargetUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.TargetUserModerationActions = rel
	}

	if t.r.RemovedByUserPosts != nil {
		rel := models.PostSlice{}
		for _, r := range t.r.RemovedByUserPosts {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.RemovedByUserID = sql.Null[int64]{V: o.UserID, Valid: true} // h2
				rel.R.RemovedByUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.RemovedByUserPosts = rel
	}

	if t.r.Pseudonyms != nil {
		rel := models.PseudonymSlice{}
		for _, r := range t.r.Pseudonyms {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.UserID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.Pseudonyms = rel
	}

	if t.r.ResolvedByUserReports != nil {
		rel := models.ReportSlice{}
		for _, r := range t.r.ResolvedByUserReports {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.ResolvedByUserID = sql.Null[int64]{V: o.UserID, Valid: true} // h2
				rel.R.ResolvedByUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.ResolvedByUserReports = rel
	}

	if t.r.CreatedByRoleKeys != nil {
		rel := models.RoleKeySlice{}
		for _, r := range t.r.CreatedByRoleKeys {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.CreatedBy = o.UserID // h2
				rel.R.CreatedByUser = o
			}
			rel = append(rel, related...)
		}
		o.R.CreatedByRoleKeys = rel
	}

	if t.r.AddedByUserSubforumModerators != nil {
		rel := models.SubforumModeratorSlice{}
		for _, r := range t.r.AddedByUserSubforumModerators {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.AddedByUserID = sql.Null[int64]{V: o.UserID, Valid: true} // h2
				rel.R.AddedByUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.AddedByUserSubforumModerators = rel
	}

	if t.r.SubforumModerators != nil {
		rel := models.SubforumModeratorSlice{}
		for _, r := range t.r.SubforumModerators {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.UserID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.SubforumModerators = rel
	}

	if t.r.CreatedByUserSubforums != nil {
		rel := models.SubforumSlice{}
		for _, r := range t.r.CreatedByUserSubforums {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.CreatedByUserID = sql.Null[int64]{V: o.UserID, Valid: true} // h2
				rel.R.CreatedByUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.CreatedByUserSubforums = rel
	}

	if t.r.UpdatedBySystemSettings != nil {
		rel := models.SystemSettingSlice{}
		for _, r := range t.r.UpdatedBySystemSettings {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UpdatedBy = sql.Null[int64]{V: o.UserID, Valid: true} // h2
				rel.R.UpdatedByUser = o
			}
			rel = append(rel, related...)
		}
		o.R.UpdatedBySystemSettings = rel
	}

	if t.r.BannedByUserUserBans != nil {
		rel := models.UserBanSlice{}
		for _, r := range t.r.BannedByUserUserBans {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.BannedByUserID = o.UserID // h2
				rel.R.BannedByUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.BannedByUserUserBans = rel
	}

	if t.r.BannedUserUserBans != nil {
		rel := models.UserBanSlice{}
		for _, r := range t.r.BannedUserUserBans {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.BannedUserID = o.UserID // h2
				rel.R.BannedUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.BannedUserUserBans = rel
	}

	if t.r.BlockedUserUserBlocks != nil {
		rel := models.UserBlockSlice{}
		for _, r := range t.r.BlockedUserUserBlocks {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.BlockedUserID = sql.Null[int64]{V: o.UserID, Valid: true} // h2
				rel.R.BlockedUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.BlockedUserUserBlocks = rel
	}

	if t.r.UserPreference != nil {
		rel := t.r.UserPreference.o.Build()
		rel.R.User = o
		rel.UserID = o.UserID // h2
		o.R.UserPreference = rel
	}
}

// BuildSetter returns an *models.UserSetter
// this does nothing with the relationship templates
func (o UserTemplate) BuildSetter() *models.UserSetter {
	m := &models.UserSetter{}

	if o.UserID != nil {
		val := o.UserID()
		m.UserID = &val
	}
	if o.Email != nil {
		val := o.Email()
		m.Email = &val
	}
	if o.PasswordHash != nil {
		val := o.PasswordHash()
		m.PasswordHash = &val
	}
	if o.CreatedAt != nil {
		val := o.CreatedAt()
		m.CreatedAt = &val
	}
	if o.LastActiveAt != nil {
		val := o.LastActiveAt()
		m.LastActiveAt = &val
	}
	if o.IsActive != nil {
		val := o.IsActive()
		m.IsActive = &val
	}
	if o.IsSuspended != nil {
		val := o.IsSuspended()
		m.IsSuspended = &val
	}
	if o.SuspensionReason != nil {
		val := o.SuspensionReason()
		m.SuspensionReason = &val
	}
	if o.SuspensionExpiresAt != nil {
		val := o.SuspensionExpiresAt()
		m.SuspensionExpiresAt = &val
	}
	if o.Roles != nil {
		val := o.Roles()
		m.Roles = &val
	}
	if o.Capabilities != nil {
		val := o.Capabilities()
		m.Capabilities = &val
	}
	if o.AdminUsername != nil {
		val := o.AdminUsername()
		m.AdminUsername = &val
	}
	if o.AdminPasswordHash != nil {
		val := o.AdminPasswordHash()
		m.AdminPasswordHash = &val
	}
	if o.MfaEnabled != nil {
		val := o.MfaEnabled()
		m.MfaEnabled = &val
	}
	if o.MfaSecret != nil {
		val := o.MfaSecret()
		m.MfaSecret = &val
	}
	if o.ModeratedSubforums != nil {
		val := o.ModeratedSubforums()
		m.ModeratedSubforums = &val
	}
	if o.AdminScope != nil {
		val := o.AdminScope()
		m.AdminScope = &val
	}
	if o.UpdatedAt != nil {
		val := o.UpdatedAt()
		m.UpdatedAt = &val
	}

	return m
}

// BuildManySetter returns an []*models.UserSetter
// this does nothing with the relationship templates
func (o UserTemplate) BuildManySetter(number int) []*models.UserSetter {
	m := make([]*models.UserSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.User
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use UserTemplate.Create
func (o UserTemplate) Build() *models.User {
	m := &models.User{}

	if o.UserID != nil {
		m.UserID = o.UserID()
	}
	if o.Email != nil {
		m.Email = o.Email()
	}
	if o.PasswordHash != nil {
		m.PasswordHash = o.PasswordHash()
	}
	if o.CreatedAt != nil {
		m.CreatedAt = o.CreatedAt()
	}
	if o.LastActiveAt != nil {
		m.LastActiveAt = o.LastActiveAt()
	}
	if o.IsActive != nil {
		m.IsActive = o.IsActive()
	}
	if o.IsSuspended != nil {
		m.IsSuspended = o.IsSuspended()
	}
	if o.SuspensionReason != nil {
		m.SuspensionReason = o.SuspensionReason()
	}
	if o.SuspensionExpiresAt != nil {
		m.SuspensionExpiresAt = o.SuspensionExpiresAt()
	}
	if o.Roles != nil {
		m.Roles = o.Roles()
	}
	if o.Capabilities != nil {
		m.Capabilities = o.Capabilities()
	}
	if o.AdminUsername != nil {
		m.AdminUsername = o.AdminUsername()
	}
	if o.AdminPasswordHash != nil {
		m.AdminPasswordHash = o.AdminPasswordHash()
	}
	if o.MfaEnabled != nil {
		m.MfaEnabled = o.MfaEnabled()
	}
	if o.MfaSecret != nil {
		m.MfaSecret = o.MfaSecret()
	}
	if o.ModeratedSubforums != nil {
		m.ModeratedSubforums = o.ModeratedSubforums()
	}
	if o.AdminScope != nil {
		m.AdminScope = o.AdminScope()
	}
	if o.UpdatedAt != nil {
		m.UpdatedAt = o.UpdatedAt()
	}

	o.setModelRels(m)

	return m
}

// BuildMany returns an models.UserSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use UserTemplate.CreateMany
func (o UserTemplate) BuildMany(number int) models.UserSlice {
	m := make(models.UserSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableUser(m *models.UserSetter) {
	if m.Email == nil {
		val := random_string(nil, "255")
		m.Email = &val
	}
	if m.PasswordHash == nil {
		val := random_string(nil, "255")
		m.PasswordHash = &val
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.User
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *UserTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.User) (context.Context, error) {
	var err error

	isRemovedByUserCommentsDone, _ := userRelRemovedByUserCommentsCtx.Value(ctx)
	if !isRemovedByUserCommentsDone && o.r.RemovedByUserComments != nil {
		ctx = userRelRemovedByUserCommentsCtx.WithValue(ctx, true)
		for _, r := range o.r.RemovedByUserComments {
			var rel0 models.CommentSlice
			ctx, rel0, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachRemovedByUserComments(ctx, exec, rel0...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isAssignedUserComplianceReportsDone, _ := userRelAssignedUserComplianceReportsCtx.Value(ctx)
	if !isAssignedUserComplianceReportsDone && o.r.AssignedUserComplianceReports != nil {
		ctx = userRelAssignedUserComplianceReportsCtx.WithValue(ctx, true)
		for _, r := range o.r.AssignedUserComplianceReports {
			var rel1 models.ComplianceReportSlice
			ctx, rel1, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachAssignedUserComplianceReports(ctx, exec, rel1...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isCorrelationAuditsDone, _ := userRelCorrelationAuditsCtx.Value(ctx)
	if !isCorrelationAuditsDone && o.r.CorrelationAudits != nil {
		ctx = userRelCorrelationAuditsCtx.WithValue(ctx, true)
		for _, r := range o.r.CorrelationAudits {
			var rel2 models.CorrelationAuditSlice
			ctx, rel2, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachCorrelationAudits(ctx, exec, rel2...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isIdentityMappingsDone, _ := userRelIdentityMappingsCtx.Value(ctx)
	if !isIdentityMappingsDone && o.r.IdentityMappings != nil {
		ctx = userRelIdentityMappingsCtx.WithValue(ctx, true)
		for _, r := range o.r.IdentityMappings {
			var rel3 models.IdentityMappingSlice
			ctx, rel3, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachIdentityMappings(ctx, exec, rel3...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isKeyUsageAuditsDone, _ := userRelKeyUsageAuditsCtx.Value(ctx)
	if !isKeyUsageAuditsDone && o.r.KeyUsageAudits != nil {
		ctx = userRelKeyUsageAuditsCtx.WithValue(ctx, true)
		for _, r := range o.r.KeyUsageAudits {
			var rel4 models.KeyUsageAuditSlice
			ctx, rel4, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachKeyUsageAudits(ctx, exec, rel4...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isModeratorUserModerationActionsDone, _ := userRelModeratorUserModerationActionsCtx.Value(ctx)
	if !isModeratorUserModerationActionsDone && o.r.ModeratorUserModerationActions != nil {
		ctx = userRelModeratorUserModerationActionsCtx.WithValue(ctx, true)
		for _, r := range o.r.ModeratorUserModerationActions {
			var rel5 models.ModerationActionSlice
			ctx, rel5, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachModeratorUserModerationActions(ctx, exec, rel5...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isTargetUserModerationActionsDone, _ := userRelTargetUserModerationActionsCtx.Value(ctx)
	if !isTargetUserModerationActionsDone && o.r.TargetUserModerationActions != nil {
		ctx = userRelTargetUserModerationActionsCtx.WithValue(ctx, true)
		for _, r := range o.r.TargetUserModerationActions {
			var rel6 models.ModerationActionSlice
			ctx, rel6, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachTargetUserModerationActions(ctx, exec, rel6...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isRemovedByUserPostsDone, _ := userRelRemovedByUserPostsCtx.Value(ctx)
	if !isRemovedByUserPostsDone && o.r.RemovedByUserPosts != nil {
		ctx = userRelRemovedByUserPostsCtx.WithValue(ctx, true)
		for _, r := range o.r.RemovedByUserPosts {
			var rel7 models.PostSlice
			ctx, rel7, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachRemovedByUserPosts(ctx, exec, rel7...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isPseudonymsDone, _ := userRelPseudonymsCtx.Value(ctx)
	if !isPseudonymsDone && o.r.Pseudonyms != nil {
		ctx = userRelPseudonymsCtx.WithValue(ctx, true)
		for _, r := range o.r.Pseudonyms {
			var rel8 models.PseudonymSlice
			ctx, rel8, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachPseudonyms(ctx, exec, rel8...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isResolvedByUserReportsDone, _ := userRelResolvedByUserReportsCtx.Value(ctx)
	if !isResolvedByUserReportsDone && o.r.ResolvedByUserReports != nil {
		ctx = userRelResolvedByUserReportsCtx.WithValue(ctx, true)
		for _, r := range o.r.ResolvedByUserReports {
			var rel9 models.ReportSlice
			ctx, rel9, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachResolvedByUserReports(ctx, exec, rel9...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isCreatedByRoleKeysDone, _ := userRelCreatedByRoleKeysCtx.Value(ctx)
	if !isCreatedByRoleKeysDone && o.r.CreatedByRoleKeys != nil {
		ctx = userRelCreatedByRoleKeysCtx.WithValue(ctx, true)
		for _, r := range o.r.CreatedByRoleKeys {
			var rel10 models.RoleKeySlice
			ctx, rel10, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachCreatedByRoleKeys(ctx, exec, rel10...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isAddedByUserSubforumModeratorsDone, _ := userRelAddedByUserSubforumModeratorsCtx.Value(ctx)
	if !isAddedByUserSubforumModeratorsDone && o.r.AddedByUserSubforumModerators != nil {
		ctx = userRelAddedByUserSubforumModeratorsCtx.WithValue(ctx, true)
		for _, r := range o.r.AddedByUserSubforumModerators {
			var rel11 models.SubforumModeratorSlice
			ctx, rel11, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachAddedByUserSubforumModerators(ctx, exec, rel11...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isSubforumModeratorsDone, _ := userRelSubforumModeratorsCtx.Value(ctx)
	if !isSubforumModeratorsDone && o.r.SubforumModerators != nil {
		ctx = userRelSubforumModeratorsCtx.WithValue(ctx, true)
		for _, r := range o.r.SubforumModerators {
			var rel12 models.SubforumModeratorSlice
			ctx, rel12, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachSubforumModerators(ctx, exec, rel12...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isCreatedByUserSubforumsDone, _ := userRelCreatedByUserSubforumsCtx.Value(ctx)
	if !isCreatedByUserSubforumsDone && o.r.CreatedByUserSubforums != nil {
		ctx = userRelCreatedByUserSubforumsCtx.WithValue(ctx, true)
		for _, r := range o.r.CreatedByUserSubforums {
			var rel13 models.SubforumSlice
			ctx, rel13, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachCreatedByUserSubforums(ctx, exec, rel13...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isUpdatedBySystemSettingsDone, _ := userRelUpdatedBySystemSettingsCtx.Value(ctx)
	if !isUpdatedBySystemSettingsDone && o.r.UpdatedBySystemSettings != nil {
		ctx = userRelUpdatedBySystemSettingsCtx.WithValue(ctx, true)
		for _, r := range o.r.UpdatedBySystemSettings {
			var rel14 models.SystemSettingSlice
			ctx, rel14, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachUpdatedBySystemSettings(ctx, exec, rel14...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isBannedByUserUserBansDone, _ := userRelBannedByUserUserBansCtx.Value(ctx)
	if !isBannedByUserUserBansDone && o.r.BannedByUserUserBans != nil {
		ctx = userRelBannedByUserUserBansCtx.WithValue(ctx, true)
		for _, r := range o.r.BannedByUserUserBans {
			var rel15 models.UserBanSlice
			ctx, rel15, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachBannedByUserUserBans(ctx, exec, rel15...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isBannedUserUserBansDone, _ := userRelBannedUserUserBansCtx.Value(ctx)
	if !isBannedUserUserBansDone && o.r.BannedUserUserBans != nil {
		ctx = userRelBannedUserUserBansCtx.WithValue(ctx, true)
		for _, r := range o.r.BannedUserUserBans {
			var rel16 models.UserBanSlice
			ctx, rel16, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachBannedUserUserBans(ctx, exec, rel16...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isBlockedUserUserBlocksDone, _ := userRelBlockedUserUserBlocksCtx.Value(ctx)
	if !isBlockedUserUserBlocksDone && o.r.BlockedUserUserBlocks != nil {
		ctx = userRelBlockedUserUserBlocksCtx.WithValue(ctx, true)
		for _, r := range o.r.BlockedUserUserBlocks {
			var rel17 models.UserBlockSlice
			ctx, rel17, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachBlockedUserUserBlocks(ctx, exec, rel17...)
			if err != nil {
				return ctx, err
			}
		}
	}

	isUserPreferenceDone, _ := userRelUserPreferenceCtx.Value(ctx)
	if !isUserPreferenceDone && o.r.UserPreference != nil {
		ctx = userRelUserPreferenceCtx.WithValue(ctx, true)
		var rel18 *models.UserPreference
		ctx, rel18, err = o.r.UserPreference.o.create(ctx, exec)
		if err != nil {
			return ctx, err
		}
		err = m.AttachUserPreference(ctx, exec, rel18)
		if err != nil {
			return ctx, err
		}

	}

	return ctx, err
}

// Create builds a user and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *UserTemplate) Create(ctx context.Context, exec bob.Executor) (*models.User, error) {
	_, m, err := o.create(ctx, exec)
	return m, err
}

// MustCreate builds a user and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *UserTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.User {
	_, m, err := o.create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a user and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *UserTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.User {
	tb.Helper()
	_, m, err := o.create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// create builds a user and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted model
func (o *UserTemplate) create(ctx context.Context, exec bob.Executor) (context.Context, *models.User, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableUser(opt)

	m, err := models.Users.Insert(opt).One(ctx, exec)
	if err != nil {
		return ctx, nil, err
	}
	ctx = userCtx.WithValue(ctx, m)

	ctx, err = o.insertOptRels(ctx, exec, m)
	return ctx, m, err
}

// CreateMany builds multiple users and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o UserTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.UserSlice, error) {
	_, m, err := o.createMany(ctx, exec, number)
	return m, err
}

// MustCreateMany builds multiple users and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o UserTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.UserSlice {
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple users and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o UserTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.UserSlice {
	tb.Helper()
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// createMany builds multiple users and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted models
func (o UserTemplate) createMany(ctx context.Context, exec bob.Executor, number int) (context.Context, models.UserSlice, error) {
	var err error
	m := make(models.UserSlice, number)

	for i := range m {
		ctx, m[i], err = o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	return ctx, m, nil
}

// User has methods that act as mods for the UserTemplate
var UserMods userMods

type userMods struct{}

func (m userMods) RandomizeAllColumns(f *faker.Faker) UserMod {
	return UserModSlice{
		UserMods.RandomUserID(f),
		UserMods.RandomEmail(f),
		UserMods.RandomPasswordHash(f),
		UserMods.RandomCreatedAt(f),
		UserMods.RandomLastActiveAt(f),
		UserMods.RandomIsActive(f),
		UserMods.RandomIsSuspended(f),
		UserMods.RandomSuspensionReason(f),
		UserMods.RandomSuspensionExpiresAt(f),
		UserMods.RandomRoles(f),
		UserMods.RandomCapabilities(f),
		UserMods.RandomAdminUsername(f),
		UserMods.RandomAdminPasswordHash(f),
		UserMods.RandomMfaEnabled(f),
		UserMods.RandomMfaSecret(f),
		UserMods.RandomModeratedSubforums(f),
		UserMods.RandomAdminScope(f),
		UserMods.RandomUpdatedAt(f),
	}
}

// Set the model columns to this value
func (m userMods) UserID(val int64) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UserID = func() int64 { return val }
	})
}

// Set the Column from the function
func (m userMods) UserIDFunc(f func() int64) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UserID = f
	})
}

// Clear any values for the column
func (m userMods) UnsetUserID() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UserID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userMods) RandomUserID(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UserID = func() int64 {
			return random_int64(f)
		}
	})
}

// Set the model columns to this value
func (m userMods) Email(val string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Email = func() string { return val }
	})
}

// Set the Column from the function
func (m userMods) EmailFunc(f func() string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Email = f
	})
}

// Clear any values for the column
func (m userMods) UnsetEmail() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Email = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userMods) RandomEmail(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Email = func() string {
			return random_string(f, "255")
		}
	})
}

// Set the model columns to this value
func (m userMods) PasswordHash(val string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.PasswordHash = func() string { return val }
	})
}

// Set the Column from the function
func (m userMods) PasswordHashFunc(f func() string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.PasswordHash = f
	})
}

// Clear any values for the column
func (m userMods) UnsetPasswordHash() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.PasswordHash = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userMods) RandomPasswordHash(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.PasswordHash = func() string {
			return random_string(f, "255")
		}
	})
}

// Set the model columns to this value
func (m userMods) CreatedAt(val sql.Null[time.Time]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.CreatedAt = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m userMods) CreatedAtFunc(f func() sql.Null[time.Time]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.CreatedAt = f
	})
}

// Clear any values for the column
func (m userMods) UnsetCreatedAt() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.CreatedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomCreatedAt(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.CreatedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomCreatedAtNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.CreatedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) LastActiveAt(val sql.Null[time.Time]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.LastActiveAt = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m userMods) LastActiveAtFunc(f func() sql.Null[time.Time]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.LastActiveAt = f
	})
}

// Clear any values for the column
func (m userMods) UnsetLastActiveAt() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.LastActiveAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomLastActiveAt(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.LastActiveAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomLastActiveAtNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.LastActiveAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) IsActive(val sql.Null[bool]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsActive = func() sql.Null[bool] { return val }
	})
}

// Set the Column from the function
func (m userMods) IsActiveFunc(f func() sql.Null[bool]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsActive = f
	})
}

// Clear any values for the column
func (m userMods) UnsetIsActive() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsActive = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomIsActive(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsActive = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomIsActiveNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsActive = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) IsSuspended(val sql.Null[bool]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsSuspended = func() sql.Null[bool] { return val }
	})
}

// Set the Column from the function
func (m userMods) IsSuspendedFunc(f func() sql.Null[bool]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsSuspended = f
	})
}

// Clear any values for the column
func (m userMods) UnsetIsSuspended() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsSuspended = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomIsSuspended(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsSuspended = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomIsSuspendedNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.IsSuspended = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) SuspensionReason(val sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionReason = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m userMods) SuspensionReasonFunc(f func() sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionReason = f
	})
}

// Clear any values for the column
func (m userMods) UnsetSuspensionReason() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionReason = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomSuspensionReason(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionReason = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomSuspensionReasonNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionReason = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) SuspensionExpiresAt(val sql.Null[time.Time]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionExpiresAt = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m userMods) SuspensionExpiresAtFunc(f func() sql.Null[time.Time]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionExpiresAt = f
	})
}

// Clear any values for the column
func (m userMods) UnsetSuspensionExpiresAt() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionExpiresAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomSuspensionExpiresAt(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionExpiresAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomSuspensionExpiresAtNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.SuspensionExpiresAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) Roles(val sql.Null[types.JSON[json.RawMessage]]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Roles = func() sql.Null[types.JSON[json.RawMessage]] { return val }
	})
}

// Set the Column from the function
func (m userMods) RolesFunc(f func() sql.Null[types.JSON[json.RawMessage]]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Roles = f
	})
}

// Clear any values for the column
func (m userMods) UnsetRoles() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Roles = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomRoles(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Roles = func() sql.Null[types.JSON[json.RawMessage]] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_types_JSON_json_RawMessage_(f)
			return sql.Null[types.JSON[json.RawMessage]]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomRolesNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Roles = func() sql.Null[types.JSON[json.RawMessage]] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_types_JSON_json_RawMessage_(f)
			return sql.Null[types.JSON[json.RawMessage]]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) Capabilities(val sql.Null[types.JSON[json.RawMessage]]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Capabilities = func() sql.Null[types.JSON[json.RawMessage]] { return val }
	})
}

// Set the Column from the function
func (m userMods) CapabilitiesFunc(f func() sql.Null[types.JSON[json.RawMessage]]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Capabilities = f
	})
}

// Clear any values for the column
func (m userMods) UnsetCapabilities() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Capabilities = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomCapabilities(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Capabilities = func() sql.Null[types.JSON[json.RawMessage]] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_types_JSON_json_RawMessage_(f)
			return sql.Null[types.JSON[json.RawMessage]]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomCapabilitiesNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Capabilities = func() sql.Null[types.JSON[json.RawMessage]] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_types_JSON_json_RawMessage_(f)
			return sql.Null[types.JSON[json.RawMessage]]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) AdminUsername(val sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminUsername = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m userMods) AdminUsernameFunc(f func() sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminUsername = f
	})
}

// Clear any values for the column
func (m userMods) UnsetAdminUsername() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminUsername = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomAdminUsername(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminUsername = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "100")
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomAdminUsernameNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminUsername = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "100")
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) AdminPasswordHash(val sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminPasswordHash = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m userMods) AdminPasswordHashFunc(f func() sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminPasswordHash = f
	})
}

// Clear any values for the column
func (m userMods) UnsetAdminPasswordHash() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminPasswordHash = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomAdminPasswordHash(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminPasswordHash = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "255")
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomAdminPasswordHashNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminPasswordHash = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "255")
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) MfaEnabled(val sql.Null[bool]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaEnabled = func() sql.Null[bool] { return val }
	})
}

// Set the Column from the function
func (m userMods) MfaEnabledFunc(f func() sql.Null[bool]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaEnabled = f
	})
}

// Clear any values for the column
func (m userMods) UnsetMfaEnabled() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaEnabled = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomMfaEnabled(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaEnabled = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomMfaEnabledNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaEnabled = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) MfaSecret(val sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaSecret = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m userMods) MfaSecretFunc(f func() sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaSecret = f
	})
}

// Clear any values for the column
func (m userMods) UnsetMfaSecret() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaSecret = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomMfaSecret(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaSecret = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "255")
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomMfaSecretNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.MfaSecret = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "255")
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) ModeratedSubforums(val sql.Null[types.JSON[json.RawMessage]]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.ModeratedSubforums = func() sql.Null[types.JSON[json.RawMessage]] { return val }
	})
}

// Set the Column from the function
func (m userMods) ModeratedSubforumsFunc(f func() sql.Null[types.JSON[json.RawMessage]]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.ModeratedSubforums = f
	})
}

// Clear any values for the column
func (m userMods) UnsetModeratedSubforums() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.ModeratedSubforums = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomModeratedSubforums(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.ModeratedSubforums = func() sql.Null[types.JSON[json.RawMessage]] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_types_JSON_json_RawMessage_(f)
			return sql.Null[types.JSON[json.RawMessage]]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomModeratedSubforumsNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.ModeratedSubforums = func() sql.Null[types.JSON[json.RawMessage]] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_types_JSON_json_RawMessage_(f)
			return sql.Null[types.JSON[json.RawMessage]]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) AdminScope(val sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminScope = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m userMods) AdminScopeFunc(f func() sql.Null[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminScope = f
	})
}

// Clear any values for the column
func (m userMods) UnsetAdminScope() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminScope = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomAdminScope(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminScope = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "100")
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomAdminScopeNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.AdminScope = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "100")
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userMods) UpdatedAt(val sql.Null[time.Time]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UpdatedAt = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m userMods) UpdatedAtFunc(f func() sql.Null[time.Time]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UpdatedAt = f
	})
}

// Clear any values for the column
func (m userMods) UnsetUpdatedAt() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UpdatedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomUpdatedAt(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UpdatedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomUpdatedAtNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UpdatedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

func (m userMods) WithParentsCascading() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		if isDone, _ := userWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = userWithParentsCascadingCtx.WithValue(ctx, true)
		{

			related := o.f.NewUserPreference(ctx, UserPreferenceMods.WithParentsCascading())
			m.WithUserPreference(related).Apply(ctx, o)
		}
	})
}

func (m userMods) WithUserPreference(rel *UserPreferenceTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserPreference = &userRUserPreferenceR{
			o: rel,
		}
	})
}

func (m userMods) WithNewUserPreference(mods ...UserPreferenceMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserPreference(ctx, mods...)

		m.WithUserPreference(related).Apply(ctx, o)
	})
}

func (m userMods) WithoutUserPreference() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserPreference = nil
	})
}

func (m userMods) WithRemovedByUserComments(number int, related *CommentTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.RemovedByUserComments = []*userRRemovedByUserCommentsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewRemovedByUserComments(number int, mods ...CommentMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewComment(ctx, mods...)
		m.WithRemovedByUserComments(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddRemovedByUserComments(number int, related *CommentTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.RemovedByUserComments = append(o.r.RemovedByUserComments, &userRRemovedByUserCommentsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewRemovedByUserComments(number int, mods ...CommentMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewComment(ctx, mods...)
		m.AddRemovedByUserComments(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutRemovedByUserComments() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.RemovedByUserComments = nil
	})
}

func (m userMods) WithAssignedUserComplianceReports(number int, related *ComplianceReportTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AssignedUserComplianceReports = []*userRAssignedUserComplianceReportsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewAssignedUserComplianceReports(number int, mods ...ComplianceReportMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewComplianceReport(ctx, mods...)
		m.WithAssignedUserComplianceReports(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddAssignedUserComplianceReports(number int, related *ComplianceReportTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AssignedUserComplianceReports = append(o.r.AssignedUserComplianceReports, &userRAssignedUserComplianceReportsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewAssignedUserComplianceReports(number int, mods ...ComplianceReportMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewComplianceReport(ctx, mods...)
		m.AddAssignedUserComplianceReports(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutAssignedUserComplianceReports() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AssignedUserComplianceReports = nil
	})
}

func (m userMods) WithCorrelationAudits(number int, related *CorrelationAuditTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CorrelationAudits = []*userRCorrelationAuditsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewCorrelationAudits(number int, mods ...CorrelationAuditMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCorrelationAudit(ctx, mods...)
		m.WithCorrelationAudits(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddCorrelationAudits(number int, related *CorrelationAuditTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CorrelationAudits = append(o.r.CorrelationAudits, &userRCorrelationAuditsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewCorrelationAudits(number int, mods ...CorrelationAuditMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCorrelationAudit(ctx, mods...)
		m.AddCorrelationAudits(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutCorrelationAudits() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CorrelationAudits = nil
	})
}

func (m userMods) WithIdentityMappings(number int, related *IdentityMappingTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.IdentityMappings = []*userRIdentityMappingsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewIdentityMappings(number int, mods ...IdentityMappingMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewIdentityMapping(ctx, mods...)
		m.WithIdentityMappings(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddIdentityMappings(number int, related *IdentityMappingTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.IdentityMappings = append(o.r.IdentityMappings, &userRIdentityMappingsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewIdentityMappings(number int, mods ...IdentityMappingMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewIdentityMapping(ctx, mods...)
		m.AddIdentityMappings(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutIdentityMappings() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.IdentityMappings = nil
	})
}

func (m userMods) WithKeyUsageAudits(number int, related *KeyUsageAuditTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.KeyUsageAudits = []*userRKeyUsageAuditsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewKeyUsageAudits(number int, mods ...KeyUsageAuditMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewKeyUsageAudit(ctx, mods...)
		m.WithKeyUsageAudits(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddKeyUsageAudits(number int, related *KeyUsageAuditTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.KeyUsageAudits = append(o.r.KeyUsageAudits, &userRKeyUsageAuditsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewKeyUsageAudits(number int, mods ...KeyUsageAuditMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewKeyUsageAudit(ctx, mods...)
		m.AddKeyUsageAudits(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutKeyUsageAudits() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.KeyUsageAudits = nil
	})
}

func (m userMods) WithModeratorUserModerationActions(number int, related *ModerationActionTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ModeratorUserModerationActions = []*userRModeratorUserModerationActionsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewModeratorUserModerationActions(number int, mods ...ModerationActionMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewModerationAction(ctx, mods...)
		m.WithModeratorUserModerationActions(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddModeratorUserModerationActions(number int, related *ModerationActionTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ModeratorUserModerationActions = append(o.r.ModeratorUserModerationActions, &userRModeratorUserModerationActionsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewModeratorUserModerationActions(number int, mods ...ModerationActionMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewModerationAction(ctx, mods...)
		m.AddModeratorUserModerationActions(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutModeratorUserModerationActions() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ModeratorUserModerationActions = nil
	})
}

func (m userMods) WithTargetUserModerationActions(number int, related *ModerationActionTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.TargetUserModerationActions = []*userRTargetUserModerationActionsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewTargetUserModerationActions(number int, mods ...ModerationActionMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewModerationAction(ctx, mods...)
		m.WithTargetUserModerationActions(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddTargetUserModerationActions(number int, related *ModerationActionTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.TargetUserModerationActions = append(o.r.TargetUserModerationActions, &userRTargetUserModerationActionsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewTargetUserModerationActions(number int, mods ...ModerationActionMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewModerationAction(ctx, mods...)
		m.AddTargetUserModerationActions(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutTargetUserModerationActions() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.TargetUserModerationActions = nil
	})
}

func (m userMods) WithRemovedByUserPosts(number int, related *PostTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.RemovedByUserPosts = []*userRRemovedByUserPostsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewRemovedByUserPosts(number int, mods ...PostMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewPost(ctx, mods...)
		m.WithRemovedByUserPosts(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddRemovedByUserPosts(number int, related *PostTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.RemovedByUserPosts = append(o.r.RemovedByUserPosts, &userRRemovedByUserPostsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewRemovedByUserPosts(number int, mods ...PostMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewPost(ctx, mods...)
		m.AddRemovedByUserPosts(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutRemovedByUserPosts() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.RemovedByUserPosts = nil
	})
}

func (m userMods) WithPseudonyms(number int, related *PseudonymTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Pseudonyms = []*userRPseudonymsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewPseudonyms(number int, mods ...PseudonymMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewPseudonym(ctx, mods...)
		m.WithPseudonyms(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddPseudonyms(number int, related *PseudonymTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Pseudonyms = append(o.r.Pseudonyms, &userRPseudonymsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewPseudonyms(number int, mods ...PseudonymMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewPseudonym(ctx, mods...)
		m.AddPseudonyms(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutPseudonyms() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Pseudonyms = nil
	})
}

func (m userMods) WithResolvedByUserReports(number int, related *ReportTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ResolvedByUserReports = []*userRResolvedByUserReportsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewResolvedByUserReports(number int, mods ...ReportMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewReport(ctx, mods...)
		m.WithResolvedByUserReports(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddResolvedByUserReports(number int, related *ReportTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ResolvedByUserReports = append(o.r.ResolvedByUserReports, &userRResolvedByUserReportsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewResolvedByUserReports(number int, mods ...ReportMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewReport(ctx, mods...)
		m.AddResolvedByUserReports(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutResolvedByUserReports() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ResolvedByUserReports = nil
	})
}

func (m userMods) WithCreatedByRoleKeys(number int, related *RoleKeyTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CreatedByRoleKeys = []*userRCreatedByRoleKeysR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewCreatedByRoleKeys(number int, mods ...RoleKeyMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewRoleKey(ctx, mods...)
		m.WithCreatedByRoleKeys(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddCreatedByRoleKeys(number int, related *RoleKeyTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CreatedByRoleKeys = append(o.r.CreatedByRoleKeys, &userRCreatedByRoleKeysR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewCreatedByRoleKeys(number int, mods ...RoleKeyMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewRoleKey(ctx, mods...)
		m.AddCreatedByRoleKeys(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutCreatedByRoleKeys() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CreatedByRoleKeys = nil
	})
}

func (m userMods) WithAddedByUserSubforumModerators(number int, related *SubforumModeratorTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AddedByUserSubforumModerators = []*userRAddedByUserSubforumModeratorsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewAddedByUserSubforumModerators(number int, mods ...SubforumModeratorMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewSubforumModerator(ctx, mods...)
		m.WithAddedByUserSubforumModerators(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddAddedByUserSubforumModerators(number int, related *SubforumModeratorTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AddedByUserSubforumModerators = append(o.r.AddedByUserSubforumModerators, &userRAddedByUserSubforumModeratorsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewAddedByUserSubforumModerators(number int, mods ...SubforumModeratorMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewSubforumModerator(ctx, mods...)
		m.AddAddedByUserSubforumModerators(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutAddedByUserSubforumModerators() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AddedByUserSubforumModerators = nil
	})
}

func (m userMods) WithSubforumModerators(number int, related *SubforumModeratorTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.SubforumModerators = []*userRSubforumModeratorsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewSubforumModerators(number int, mods ...SubforumModeratorMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewSubforumModerator(ctx, mods...)
		m.WithSubforumModerators(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddSubforumModerators(number int, related *SubforumModeratorTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.SubforumModerators = append(o.r.SubforumModerators, &userRSubforumModeratorsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewSubforumModerators(number int, mods ...SubforumModeratorMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewSubforumModerator(ctx, mods...)
		m.AddSubforumModerators(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutSubforumModerators() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.SubforumModerators = nil
	})
}

func (m userMods) WithCreatedByUserSubforums(number int, related *SubforumTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CreatedByUserSubforums = []*userRCreatedByUserSubforumsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewCreatedByUserSubforums(number int, mods ...SubforumMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewSubforum(ctx, mods...)
		m.WithCreatedByUserSubforums(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddCreatedByUserSubforums(number int, related *SubforumTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CreatedByUserSubforums = append(o.r.CreatedByUserSubforums, &userRCreatedByUserSubforumsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewCreatedByUserSubforums(number int, mods ...SubforumMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewSubforum(ctx, mods...)
		m.AddCreatedByUserSubforums(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutCreatedByUserSubforums() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CreatedByUserSubforums = nil
	})
}

func (m userMods) WithUpdatedBySystemSettings(number int, related *SystemSettingTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UpdatedBySystemSettings = []*userRUpdatedBySystemSettingsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewUpdatedBySystemSettings(number int, mods ...SystemSettingMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewSystemSetting(ctx, mods...)
		m.WithUpdatedBySystemSettings(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddUpdatedBySystemSettings(number int, related *SystemSettingTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UpdatedBySystemSettings = append(o.r.UpdatedBySystemSettings, &userRUpdatedBySystemSettingsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewUpdatedBySystemSettings(number int, mods ...SystemSettingMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewSystemSetting(ctx, mods...)
		m.AddUpdatedBySystemSettings(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutUpdatedBySystemSettings() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UpdatedBySystemSettings = nil
	})
}

func (m userMods) WithBannedByUserUserBans(number int, related *UserBanTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.BannedByUserUserBans = []*userRBannedByUserUserBansR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewBannedByUserUserBans(number int, mods ...UserBanMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserBan(ctx, mods...)
		m.WithBannedByUserUserBans(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddBannedByUserUserBans(number int, related *UserBanTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.BannedByUserUserBans = append(o.r.BannedByUserUserBans, &userRBannedByUserUserBansR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewBannedByUserUserBans(number int, mods ...UserBanMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserBan(ctx, mods...)
		m.AddBannedByUserUserBans(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutBannedByUserUserBans() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.BannedByUserUserBans = nil
	})
}

func (m userMods) WithBannedUserUserBans(number int, related *UserBanTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.BannedUserUserBans = []*userRBannedUserUserBansR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewBannedUserUserBans(number int, mods ...UserBanMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserBan(ctx, mods...)
		m.WithBannedUserUserBans(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddBannedUserUserBans(number int, related *UserBanTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.BannedUserUserBans = append(o.r.BannedUserUserBans, &userRBannedUserUserBansR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewBannedUserUserBans(number int, mods ...UserBanMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserBan(ctx, mods...)
		m.AddBannedUserUserBans(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutBannedUserUserBans() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.BannedUserUserBans = nil
	})
}

func (m userMods) WithBlockedUserUserBlocks(number int, related *UserBlockTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.BlockedUserUserBlocks = []*userRBlockedUserUserBlocksR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewBlockedUserUserBlocks(number int, mods ...UserBlockMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserBlock(ctx, mods...)
		m.WithBlockedUserUserBlocks(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddBlockedUserUserBlocks(number int, related *UserBlockTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.BlockedUserUserBlocks = append(o.r.BlockedUserUserBlocks, &userRBlockedUserUserBlocksR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewBlockedUserUserBlocks(number int, mods ...UserBlockMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserBlock(ctx, mods...)
		m.AddBlockedUserUserBlocks(number, related).Apply(ctx, o)
	})
}

func (m userMods) WithoutBlockedUserUserBlocks() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.BlockedUserUserBlocks = nil
	})
}
