// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"database/sql"
	"testing"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/jaswdr/faker/v2"
	models "github.com/matt0x6f/hashpost/internal/database/models"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/types/pgtypes"
)

type KeyUsageAuditMod interface {
	Apply(context.Context, *KeyUsageAuditTemplate)
}

type KeyUsageAuditModFunc func(context.Context, *KeyUsageAuditTemplate)

func (f KeyUsageAuditModFunc) Apply(ctx context.Context, n *KeyUsageAuditTemplate) {
	f(ctx, n)
}

type KeyUsageAuditModSlice []KeyUsageAuditMod

func (mods KeyUsageAuditModSlice) Apply(ctx context.Context, n *KeyUsageAuditTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// KeyUsageAuditTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type KeyUsageAuditTemplate struct {
	UsageID           func() uuid.UUID
	KeyID             func() uuid.UUID
	UserID            func() int64
	OperationType     func() string
	TargetFingerprint func() sql.Null[string]
	TargetPseudonym   func() sql.Null[string]
	Success           func() bool
	ErrorMessage      func() sql.Null[string]
	Timestamp         func() sql.Null[time.Time]
	IPAddress         func() sql.Null[pgtypes.Inet]
	UserAgent         func() sql.Null[string]

	r keyUsageAuditR
	f *Factory
}

type keyUsageAuditR struct {
	KeyRoleKey *keyUsageAuditRKeyRoleKeyR
	User       *keyUsageAuditRUserR
}

type keyUsageAuditRKeyRoleKeyR struct {
	o *RoleKeyTemplate
}
type keyUsageAuditRUserR struct {
	o *UserTemplate
}

// Apply mods to the KeyUsageAuditTemplate
func (o *KeyUsageAuditTemplate) Apply(ctx context.Context, mods ...KeyUsageAuditMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// setModelRels creates and sets the relationships on *models.KeyUsageAudit
// according to the relationships in the template. Nothing is inserted into the db
func (t KeyUsageAuditTemplate) setModelRels(o *models.KeyUsageAudit) {
	if t.r.KeyRoleKey != nil {
		rel := t.r.KeyRoleKey.o.Build()
		rel.R.KeyKeyUsageAudits = append(rel.R.KeyKeyUsageAudits, o)
		o.KeyID = rel.KeyID // h2
		o.R.KeyRoleKey = rel
	}

	if t.r.User != nil {
		rel := t.r.User.o.Build()
		rel.R.KeyUsageAudits = append(rel.R.KeyUsageAudits, o)
		o.UserID = rel.UserID // h2
		o.R.User = rel
	}
}

// BuildSetter returns an *models.KeyUsageAuditSetter
// this does nothing with the relationship templates
func (o KeyUsageAuditTemplate) BuildSetter() *models.KeyUsageAuditSetter {
	m := &models.KeyUsageAuditSetter{}

	if o.UsageID != nil {
		val := o.UsageID()
		m.UsageID = &val
	}
	if o.KeyID != nil {
		val := o.KeyID()
		m.KeyID = &val
	}
	if o.UserID != nil {
		val := o.UserID()
		m.UserID = &val
	}
	if o.OperationType != nil {
		val := o.OperationType()
		m.OperationType = &val
	}
	if o.TargetFingerprint != nil {
		val := o.TargetFingerprint()
		m.TargetFingerprint = &val
	}
	if o.TargetPseudonym != nil {
		val := o.TargetPseudonym()
		m.TargetPseudonym = &val
	}
	if o.Success != nil {
		val := o.Success()
		m.Success = &val
	}
	if o.ErrorMessage != nil {
		val := o.ErrorMessage()
		m.ErrorMessage = &val
	}
	if o.Timestamp != nil {
		val := o.Timestamp()
		m.Timestamp = &val
	}
	if o.IPAddress != nil {
		val := o.IPAddress()
		m.IPAddress = &val
	}
	if o.UserAgent != nil {
		val := o.UserAgent()
		m.UserAgent = &val
	}

	return m
}

// BuildManySetter returns an []*models.KeyUsageAuditSetter
// this does nothing with the relationship templates
func (o KeyUsageAuditTemplate) BuildManySetter(number int) []*models.KeyUsageAuditSetter {
	m := make([]*models.KeyUsageAuditSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.KeyUsageAudit
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use KeyUsageAuditTemplate.Create
func (o KeyUsageAuditTemplate) Build() *models.KeyUsageAudit {
	m := &models.KeyUsageAudit{}

	if o.UsageID != nil {
		m.UsageID = o.UsageID()
	}
	if o.KeyID != nil {
		m.KeyID = o.KeyID()
	}
	if o.UserID != nil {
		m.UserID = o.UserID()
	}
	if o.OperationType != nil {
		m.OperationType = o.OperationType()
	}
	if o.TargetFingerprint != nil {
		m.TargetFingerprint = o.TargetFingerprint()
	}
	if o.TargetPseudonym != nil {
		m.TargetPseudonym = o.TargetPseudonym()
	}
	if o.Success != nil {
		m.Success = o.Success()
	}
	if o.ErrorMessage != nil {
		m.ErrorMessage = o.ErrorMessage()
	}
	if o.Timestamp != nil {
		m.Timestamp = o.Timestamp()
	}
	if o.IPAddress != nil {
		m.IPAddress = o.IPAddress()
	}
	if o.UserAgent != nil {
		m.UserAgent = o.UserAgent()
	}

	o.setModelRels(m)

	return m
}

// BuildMany returns an models.KeyUsageAuditSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use KeyUsageAuditTemplate.CreateMany
func (o KeyUsageAuditTemplate) BuildMany(number int) models.KeyUsageAuditSlice {
	m := make(models.KeyUsageAuditSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableKeyUsageAudit(m *models.KeyUsageAuditSetter) {
	if m.KeyID == nil {
		val := random_uuid_UUID(nil)
		m.KeyID = &val
	}
	if m.UserID == nil {
		val := random_int64(nil)
		m.UserID = &val
	}
	if m.OperationType == nil {
		val := random_string(nil, "50")
		m.OperationType = &val
	}
	if m.Success == nil {
		val := random_bool(nil)
		m.Success = &val
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.KeyUsageAudit
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *KeyUsageAuditTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.KeyUsageAudit) (context.Context, error) {
	var err error

	return ctx, err
}

// Create builds a keyUsageAudit and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *KeyUsageAuditTemplate) Create(ctx context.Context, exec bob.Executor) (*models.KeyUsageAudit, error) {
	_, m, err := o.create(ctx, exec)
	return m, err
}

// MustCreate builds a keyUsageAudit and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *KeyUsageAuditTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.KeyUsageAudit {
	_, m, err := o.create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a keyUsageAudit and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *KeyUsageAuditTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.KeyUsageAudit {
	tb.Helper()
	_, m, err := o.create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// create builds a keyUsageAudit and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted model
func (o *KeyUsageAuditTemplate) create(ctx context.Context, exec bob.Executor) (context.Context, *models.KeyUsageAudit, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableKeyUsageAudit(opt)

	if o.r.KeyRoleKey == nil {
		KeyUsageAuditMods.WithNewKeyRoleKey().Apply(ctx, o)
	}

	rel0, ok := roleKeyCtx.Value(ctx)
	if !ok {
		ctx, rel0, err = o.r.KeyRoleKey.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	opt.KeyID = &rel0.KeyID

	if o.r.User == nil {
		KeyUsageAuditMods.WithNewUser().Apply(ctx, o)
	}

	rel1, ok := userCtx.Value(ctx)
	if !ok {
		ctx, rel1, err = o.r.User.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	opt.UserID = &rel1.UserID

	m, err := models.KeyUsageAudits.Insert(opt).One(ctx, exec)
	if err != nil {
		return ctx, nil, err
	}
	ctx = keyUsageAuditCtx.WithValue(ctx, m)

	m.R.KeyRoleKey = rel0
	m.R.User = rel1

	ctx, err = o.insertOptRels(ctx, exec, m)
	return ctx, m, err
}

// CreateMany builds multiple keyUsageAudits and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o KeyUsageAuditTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.KeyUsageAuditSlice, error) {
	_, m, err := o.createMany(ctx, exec, number)
	return m, err
}

// MustCreateMany builds multiple keyUsageAudits and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o KeyUsageAuditTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.KeyUsageAuditSlice {
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple keyUsageAudits and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o KeyUsageAuditTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.KeyUsageAuditSlice {
	tb.Helper()
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// createMany builds multiple keyUsageAudits and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted models
func (o KeyUsageAuditTemplate) createMany(ctx context.Context, exec bob.Executor, number int) (context.Context, models.KeyUsageAuditSlice, error) {
	var err error
	m := make(models.KeyUsageAuditSlice, number)

	for i := range m {
		ctx, m[i], err = o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	return ctx, m, nil
}

// KeyUsageAudit has methods that act as mods for the KeyUsageAuditTemplate
var KeyUsageAuditMods keyUsageAuditMods

type keyUsageAuditMods struct{}

func (m keyUsageAuditMods) RandomizeAllColumns(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModSlice{
		KeyUsageAuditMods.RandomUsageID(f),
		KeyUsageAuditMods.RandomKeyID(f),
		KeyUsageAuditMods.RandomUserID(f),
		KeyUsageAuditMods.RandomOperationType(f),
		KeyUsageAuditMods.RandomTargetFingerprint(f),
		KeyUsageAuditMods.RandomTargetPseudonym(f),
		KeyUsageAuditMods.RandomSuccess(f),
		KeyUsageAuditMods.RandomErrorMessage(f),
		KeyUsageAuditMods.RandomTimestamp(f),
		KeyUsageAuditMods.RandomIPAddress(f),
		KeyUsageAuditMods.RandomUserAgent(f),
	}
}

// Set the model columns to this value
func (m keyUsageAuditMods) UsageID(val uuid.UUID) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UsageID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) UsageIDFunc(f func() uuid.UUID) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UsageID = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetUsageID() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UsageID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m keyUsageAuditMods) RandomUsageID(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UsageID = func() uuid.UUID {
			return random_uuid_UUID(f)
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) KeyID(val uuid.UUID) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.KeyID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) KeyIDFunc(f func() uuid.UUID) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.KeyID = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetKeyID() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.KeyID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m keyUsageAuditMods) RandomKeyID(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.KeyID = func() uuid.UUID {
			return random_uuid_UUID(f)
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) UserID(val int64) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UserID = func() int64 { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) UserIDFunc(f func() int64) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UserID = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetUserID() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UserID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m keyUsageAuditMods) RandomUserID(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UserID = func() int64 {
			return random_int64(f)
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) OperationType(val string) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.OperationType = func() string { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) OperationTypeFunc(f func() string) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.OperationType = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetOperationType() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.OperationType = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m keyUsageAuditMods) RandomOperationType(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.OperationType = func() string {
			return random_string(f, "50")
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) TargetFingerprint(val sql.Null[string]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetFingerprint = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) TargetFingerprintFunc(f func() sql.Null[string]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetFingerprint = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetTargetFingerprint() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetFingerprint = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m keyUsageAuditMods) RandomTargetFingerprint(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetFingerprint = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "32")
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m keyUsageAuditMods) RandomTargetFingerprintNotNull(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetFingerprint = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "32")
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) TargetPseudonym(val sql.Null[string]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetPseudonym = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) TargetPseudonymFunc(f func() sql.Null[string]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetPseudonym = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetTargetPseudonym() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetPseudonym = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m keyUsageAuditMods) RandomTargetPseudonym(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetPseudonym = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "64")
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m keyUsageAuditMods) RandomTargetPseudonymNotNull(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.TargetPseudonym = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "64")
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) Success(val bool) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.Success = func() bool { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) SuccessFunc(f func() bool) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.Success = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetSuccess() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.Success = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m keyUsageAuditMods) RandomSuccess(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.Success = func() bool {
			return random_bool(f)
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) ErrorMessage(val sql.Null[string]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.ErrorMessage = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) ErrorMessageFunc(f func() sql.Null[string]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.ErrorMessage = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetErrorMessage() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.ErrorMessage = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m keyUsageAuditMods) RandomErrorMessage(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.ErrorMessage = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m keyUsageAuditMods) RandomErrorMessageNotNull(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.ErrorMessage = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) Timestamp(val sql.Null[time.Time]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.Timestamp = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) TimestampFunc(f func() sql.Null[time.Time]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.Timestamp = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetTimestamp() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.Timestamp = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m keyUsageAuditMods) RandomTimestamp(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.Timestamp = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m keyUsageAuditMods) RandomTimestampNotNull(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.Timestamp = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) IPAddress(val sql.Null[pgtypes.Inet]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.IPAddress = func() sql.Null[pgtypes.Inet] { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) IPAddressFunc(f func() sql.Null[pgtypes.Inet]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.IPAddress = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetIPAddress() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.IPAddress = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m keyUsageAuditMods) RandomIPAddress(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.IPAddress = func() sql.Null[pgtypes.Inet] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_pgtypes_Inet(f)
			return sql.Null[pgtypes.Inet]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m keyUsageAuditMods) RandomIPAddressNotNull(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.IPAddress = func() sql.Null[pgtypes.Inet] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_pgtypes_Inet(f)
			return sql.Null[pgtypes.Inet]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m keyUsageAuditMods) UserAgent(val sql.Null[string]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UserAgent = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m keyUsageAuditMods) UserAgentFunc(f func() sql.Null[string]) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UserAgent = f
	})
}

// Clear any values for the column
func (m keyUsageAuditMods) UnsetUserAgent() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UserAgent = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m keyUsageAuditMods) RandomUserAgent(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UserAgent = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m keyUsageAuditMods) RandomUserAgentNotNull(f *faker.Faker) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(_ context.Context, o *KeyUsageAuditTemplate) {
		o.UserAgent = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

func (m keyUsageAuditMods) WithParentsCascading() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(ctx context.Context, o *KeyUsageAuditTemplate) {
		if isDone, _ := keyUsageAuditWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = keyUsageAuditWithParentsCascadingCtx.WithValue(ctx, true)
		{

			related := o.f.NewRoleKey(ctx, RoleKeyMods.WithParentsCascading())
			m.WithKeyRoleKey(related).Apply(ctx, o)
		}
		{

			related := o.f.NewUser(ctx, UserMods.WithParentsCascading())
			m.WithUser(related).Apply(ctx, o)
		}
	})
}

func (m keyUsageAuditMods) WithKeyRoleKey(rel *RoleKeyTemplate) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(ctx context.Context, o *KeyUsageAuditTemplate) {
		o.r.KeyRoleKey = &keyUsageAuditRKeyRoleKeyR{
			o: rel,
		}
	})
}

func (m keyUsageAuditMods) WithNewKeyRoleKey(mods ...RoleKeyMod) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(ctx context.Context, o *KeyUsageAuditTemplate) {
		related := o.f.NewRoleKey(ctx, mods...)

		m.WithKeyRoleKey(related).Apply(ctx, o)
	})
}

func (m keyUsageAuditMods) WithoutKeyRoleKey() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(ctx context.Context, o *KeyUsageAuditTemplate) {
		o.r.KeyRoleKey = nil
	})
}

func (m keyUsageAuditMods) WithUser(rel *UserTemplate) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(ctx context.Context, o *KeyUsageAuditTemplate) {
		o.r.User = &keyUsageAuditRUserR{
			o: rel,
		}
	})
}

func (m keyUsageAuditMods) WithNewUser(mods ...UserMod) KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(ctx context.Context, o *KeyUsageAuditTemplate) {
		related := o.f.NewUser(ctx, mods...)

		m.WithUser(related).Apply(ctx, o)
	})
}

func (m keyUsageAuditMods) WithoutUser() KeyUsageAuditMod {
	return KeyUsageAuditModFunc(func(ctx context.Context, o *KeyUsageAuditTemplate) {
		o.r.User = nil
	})
}
