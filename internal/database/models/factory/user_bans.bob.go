// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"database/sql"
	"testing"
	"time"

	"github.com/jaswdr/faker/v2"
	models "github.com/matt0x6f/hashpost/internal/database/models"
	"github.com/stephenafamo/bob"
)

type UserBanMod interface {
	Apply(context.Context, *UserBanTemplate)
}

type UserBanModFunc func(context.Context, *UserBanTemplate)

func (f UserBanModFunc) Apply(ctx context.Context, n *UserBanTemplate) {
	f(ctx, n)
}

type UserBanModSlice []UserBanMod

func (mods UserBanModSlice) Apply(ctx context.Context, n *UserBanTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// UserBanTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type UserBanTemplate struct {
	BanID               func() int64
	SubforumID          func() int32
	BannedUserID        func() int64
	BannedByUserID      func() int64
	BannedByPseudonymID func() string
	BanReason           func() string
	IsPermanent         func() sql.Null[bool]
	ExpiresAt           func() sql.Null[time.Time]
	CreatedAt           func() sql.Null[time.Time]
	IsActive            func() sql.Null[bool]

	r userBanR
	f *Factory
}

type userBanR struct {
	BannedByPseudonymPseudonym *userBanRBannedByPseudonymPseudonymR
	BannedByUserUser           *userBanRBannedByUserUserR
	BannedUserUser             *userBanRBannedUserUserR
	Subforum                   *userBanRSubforumR
}

type userBanRBannedByPseudonymPseudonymR struct {
	o *PseudonymTemplate
}
type userBanRBannedByUserUserR struct {
	o *UserTemplate
}
type userBanRBannedUserUserR struct {
	o *UserTemplate
}
type userBanRSubforumR struct {
	o *SubforumTemplate
}

// Apply mods to the UserBanTemplate
func (o *UserBanTemplate) Apply(ctx context.Context, mods ...UserBanMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// setModelRels creates and sets the relationships on *models.UserBan
// according to the relationships in the template. Nothing is inserted into the db
func (t UserBanTemplate) setModelRels(o *models.UserBan) {
	if t.r.BannedByPseudonymPseudonym != nil {
		rel := t.r.BannedByPseudonymPseudonym.o.Build()
		rel.R.BannedByPseudonymUserBans = append(rel.R.BannedByPseudonymUserBans, o)
		o.BannedByPseudonymID = rel.PseudonymID // h2
		o.R.BannedByPseudonymPseudonym = rel
	}

	if t.r.BannedByUserUser != nil {
		rel := t.r.BannedByUserUser.o.Build()
		rel.R.BannedByUserUserBans = append(rel.R.BannedByUserUserBans, o)
		o.BannedByUserID = rel.UserID // h2
		o.R.BannedByUserUser = rel
	}

	if t.r.BannedUserUser != nil {
		rel := t.r.BannedUserUser.o.Build()
		rel.R.BannedUserUserBans = append(rel.R.BannedUserUserBans, o)
		o.BannedUserID = rel.UserID // h2
		o.R.BannedUserUser = rel
	}

	if t.r.Subforum != nil {
		rel := t.r.Subforum.o.Build()
		rel.R.UserBans = append(rel.R.UserBans, o)
		o.SubforumID = rel.SubforumID // h2
		o.R.Subforum = rel
	}
}

// BuildSetter returns an *models.UserBanSetter
// this does nothing with the relationship templates
func (o UserBanTemplate) BuildSetter() *models.UserBanSetter {
	m := &models.UserBanSetter{}

	if o.BanID != nil {
		val := o.BanID()
		m.BanID = &val
	}
	if o.SubforumID != nil {
		val := o.SubforumID()
		m.SubforumID = &val
	}
	if o.BannedUserID != nil {
		val := o.BannedUserID()
		m.BannedUserID = &val
	}
	if o.BannedByUserID != nil {
		val := o.BannedByUserID()
		m.BannedByUserID = &val
	}
	if o.BannedByPseudonymID != nil {
		val := o.BannedByPseudonymID()
		m.BannedByPseudonymID = &val
	}
	if o.BanReason != nil {
		val := o.BanReason()
		m.BanReason = &val
	}
	if o.IsPermanent != nil {
		val := o.IsPermanent()
		m.IsPermanent = &val
	}
	if o.ExpiresAt != nil {
		val := o.ExpiresAt()
		m.ExpiresAt = &val
	}
	if o.CreatedAt != nil {
		val := o.CreatedAt()
		m.CreatedAt = &val
	}
	if o.IsActive != nil {
		val := o.IsActive()
		m.IsActive = &val
	}

	return m
}

// BuildManySetter returns an []*models.UserBanSetter
// this does nothing with the relationship templates
func (o UserBanTemplate) BuildManySetter(number int) []*models.UserBanSetter {
	m := make([]*models.UserBanSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.UserBan
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use UserBanTemplate.Create
func (o UserBanTemplate) Build() *models.UserBan {
	m := &models.UserBan{}

	if o.BanID != nil {
		m.BanID = o.BanID()
	}
	if o.SubforumID != nil {
		m.SubforumID = o.SubforumID()
	}
	if o.BannedUserID != nil {
		m.BannedUserID = o.BannedUserID()
	}
	if o.BannedByUserID != nil {
		m.BannedByUserID = o.BannedByUserID()
	}
	if o.BannedByPseudonymID != nil {
		m.BannedByPseudonymID = o.BannedByPseudonymID()
	}
	if o.BanReason != nil {
		m.BanReason = o.BanReason()
	}
	if o.IsPermanent != nil {
		m.IsPermanent = o.IsPermanent()
	}
	if o.ExpiresAt != nil {
		m.ExpiresAt = o.ExpiresAt()
	}
	if o.CreatedAt != nil {
		m.CreatedAt = o.CreatedAt()
	}
	if o.IsActive != nil {
		m.IsActive = o.IsActive()
	}

	o.setModelRels(m)

	return m
}

// BuildMany returns an models.UserBanSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use UserBanTemplate.CreateMany
func (o UserBanTemplate) BuildMany(number int) models.UserBanSlice {
	m := make(models.UserBanSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableUserBan(m *models.UserBanSetter) {
	if m.SubforumID == nil {
		val := random_int32(nil)
		m.SubforumID = &val
	}
	if m.BannedUserID == nil {
		val := random_int64(nil)
		m.BannedUserID = &val
	}
	if m.BannedByUserID == nil {
		val := random_int64(nil)
		m.BannedByUserID = &val
	}
	if m.BannedByPseudonymID == nil {
		val := random_string(nil, "64")
		m.BannedByPseudonymID = &val
	}
	if m.BanReason == nil {
		val := random_string(nil)
		m.BanReason = &val
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.UserBan
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *UserBanTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.UserBan) (context.Context, error) {
	var err error

	return ctx, err
}

// Create builds a userBan and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *UserBanTemplate) Create(ctx context.Context, exec bob.Executor) (*models.UserBan, error) {
	_, m, err := o.create(ctx, exec)
	return m, err
}

// MustCreate builds a userBan and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *UserBanTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.UserBan {
	_, m, err := o.create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a userBan and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *UserBanTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.UserBan {
	tb.Helper()
	_, m, err := o.create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// create builds a userBan and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted model
func (o *UserBanTemplate) create(ctx context.Context, exec bob.Executor) (context.Context, *models.UserBan, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableUserBan(opt)

	if o.r.BannedByPseudonymPseudonym == nil {
		UserBanMods.WithNewBannedByPseudonymPseudonym().Apply(ctx, o)
	}

	rel0, ok := pseudonymCtx.Value(ctx)
	if !ok {
		ctx, rel0, err = o.r.BannedByPseudonymPseudonym.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	opt.BannedByPseudonymID = &rel0.PseudonymID

	if o.r.BannedByUserUser == nil {
		UserBanMods.WithNewBannedByUserUser().Apply(ctx, o)
	}

	rel1, ok := userCtx.Value(ctx)
	if !ok {
		ctx, rel1, err = o.r.BannedByUserUser.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	opt.BannedByUserID = &rel1.UserID

	if o.r.BannedUserUser == nil {
		UserBanMods.WithNewBannedUserUser().Apply(ctx, o)
	}

	rel2, ok := userCtx.Value(ctx)
	if !ok {
		ctx, rel2, err = o.r.BannedUserUser.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	opt.BannedUserID = &rel2.UserID

	if o.r.Subforum == nil {
		UserBanMods.WithNewSubforum().Apply(ctx, o)
	}

	rel3, ok := subforumCtx.Value(ctx)
	if !ok {
		ctx, rel3, err = o.r.Subforum.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	opt.SubforumID = &rel3.SubforumID

	m, err := models.UserBans.Insert(opt).One(ctx, exec)
	if err != nil {
		return ctx, nil, err
	}
	ctx = userBanCtx.WithValue(ctx, m)

	m.R.BannedByPseudonymPseudonym = rel0
	m.R.BannedByUserUser = rel1
	m.R.BannedUserUser = rel2
	m.R.Subforum = rel3

	ctx, err = o.insertOptRels(ctx, exec, m)
	return ctx, m, err
}

// CreateMany builds multiple userBans and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o UserBanTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.UserBanSlice, error) {
	_, m, err := o.createMany(ctx, exec, number)
	return m, err
}

// MustCreateMany builds multiple userBans and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o UserBanTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.UserBanSlice {
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple userBans and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o UserBanTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.UserBanSlice {
	tb.Helper()
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// createMany builds multiple userBans and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted models
func (o UserBanTemplate) createMany(ctx context.Context, exec bob.Executor, number int) (context.Context, models.UserBanSlice, error) {
	var err error
	m := make(models.UserBanSlice, number)

	for i := range m {
		ctx, m[i], err = o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	return ctx, m, nil
}

// UserBan has methods that act as mods for the UserBanTemplate
var UserBanMods userBanMods

type userBanMods struct{}

func (m userBanMods) RandomizeAllColumns(f *faker.Faker) UserBanMod {
	return UserBanModSlice{
		UserBanMods.RandomBanID(f),
		UserBanMods.RandomSubforumID(f),
		UserBanMods.RandomBannedUserID(f),
		UserBanMods.RandomBannedByUserID(f),
		UserBanMods.RandomBannedByPseudonymID(f),
		UserBanMods.RandomBanReason(f),
		UserBanMods.RandomIsPermanent(f),
		UserBanMods.RandomExpiresAt(f),
		UserBanMods.RandomCreatedAt(f),
		UserBanMods.RandomIsActive(f),
	}
}

// Set the model columns to this value
func (m userBanMods) BanID(val int64) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BanID = func() int64 { return val }
	})
}

// Set the Column from the function
func (m userBanMods) BanIDFunc(f func() int64) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BanID = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetBanID() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BanID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userBanMods) RandomBanID(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BanID = func() int64 {
			return random_int64(f)
		}
	})
}

// Set the model columns to this value
func (m userBanMods) SubforumID(val int32) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.SubforumID = func() int32 { return val }
	})
}

// Set the Column from the function
func (m userBanMods) SubforumIDFunc(f func() int32) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.SubforumID = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetSubforumID() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.SubforumID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userBanMods) RandomSubforumID(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.SubforumID = func() int32 {
			return random_int32(f)
		}
	})
}

// Set the model columns to this value
func (m userBanMods) BannedUserID(val int64) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedUserID = func() int64 { return val }
	})
}

// Set the Column from the function
func (m userBanMods) BannedUserIDFunc(f func() int64) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedUserID = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetBannedUserID() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedUserID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userBanMods) RandomBannedUserID(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedUserID = func() int64 {
			return random_int64(f)
		}
	})
}

// Set the model columns to this value
func (m userBanMods) BannedByUserID(val int64) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedByUserID = func() int64 { return val }
	})
}

// Set the Column from the function
func (m userBanMods) BannedByUserIDFunc(f func() int64) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedByUserID = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetBannedByUserID() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedByUserID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userBanMods) RandomBannedByUserID(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedByUserID = func() int64 {
			return random_int64(f)
		}
	})
}

// Set the model columns to this value
func (m userBanMods) BannedByPseudonymID(val string) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedByPseudonymID = func() string { return val }
	})
}

// Set the Column from the function
func (m userBanMods) BannedByPseudonymIDFunc(f func() string) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedByPseudonymID = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetBannedByPseudonymID() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedByPseudonymID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userBanMods) RandomBannedByPseudonymID(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BannedByPseudonymID = func() string {
			return random_string(f, "64")
		}
	})
}

// Set the model columns to this value
func (m userBanMods) BanReason(val string) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BanReason = func() string { return val }
	})
}

// Set the Column from the function
func (m userBanMods) BanReasonFunc(f func() string) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BanReason = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetBanReason() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BanReason = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userBanMods) RandomBanReason(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.BanReason = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m userBanMods) IsPermanent(val sql.Null[bool]) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsPermanent = func() sql.Null[bool] { return val }
	})
}

// Set the Column from the function
func (m userBanMods) IsPermanentFunc(f func() sql.Null[bool]) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsPermanent = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetIsPermanent() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsPermanent = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userBanMods) RandomIsPermanent(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsPermanent = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userBanMods) RandomIsPermanentNotNull(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsPermanent = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userBanMods) ExpiresAt(val sql.Null[time.Time]) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.ExpiresAt = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m userBanMods) ExpiresAtFunc(f func() sql.Null[time.Time]) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.ExpiresAt = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetExpiresAt() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.ExpiresAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userBanMods) RandomExpiresAt(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.ExpiresAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userBanMods) RandomExpiresAtNotNull(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.ExpiresAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userBanMods) CreatedAt(val sql.Null[time.Time]) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.CreatedAt = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m userBanMods) CreatedAtFunc(f func() sql.Null[time.Time]) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.CreatedAt = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetCreatedAt() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.CreatedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userBanMods) RandomCreatedAt(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.CreatedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userBanMods) RandomCreatedAtNotNull(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.CreatedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userBanMods) IsActive(val sql.Null[bool]) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsActive = func() sql.Null[bool] { return val }
	})
}

// Set the Column from the function
func (m userBanMods) IsActiveFunc(f func() sql.Null[bool]) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsActive = f
	})
}

// Clear any values for the column
func (m userBanMods) UnsetIsActive() UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsActive = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userBanMods) RandomIsActive(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsActive = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userBanMods) RandomIsActiveNotNull(f *faker.Faker) UserBanMod {
	return UserBanModFunc(func(_ context.Context, o *UserBanTemplate) {
		o.IsActive = func() sql.Null[bool] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_bool(f)
			return sql.Null[bool]{V: val, Valid: true}
		}
	})
}

func (m userBanMods) WithParentsCascading() UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		if isDone, _ := userBanWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = userBanWithParentsCascadingCtx.WithValue(ctx, true)
		{

			related := o.f.NewPseudonym(ctx, PseudonymMods.WithParentsCascading())
			m.WithBannedByPseudonymPseudonym(related).Apply(ctx, o)
		}
		{

			related := o.f.NewUser(ctx, UserMods.WithParentsCascading())
			m.WithBannedByUserUser(related).Apply(ctx, o)
		}
		{

			related := o.f.NewUser(ctx, UserMods.WithParentsCascading())
			m.WithBannedUserUser(related).Apply(ctx, o)
		}
		{

			related := o.f.NewSubforum(ctx, SubforumMods.WithParentsCascading())
			m.WithSubforum(related).Apply(ctx, o)
		}
	})
}

func (m userBanMods) WithBannedByPseudonymPseudonym(rel *PseudonymTemplate) UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		o.r.BannedByPseudonymPseudonym = &userBanRBannedByPseudonymPseudonymR{
			o: rel,
		}
	})
}

func (m userBanMods) WithNewBannedByPseudonymPseudonym(mods ...PseudonymMod) UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		related := o.f.NewPseudonym(ctx, mods...)

		m.WithBannedByPseudonymPseudonym(related).Apply(ctx, o)
	})
}

func (m userBanMods) WithoutBannedByPseudonymPseudonym() UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		o.r.BannedByPseudonymPseudonym = nil
	})
}

func (m userBanMods) WithBannedByUserUser(rel *UserTemplate) UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		o.r.BannedByUserUser = &userBanRBannedByUserUserR{
			o: rel,
		}
	})
}

func (m userBanMods) WithNewBannedByUserUser(mods ...UserMod) UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		related := o.f.NewUser(ctx, mods...)

		m.WithBannedByUserUser(related).Apply(ctx, o)
	})
}

func (m userBanMods) WithoutBannedByUserUser() UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		o.r.BannedByUserUser = nil
	})
}

func (m userBanMods) WithBannedUserUser(rel *UserTemplate) UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		o.r.BannedUserUser = &userBanRBannedUserUserR{
			o: rel,
		}
	})
}

func (m userBanMods) WithNewBannedUserUser(mods ...UserMod) UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		related := o.f.NewUser(ctx, mods...)

		m.WithBannedUserUser(related).Apply(ctx, o)
	})
}

func (m userBanMods) WithoutBannedUserUser() UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		o.r.BannedUserUser = nil
	})
}

func (m userBanMods) WithSubforum(rel *SubforumTemplate) UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		o.r.Subforum = &userBanRSubforumR{
			o: rel,
		}
	})
}

func (m userBanMods) WithNewSubforum(mods ...SubforumMod) UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		related := o.f.NewSubforum(ctx, mods...)

		m.WithSubforum(related).Apply(ctx, o)
	})
}

func (m userBanMods) WithoutSubforum() UserBanMod {
	return UserBanModFunc(func(ctx context.Context, o *UserBanTemplate) {
		o.r.Subforum = nil
	})
}
