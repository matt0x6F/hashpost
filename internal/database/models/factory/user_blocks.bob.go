// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"database/sql"
	"testing"
	"time"

	"github.com/jaswdr/faker/v2"
	models "github.com/matt0x6f/hashpost/internal/database/models"
	"github.com/stephenafamo/bob"
)

type UserBlockMod interface {
	Apply(context.Context, *UserBlockTemplate)
}

type UserBlockModFunc func(context.Context, *UserBlockTemplate)

func (f UserBlockModFunc) Apply(ctx context.Context, n *UserBlockTemplate) {
	f(ctx, n)
}

type UserBlockModSlice []UserBlockMod

func (mods UserBlockModSlice) Apply(ctx context.Context, n *UserBlockTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// UserBlockTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type UserBlockTemplate struct {
	BlockID            func() int64
	BlockerPseudonymID func() string
	BlockedPseudonymID func() sql.Null[string]
	BlockedUserID      func() sql.Null[int64]
	CreatedAt          func() sql.Null[time.Time]

	r userBlockR
	f *Factory
}

type userBlockR struct {
	BlockedPseudonymPseudonym *userBlockRBlockedPseudonymPseudonymR
	BlockedUserUser           *userBlockRBlockedUserUserR
	BlockerPseudonymPseudonym *userBlockRBlockerPseudonymPseudonymR
}

type userBlockRBlockedPseudonymPseudonymR struct {
	o *PseudonymTemplate
}
type userBlockRBlockedUserUserR struct {
	o *UserTemplate
}
type userBlockRBlockerPseudonymPseudonymR struct {
	o *PseudonymTemplate
}

// Apply mods to the UserBlockTemplate
func (o *UserBlockTemplate) Apply(ctx context.Context, mods ...UserBlockMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// setModelRels creates and sets the relationships on *models.UserBlock
// according to the relationships in the template. Nothing is inserted into the db
func (t UserBlockTemplate) setModelRels(o *models.UserBlock) {
	if t.r.BlockedPseudonymPseudonym != nil {
		rel := t.r.BlockedPseudonymPseudonym.o.Build()
		rel.R.BlockedPseudonymUserBlocks = append(rel.R.BlockedPseudonymUserBlocks, o)
		o.BlockedPseudonymID = sql.Null[string]{V: rel.PseudonymID, Valid: true} // h2
		o.R.BlockedPseudonymPseudonym = rel
	}

	if t.r.BlockedUserUser != nil {
		rel := t.r.BlockedUserUser.o.Build()
		rel.R.BlockedUserUserBlocks = append(rel.R.BlockedUserUserBlocks, o)
		o.BlockedUserID = sql.Null[int64]{V: rel.UserID, Valid: true} // h2
		o.R.BlockedUserUser = rel
	}

	if t.r.BlockerPseudonymPseudonym != nil {
		rel := t.r.BlockerPseudonymPseudonym.o.Build()
		rel.R.BlockerPseudonymUserBlocks = append(rel.R.BlockerPseudonymUserBlocks, o)
		o.BlockerPseudonymID = rel.PseudonymID // h2
		o.R.BlockerPseudonymPseudonym = rel
	}
}

// BuildSetter returns an *models.UserBlockSetter
// this does nothing with the relationship templates
func (o UserBlockTemplate) BuildSetter() *models.UserBlockSetter {
	m := &models.UserBlockSetter{}

	if o.BlockID != nil {
		val := o.BlockID()
		m.BlockID = &val
	}
	if o.BlockerPseudonymID != nil {
		val := o.BlockerPseudonymID()
		m.BlockerPseudonymID = &val
	}
	if o.BlockedPseudonymID != nil {
		val := o.BlockedPseudonymID()
		m.BlockedPseudonymID = &val
	}
	if o.BlockedUserID != nil {
		val := o.BlockedUserID()
		m.BlockedUserID = &val
	}
	if o.CreatedAt != nil {
		val := o.CreatedAt()
		m.CreatedAt = &val
	}

	return m
}

// BuildManySetter returns an []*models.UserBlockSetter
// this does nothing with the relationship templates
func (o UserBlockTemplate) BuildManySetter(number int) []*models.UserBlockSetter {
	m := make([]*models.UserBlockSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.UserBlock
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use UserBlockTemplate.Create
func (o UserBlockTemplate) Build() *models.UserBlock {
	m := &models.UserBlock{}

	if o.BlockID != nil {
		m.BlockID = o.BlockID()
	}
	if o.BlockerPseudonymID != nil {
		m.BlockerPseudonymID = o.BlockerPseudonymID()
	}
	if o.BlockedPseudonymID != nil {
		m.BlockedPseudonymID = o.BlockedPseudonymID()
	}
	if o.BlockedUserID != nil {
		m.BlockedUserID = o.BlockedUserID()
	}
	if o.CreatedAt != nil {
		m.CreatedAt = o.CreatedAt()
	}

	o.setModelRels(m)

	return m
}

// BuildMany returns an models.UserBlockSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use UserBlockTemplate.CreateMany
func (o UserBlockTemplate) BuildMany(number int) models.UserBlockSlice {
	m := make(models.UserBlockSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableUserBlock(m *models.UserBlockSetter) {
	if m.BlockerPseudonymID == nil {
		val := random_string(nil, "64")
		m.BlockerPseudonymID = &val
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.UserBlock
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *UserBlockTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.UserBlock) (context.Context, error) {
	var err error

	isBlockedPseudonymPseudonymDone, _ := userBlockRelBlockedPseudonymPseudonymCtx.Value(ctx)
	if !isBlockedPseudonymPseudonymDone && o.r.BlockedPseudonymPseudonym != nil {
		ctx = userBlockRelBlockedPseudonymPseudonymCtx.WithValue(ctx, true)
		var rel0 *models.Pseudonym
		ctx, rel0, err = o.r.BlockedPseudonymPseudonym.o.create(ctx, exec)
		if err != nil {
			return ctx, err
		}
		err = m.AttachBlockedPseudonymPseudonym(ctx, exec, rel0)
		if err != nil {
			return ctx, err
		}

	}

	isBlockedUserUserDone, _ := userBlockRelBlockedUserUserCtx.Value(ctx)
	if !isBlockedUserUserDone && o.r.BlockedUserUser != nil {
		ctx = userBlockRelBlockedUserUserCtx.WithValue(ctx, true)
		var rel1 *models.User
		ctx, rel1, err = o.r.BlockedUserUser.o.create(ctx, exec)
		if err != nil {
			return ctx, err
		}
		err = m.AttachBlockedUserUser(ctx, exec, rel1)
		if err != nil {
			return ctx, err
		}

	}

	return ctx, err
}

// Create builds a userBlock and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *UserBlockTemplate) Create(ctx context.Context, exec bob.Executor) (*models.UserBlock, error) {
	_, m, err := o.create(ctx, exec)
	return m, err
}

// MustCreate builds a userBlock and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *UserBlockTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.UserBlock {
	_, m, err := o.create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a userBlock and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *UserBlockTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.UserBlock {
	tb.Helper()
	_, m, err := o.create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// create builds a userBlock and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted model
func (o *UserBlockTemplate) create(ctx context.Context, exec bob.Executor) (context.Context, *models.UserBlock, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableUserBlock(opt)

	if o.r.BlockerPseudonymPseudonym == nil {
		UserBlockMods.WithNewBlockerPseudonymPseudonym().Apply(ctx, o)
	}

	rel2, ok := pseudonymCtx.Value(ctx)
	if !ok {
		ctx, rel2, err = o.r.BlockerPseudonymPseudonym.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	opt.BlockerPseudonymID = &rel2.PseudonymID

	m, err := models.UserBlocks.Insert(opt).One(ctx, exec)
	if err != nil {
		return ctx, nil, err
	}
	ctx = userBlockCtx.WithValue(ctx, m)

	m.R.BlockerPseudonymPseudonym = rel2

	ctx, err = o.insertOptRels(ctx, exec, m)
	return ctx, m, err
}

// CreateMany builds multiple userBlocks and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o UserBlockTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.UserBlockSlice, error) {
	_, m, err := o.createMany(ctx, exec, number)
	return m, err
}

// MustCreateMany builds multiple userBlocks and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o UserBlockTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.UserBlockSlice {
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple userBlocks and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o UserBlockTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.UserBlockSlice {
	tb.Helper()
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// createMany builds multiple userBlocks and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted models
func (o UserBlockTemplate) createMany(ctx context.Context, exec bob.Executor, number int) (context.Context, models.UserBlockSlice, error) {
	var err error
	m := make(models.UserBlockSlice, number)

	for i := range m {
		ctx, m[i], err = o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	return ctx, m, nil
}

// UserBlock has methods that act as mods for the UserBlockTemplate
var UserBlockMods userBlockMods

type userBlockMods struct{}

func (m userBlockMods) RandomizeAllColumns(f *faker.Faker) UserBlockMod {
	return UserBlockModSlice{
		UserBlockMods.RandomBlockID(f),
		UserBlockMods.RandomBlockerPseudonymID(f),
		UserBlockMods.RandomBlockedPseudonymID(f),
		UserBlockMods.RandomBlockedUserID(f),
		UserBlockMods.RandomCreatedAt(f),
	}
}

// Set the model columns to this value
func (m userBlockMods) BlockID(val int64) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockID = func() int64 { return val }
	})
}

// Set the Column from the function
func (m userBlockMods) BlockIDFunc(f func() int64) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockID = f
	})
}

// Clear any values for the column
func (m userBlockMods) UnsetBlockID() UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userBlockMods) RandomBlockID(f *faker.Faker) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockID = func() int64 {
			return random_int64(f)
		}
	})
}

// Set the model columns to this value
func (m userBlockMods) BlockerPseudonymID(val string) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockerPseudonymID = func() string { return val }
	})
}

// Set the Column from the function
func (m userBlockMods) BlockerPseudonymIDFunc(f func() string) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockerPseudonymID = f
	})
}

// Clear any values for the column
func (m userBlockMods) UnsetBlockerPseudonymID() UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockerPseudonymID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userBlockMods) RandomBlockerPseudonymID(f *faker.Faker) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockerPseudonymID = func() string {
			return random_string(f, "64")
		}
	})
}

// Set the model columns to this value
func (m userBlockMods) BlockedPseudonymID(val sql.Null[string]) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedPseudonymID = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m userBlockMods) BlockedPseudonymIDFunc(f func() sql.Null[string]) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedPseudonymID = f
	})
}

// Clear any values for the column
func (m userBlockMods) UnsetBlockedPseudonymID() UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedPseudonymID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userBlockMods) RandomBlockedPseudonymID(f *faker.Faker) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedPseudonymID = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "64")
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userBlockMods) RandomBlockedPseudonymIDNotNull(f *faker.Faker) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedPseudonymID = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "64")
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userBlockMods) BlockedUserID(val sql.Null[int64]) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedUserID = func() sql.Null[int64] { return val }
	})
}

// Set the Column from the function
func (m userBlockMods) BlockedUserIDFunc(f func() sql.Null[int64]) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedUserID = f
	})
}

// Clear any values for the column
func (m userBlockMods) UnsetBlockedUserID() UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedUserID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userBlockMods) RandomBlockedUserID(f *faker.Faker) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedUserID = func() sql.Null[int64] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_int64(f)
			return sql.Null[int64]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userBlockMods) RandomBlockedUserIDNotNull(f *faker.Faker) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.BlockedUserID = func() sql.Null[int64] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_int64(f)
			return sql.Null[int64]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m userBlockMods) CreatedAt(val sql.Null[time.Time]) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.CreatedAt = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m userBlockMods) CreatedAtFunc(f func() sql.Null[time.Time]) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.CreatedAt = f
	})
}

// Clear any values for the column
func (m userBlockMods) UnsetCreatedAt() UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.CreatedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userBlockMods) RandomCreatedAt(f *faker.Faker) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.CreatedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userBlockMods) RandomCreatedAtNotNull(f *faker.Faker) UserBlockMod {
	return UserBlockModFunc(func(_ context.Context, o *UserBlockTemplate) {
		o.CreatedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

func (m userBlockMods) WithParentsCascading() UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		if isDone, _ := userBlockWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = userBlockWithParentsCascadingCtx.WithValue(ctx, true)
		{

			related := o.f.NewPseudonym(ctx, PseudonymMods.WithParentsCascading())
			m.WithBlockedPseudonymPseudonym(related).Apply(ctx, o)
		}
		{

			related := o.f.NewUser(ctx, UserMods.WithParentsCascading())
			m.WithBlockedUserUser(related).Apply(ctx, o)
		}
		{

			related := o.f.NewPseudonym(ctx, PseudonymMods.WithParentsCascading())
			m.WithBlockerPseudonymPseudonym(related).Apply(ctx, o)
		}
	})
}

func (m userBlockMods) WithBlockedPseudonymPseudonym(rel *PseudonymTemplate) UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		o.r.BlockedPseudonymPseudonym = &userBlockRBlockedPseudonymPseudonymR{
			o: rel,
		}
	})
}

func (m userBlockMods) WithNewBlockedPseudonymPseudonym(mods ...PseudonymMod) UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		related := o.f.NewPseudonym(ctx, mods...)

		m.WithBlockedPseudonymPseudonym(related).Apply(ctx, o)
	})
}

func (m userBlockMods) WithoutBlockedPseudonymPseudonym() UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		o.r.BlockedPseudonymPseudonym = nil
	})
}

func (m userBlockMods) WithBlockedUserUser(rel *UserTemplate) UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		o.r.BlockedUserUser = &userBlockRBlockedUserUserR{
			o: rel,
		}
	})
}

func (m userBlockMods) WithNewBlockedUserUser(mods ...UserMod) UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		related := o.f.NewUser(ctx, mods...)

		m.WithBlockedUserUser(related).Apply(ctx, o)
	})
}

func (m userBlockMods) WithoutBlockedUserUser() UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		o.r.BlockedUserUser = nil
	})
}

func (m userBlockMods) WithBlockerPseudonymPseudonym(rel *PseudonymTemplate) UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		o.r.BlockerPseudonymPseudonym = &userBlockRBlockerPseudonymPseudonymR{
			o: rel,
		}
	})
}

func (m userBlockMods) WithNewBlockerPseudonymPseudonym(mods ...PseudonymMod) UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		related := o.f.NewPseudonym(ctx, mods...)

		m.WithBlockerPseudonymPseudonym(related).Apply(ctx, o)
	})
}

func (m userBlockMods) WithoutBlockerPseudonymPseudonym() UserBlockMod {
	return UserBlockModFunc(func(ctx context.Context, o *UserBlockTemplate) {
		o.r.BlockerPseudonymPseudonym = nil
	})
}
