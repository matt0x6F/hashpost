// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// User is an object representing the database table.
type User struct {
	UserID              int64                                 `db:"user_id,pk" scan:"user_id" json:"user_id"`
	Email               string                                `db:"email" scan:"email" json:"email"`
	PasswordHash        string                                `db:"password_hash" scan:"password_hash" json:"password_hash"`
	CreatedAt           sql.Null[time.Time]                   `db:"created_at" scan:"created_at" json:"created_at"`
	LastActiveAt        sql.Null[time.Time]                   `db:"last_active_at" scan:"last_active_at" json:"last_active_at"`
	IsActive            sql.Null[bool]                        `db:"is_active" scan:"is_active" json:"is_active"`
	IsSuspended         sql.Null[bool]                        `db:"is_suspended" scan:"is_suspended" json:"is_suspended"`
	SuspensionReason    sql.Null[string]                      `db:"suspension_reason" scan:"suspension_reason" json:"suspension_reason"`
	SuspensionExpiresAt sql.Null[time.Time]                   `db:"suspension_expires_at" scan:"suspension_expires_at" json:"suspension_expires_at"`
	Roles               sql.Null[types.JSON[json.RawMessage]] `db:"roles" scan:"roles" json:"roles"`
	Capabilities        sql.Null[types.JSON[json.RawMessage]] `db:"capabilities" scan:"capabilities" json:"capabilities"`
	AdminUsername       sql.Null[string]                      `db:"admin_username" scan:"admin_username" json:"admin_username"`
	AdminPasswordHash   sql.Null[string]                      `db:"admin_password_hash" scan:"admin_password_hash" json:"admin_password_hash"`
	MfaEnabled          sql.Null[bool]                        `db:"mfa_enabled" scan:"mfa_enabled" json:"mfa_enabled"`
	MfaSecret           sql.Null[string]                      `db:"mfa_secret" scan:"mfa_secret" json:"mfa_secret"`
	ModeratedSubforums  sql.Null[types.JSON[json.RawMessage]] `db:"moderated_subforums" scan:"moderated_subforums" json:"moderated_subforums"`
	AdminScope          sql.Null[string]                      `db:"admin_scope" scan:"admin_scope" json:"admin_scope"`
	UpdatedAt           sql.Null[time.Time]                   `db:"updated_at" scan:"updated_at" json:"updated_at"`

	R userR `db:"-" scan:"rel" json:"rel"`
}

// UserSlice is an alias for a slice of pointers to User.
// This should almost always be used instead of []*User.
type UserSlice []*User

// Users contains methods to work with the users table
var Users = psql.NewTablex[*User, UserSlice, *UserSetter]("", "users")

// UsersQuery is a query on the users table
type UsersQuery = *psql.ViewQuery[*User, UserSlice]

// userR is where relationships are stored.
type userR struct {
	RemovedByUserComments          CommentSlice           `scan:"RemovedByUserComments" json:"RemovedByUserComments"`                   // comments.comments_removed_by_user_id_fkey
	AssignedUserComplianceReports  ComplianceReportSlice  `scan:"AssignedUserComplianceReports" json:"AssignedUserComplianceReports"`   // compliance_reports.compliance_reports_assigned_user_id_fkey
	CorrelationAudits              CorrelationAuditSlice  `scan:"CorrelationAudits" json:"CorrelationAudits"`                           // correlation_audit.correlation_audit_user_id_fkey
	IdentityMappings               IdentityMappingSlice   `scan:"IdentityMappings" json:"IdentityMappings"`                             // identity_mappings.identity_mappings_user_id_fkey
	KeyUsageAudits                 KeyUsageAuditSlice     `scan:"KeyUsageAudits" json:"KeyUsageAudits"`                                 // key_usage_audit.key_usage_audit_user_id_fkey
	ModeratorUserModerationActions ModerationActionSlice  `scan:"ModeratorUserModerationActions" json:"ModeratorUserModerationActions"` // moderation_actions.moderation_actions_moderator_user_id_fkey
	TargetUserModerationActions    ModerationActionSlice  `scan:"TargetUserModerationActions" json:"TargetUserModerationActions"`       // moderation_actions.moderation_actions_target_user_id_fkey
	RemovedByUserPosts             PostSlice              `scan:"RemovedByUserPosts" json:"RemovedByUserPosts"`                         // posts.posts_removed_by_user_id_fkey
	Pseudonyms                     PseudonymSlice         `scan:"Pseudonyms" json:"Pseudonyms"`                                         // pseudonyms.pseudonyms_user_id_fkey
	ResolvedByUserReports          ReportSlice            `scan:"ResolvedByUserReports" json:"ResolvedByUserReports"`                   // reports.reports_resolved_by_user_id_fkey
	CreatedByRoleKeys              RoleKeySlice           `scan:"CreatedByRoleKeys" json:"CreatedByRoleKeys"`                           // role_keys.role_keys_created_by_fkey
	AddedByUserSubforumModerators  SubforumModeratorSlice `scan:"AddedByUserSubforumModerators" json:"AddedByUserSubforumModerators"`   // subforum_moderators.subforum_moderators_added_by_user_id_fkey
	SubforumModerators             SubforumModeratorSlice `scan:"SubforumModerators" json:"SubforumModerators"`                         // subforum_moderators.subforum_moderators_user_id_fkey
	CreatedByUserSubforums         SubforumSlice          `scan:"CreatedByUserSubforums" json:"CreatedByUserSubforums"`                 // subforums.subforums_created_by_user_id_fkey
	UpdatedBySystemSettings        SystemSettingSlice     `scan:"UpdatedBySystemSettings" json:"UpdatedBySystemSettings"`               // system_settings.system_settings_updated_by_fkey
	BannedByUserUserBans           UserBanSlice           `scan:"BannedByUserUserBans" json:"BannedByUserUserBans"`                     // user_bans.user_bans_banned_by_user_id_fkey
	BannedUserUserBans             UserBanSlice           `scan:"BannedUserUserBans" json:"BannedUserUserBans"`                         // user_bans.user_bans_banned_user_id_fkey
	BlockedUserUserBlocks          UserBlockSlice         `scan:"BlockedUserUserBlocks" json:"BlockedUserUserBlocks"`                   // user_blocks.user_blocks_blocked_user_id_fkey
	UserPreference                 *UserPreference        `scan:"UserPreference" json:"UserPreference"`                                 // user_preferences.user_preferences_user_id_fkey
}

type userColumnNames struct {
	UserID              string
	Email               string
	PasswordHash        string
	CreatedAt           string
	LastActiveAt        string
	IsActive            string
	IsSuspended         string
	SuspensionReason    string
	SuspensionExpiresAt string
	Roles               string
	Capabilities        string
	AdminUsername       string
	AdminPasswordHash   string
	MfaEnabled          string
	MfaSecret           string
	ModeratedSubforums  string
	AdminScope          string
	UpdatedAt           string
}

var UserColumns = buildUserColumns("users")

type userColumns struct {
	tableAlias          string
	UserID              psql.Expression
	Email               psql.Expression
	PasswordHash        psql.Expression
	CreatedAt           psql.Expression
	LastActiveAt        psql.Expression
	IsActive            psql.Expression
	IsSuspended         psql.Expression
	SuspensionReason    psql.Expression
	SuspensionExpiresAt psql.Expression
	Roles               psql.Expression
	Capabilities        psql.Expression
	AdminUsername       psql.Expression
	AdminPasswordHash   psql.Expression
	MfaEnabled          psql.Expression
	MfaSecret           psql.Expression
	ModeratedSubforums  psql.Expression
	AdminScope          psql.Expression
	UpdatedAt           psql.Expression
}

func (c userColumns) Alias() string {
	return c.tableAlias
}

func (userColumns) AliasedAs(alias string) userColumns {
	return buildUserColumns(alias)
}

func buildUserColumns(alias string) userColumns {
	return userColumns{
		tableAlias:          alias,
		UserID:              psql.Quote(alias, "user_id"),
		Email:               psql.Quote(alias, "email"),
		PasswordHash:        psql.Quote(alias, "password_hash"),
		CreatedAt:           psql.Quote(alias, "created_at"),
		LastActiveAt:        psql.Quote(alias, "last_active_at"),
		IsActive:            psql.Quote(alias, "is_active"),
		IsSuspended:         psql.Quote(alias, "is_suspended"),
		SuspensionReason:    psql.Quote(alias, "suspension_reason"),
		SuspensionExpiresAt: psql.Quote(alias, "suspension_expires_at"),
		Roles:               psql.Quote(alias, "roles"),
		Capabilities:        psql.Quote(alias, "capabilities"),
		AdminUsername:       psql.Quote(alias, "admin_username"),
		AdminPasswordHash:   psql.Quote(alias, "admin_password_hash"),
		MfaEnabled:          psql.Quote(alias, "mfa_enabled"),
		MfaSecret:           psql.Quote(alias, "mfa_secret"),
		ModeratedSubforums:  psql.Quote(alias, "moderated_subforums"),
		AdminScope:          psql.Quote(alias, "admin_scope"),
		UpdatedAt:           psql.Quote(alias, "updated_at"),
	}
}

type userWhere[Q psql.Filterable] struct {
	UserID              psql.WhereMod[Q, int64]
	Email               psql.WhereMod[Q, string]
	PasswordHash        psql.WhereMod[Q, string]
	CreatedAt           psql.WhereNullMod[Q, time.Time]
	LastActiveAt        psql.WhereNullMod[Q, time.Time]
	IsActive            psql.WhereNullMod[Q, bool]
	IsSuspended         psql.WhereNullMod[Q, bool]
	SuspensionReason    psql.WhereNullMod[Q, string]
	SuspensionExpiresAt psql.WhereNullMod[Q, time.Time]
	Roles               psql.WhereNullMod[Q, types.JSON[json.RawMessage]]
	Capabilities        psql.WhereNullMod[Q, types.JSON[json.RawMessage]]
	AdminUsername       psql.WhereNullMod[Q, string]
	AdminPasswordHash   psql.WhereNullMod[Q, string]
	MfaEnabled          psql.WhereNullMod[Q, bool]
	MfaSecret           psql.WhereNullMod[Q, string]
	ModeratedSubforums  psql.WhereNullMod[Q, types.JSON[json.RawMessage]]
	AdminScope          psql.WhereNullMod[Q, string]
	UpdatedAt           psql.WhereNullMod[Q, time.Time]
}

func (userWhere[Q]) AliasedAs(alias string) userWhere[Q] {
	return buildUserWhere[Q](buildUserColumns(alias))
}

func buildUserWhere[Q psql.Filterable](cols userColumns) userWhere[Q] {
	return userWhere[Q]{
		UserID:              psql.Where[Q, int64](cols.UserID),
		Email:               psql.Where[Q, string](cols.Email),
		PasswordHash:        psql.Where[Q, string](cols.PasswordHash),
		CreatedAt:           psql.WhereNull[Q, time.Time](cols.CreatedAt),
		LastActiveAt:        psql.WhereNull[Q, time.Time](cols.LastActiveAt),
		IsActive:            psql.WhereNull[Q, bool](cols.IsActive),
		IsSuspended:         psql.WhereNull[Q, bool](cols.IsSuspended),
		SuspensionReason:    psql.WhereNull[Q, string](cols.SuspensionReason),
		SuspensionExpiresAt: psql.WhereNull[Q, time.Time](cols.SuspensionExpiresAt),
		Roles:               psql.WhereNull[Q, types.JSON[json.RawMessage]](cols.Roles),
		Capabilities:        psql.WhereNull[Q, types.JSON[json.RawMessage]](cols.Capabilities),
		AdminUsername:       psql.WhereNull[Q, string](cols.AdminUsername),
		AdminPasswordHash:   psql.WhereNull[Q, string](cols.AdminPasswordHash),
		MfaEnabled:          psql.WhereNull[Q, bool](cols.MfaEnabled),
		MfaSecret:           psql.WhereNull[Q, string](cols.MfaSecret),
		ModeratedSubforums:  psql.WhereNull[Q, types.JSON[json.RawMessage]](cols.ModeratedSubforums),
		AdminScope:          psql.WhereNull[Q, string](cols.AdminScope),
		UpdatedAt:           psql.WhereNull[Q, time.Time](cols.UpdatedAt),
	}
}

var UserErrors = &userErrors{
	ErrUniqueUsersPkey: &UniqueConstraintError{
		schema:  "",
		table:   "users",
		columns: []string{"user_id"},
		s:       "users_pkey",
	},

	ErrUniqueUsersAdminUsernameKey: &UniqueConstraintError{
		schema:  "",
		table:   "users",
		columns: []string{"admin_username"},
		s:       "users_admin_username_key",
	},

	ErrUniqueUsersEmailKey: &UniqueConstraintError{
		schema:  "",
		table:   "users",
		columns: []string{"email"},
		s:       "users_email_key",
	},
}

type userErrors struct {
	ErrUniqueUsersPkey *UniqueConstraintError

	ErrUniqueUsersAdminUsernameKey *UniqueConstraintError

	ErrUniqueUsersEmailKey *UniqueConstraintError
}

// UserSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type UserSetter struct {
	UserID              *int64                                 `db:"user_id,pk" scan:"user_id" json:"user_id"`
	Email               *string                                `db:"email" scan:"email" json:"email"`
	PasswordHash        *string                                `db:"password_hash" scan:"password_hash" json:"password_hash"`
	CreatedAt           *sql.Null[time.Time]                   `db:"created_at" scan:"created_at" json:"created_at"`
	LastActiveAt        *sql.Null[time.Time]                   `db:"last_active_at" scan:"last_active_at" json:"last_active_at"`
	IsActive            *sql.Null[bool]                        `db:"is_active" scan:"is_active" json:"is_active"`
	IsSuspended         *sql.Null[bool]                        `db:"is_suspended" scan:"is_suspended" json:"is_suspended"`
	SuspensionReason    *sql.Null[string]                      `db:"suspension_reason" scan:"suspension_reason" json:"suspension_reason"`
	SuspensionExpiresAt *sql.Null[time.Time]                   `db:"suspension_expires_at" scan:"suspension_expires_at" json:"suspension_expires_at"`
	Roles               *sql.Null[types.JSON[json.RawMessage]] `db:"roles" scan:"roles" json:"roles"`
	Capabilities        *sql.Null[types.JSON[json.RawMessage]] `db:"capabilities" scan:"capabilities" json:"capabilities"`
	AdminUsername       *sql.Null[string]                      `db:"admin_username" scan:"admin_username" json:"admin_username"`
	AdminPasswordHash   *sql.Null[string]                      `db:"admin_password_hash" scan:"admin_password_hash" json:"admin_password_hash"`
	MfaEnabled          *sql.Null[bool]                        `db:"mfa_enabled" scan:"mfa_enabled" json:"mfa_enabled"`
	MfaSecret           *sql.Null[string]                      `db:"mfa_secret" scan:"mfa_secret" json:"mfa_secret"`
	ModeratedSubforums  *sql.Null[types.JSON[json.RawMessage]] `db:"moderated_subforums" scan:"moderated_subforums" json:"moderated_subforums"`
	AdminScope          *sql.Null[string]                      `db:"admin_scope" scan:"admin_scope" json:"admin_scope"`
	UpdatedAt           *sql.Null[time.Time]                   `db:"updated_at" scan:"updated_at" json:"updated_at"`
}

func (s UserSetter) SetColumns() []string {
	vals := make([]string, 0, 18)
	if s.UserID != nil {
		vals = append(vals, "user_id")
	}

	if s.Email != nil {
		vals = append(vals, "email")
	}

	if s.PasswordHash != nil {
		vals = append(vals, "password_hash")
	}

	if s.CreatedAt != nil {
		vals = append(vals, "created_at")
	}

	if s.LastActiveAt != nil {
		vals = append(vals, "last_active_at")
	}

	if s.IsActive != nil {
		vals = append(vals, "is_active")
	}

	if s.IsSuspended != nil {
		vals = append(vals, "is_suspended")
	}

	if s.SuspensionReason != nil {
		vals = append(vals, "suspension_reason")
	}

	if s.SuspensionExpiresAt != nil {
		vals = append(vals, "suspension_expires_at")
	}

	if s.Roles != nil {
		vals = append(vals, "roles")
	}

	if s.Capabilities != nil {
		vals = append(vals, "capabilities")
	}

	if s.AdminUsername != nil {
		vals = append(vals, "admin_username")
	}

	if s.AdminPasswordHash != nil {
		vals = append(vals, "admin_password_hash")
	}

	if s.MfaEnabled != nil {
		vals = append(vals, "mfa_enabled")
	}

	if s.MfaSecret != nil {
		vals = append(vals, "mfa_secret")
	}

	if s.ModeratedSubforums != nil {
		vals = append(vals, "moderated_subforums")
	}

	if s.AdminScope != nil {
		vals = append(vals, "admin_scope")
	}

	if s.UpdatedAt != nil {
		vals = append(vals, "updated_at")
	}

	return vals
}

func (s UserSetter) Overwrite(t *User) {
	if s.UserID != nil {
		t.UserID = *s.UserID
	}
	if s.Email != nil {
		t.Email = *s.Email
	}
	if s.PasswordHash != nil {
		t.PasswordHash = *s.PasswordHash
	}
	if s.CreatedAt != nil {
		t.CreatedAt = *s.CreatedAt
	}
	if s.LastActiveAt != nil {
		t.LastActiveAt = *s.LastActiveAt
	}
	if s.IsActive != nil {
		t.IsActive = *s.IsActive
	}
	if s.IsSuspended != nil {
		t.IsSuspended = *s.IsSuspended
	}
	if s.SuspensionReason != nil {
		t.SuspensionReason = *s.SuspensionReason
	}
	if s.SuspensionExpiresAt != nil {
		t.SuspensionExpiresAt = *s.SuspensionExpiresAt
	}
	if s.Roles != nil {
		t.Roles = *s.Roles
	}
	if s.Capabilities != nil {
		t.Capabilities = *s.Capabilities
	}
	if s.AdminUsername != nil {
		t.AdminUsername = *s.AdminUsername
	}
	if s.AdminPasswordHash != nil {
		t.AdminPasswordHash = *s.AdminPasswordHash
	}
	if s.MfaEnabled != nil {
		t.MfaEnabled = *s.MfaEnabled
	}
	if s.MfaSecret != nil {
		t.MfaSecret = *s.MfaSecret
	}
	if s.ModeratedSubforums != nil {
		t.ModeratedSubforums = *s.ModeratedSubforums
	}
	if s.AdminScope != nil {
		t.AdminScope = *s.AdminScope
	}
	if s.UpdatedAt != nil {
		t.UpdatedAt = *s.UpdatedAt
	}
}

func (s *UserSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Users.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 18)
		if s.UserID != nil {
			vals[0] = psql.Arg(*s.UserID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.Email != nil {
			vals[1] = psql.Arg(*s.Email)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.PasswordHash != nil {
			vals[2] = psql.Arg(*s.PasswordHash)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt != nil {
			vals[3] = psql.Arg(*s.CreatedAt)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.LastActiveAt != nil {
			vals[4] = psql.Arg(*s.LastActiveAt)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.IsActive != nil {
			vals[5] = psql.Arg(*s.IsActive)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.IsSuspended != nil {
			vals[6] = psql.Arg(*s.IsSuspended)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.SuspensionReason != nil {
			vals[7] = psql.Arg(*s.SuspensionReason)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.SuspensionExpiresAt != nil {
			vals[8] = psql.Arg(*s.SuspensionExpiresAt)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.Roles != nil {
			vals[9] = psql.Arg(*s.Roles)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.Capabilities != nil {
			vals[10] = psql.Arg(*s.Capabilities)
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.AdminUsername != nil {
			vals[11] = psql.Arg(*s.AdminUsername)
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.AdminPasswordHash != nil {
			vals[12] = psql.Arg(*s.AdminPasswordHash)
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.MfaEnabled != nil {
			vals[13] = psql.Arg(*s.MfaEnabled)
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.MfaSecret != nil {
			vals[14] = psql.Arg(*s.MfaSecret)
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.ModeratedSubforums != nil {
			vals[15] = psql.Arg(*s.ModeratedSubforums)
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if s.AdminScope != nil {
			vals[16] = psql.Arg(*s.AdminScope)
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if s.UpdatedAt != nil {
			vals[17] = psql.Arg(*s.UpdatedAt)
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s UserSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s UserSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 18)

	if s.UserID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "user_id")...),
			psql.Arg(s.UserID),
		}})
	}

	if s.Email != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "email")...),
			psql.Arg(s.Email),
		}})
	}

	if s.PasswordHash != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "password_hash")...),
			psql.Arg(s.PasswordHash),
		}})
	}

	if s.CreatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.LastActiveAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_active_at")...),
			psql.Arg(s.LastActiveAt),
		}})
	}

	if s.IsActive != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_active")...),
			psql.Arg(s.IsActive),
		}})
	}

	if s.IsSuspended != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_suspended")...),
			psql.Arg(s.IsSuspended),
		}})
	}

	if s.SuspensionReason != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "suspension_reason")...),
			psql.Arg(s.SuspensionReason),
		}})
	}

	if s.SuspensionExpiresAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "suspension_expires_at")...),
			psql.Arg(s.SuspensionExpiresAt),
		}})
	}

	if s.Roles != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "roles")...),
			psql.Arg(s.Roles),
		}})
	}

	if s.Capabilities != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "capabilities")...),
			psql.Arg(s.Capabilities),
		}})
	}

	if s.AdminUsername != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "admin_username")...),
			psql.Arg(s.AdminUsername),
		}})
	}

	if s.AdminPasswordHash != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "admin_password_hash")...),
			psql.Arg(s.AdminPasswordHash),
		}})
	}

	if s.MfaEnabled != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "mfa_enabled")...),
			psql.Arg(s.MfaEnabled),
		}})
	}

	if s.MfaSecret != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "mfa_secret")...),
			psql.Arg(s.MfaSecret),
		}})
	}

	if s.ModeratedSubforums != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "moderated_subforums")...),
			psql.Arg(s.ModeratedSubforums),
		}})
	}

	if s.AdminScope != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "admin_scope")...),
			psql.Arg(s.AdminScope),
		}})
	}

	if s.UpdatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated_at")...),
			psql.Arg(s.UpdatedAt),
		}})
	}

	return exprs
}

// FindUser retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindUser(ctx context.Context, exec bob.Executor, UserIDPK int64, cols ...string) (*User, error) {
	if len(cols) == 0 {
		return Users.Query(
			SelectWhere.Users.UserID.EQ(UserIDPK),
		).One(ctx, exec)
	}

	return Users.Query(
		SelectWhere.Users.UserID.EQ(UserIDPK),
		sm.Columns(Users.Columns().Only(cols...)),
	).One(ctx, exec)
}

// UserExists checks the presence of a single record by primary key
func UserExists(ctx context.Context, exec bob.Executor, UserIDPK int64) (bool, error) {
	return Users.Query(
		SelectWhere.Users.UserID.EQ(UserIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after User is retrieved from the database
func (o *User) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Users.AfterSelectHooks.RunHooks(ctx, exec, UserSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Users.AfterInsertHooks.RunHooks(ctx, exec, UserSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Users.AfterUpdateHooks.RunHooks(ctx, exec, UserSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Users.AfterDeleteHooks.RunHooks(ctx, exec, UserSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the User
func (o *User) primaryKeyVals() bob.Expression {
	return psql.Arg(o.UserID)
}

func (o *User) pkEQ() dialect.Expression {
	return psql.Quote("users", "user_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the User
func (o *User) Update(ctx context.Context, exec bob.Executor, s *UserSetter) error {
	v, err := Users.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single User record with an executor
func (o *User) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Users.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the User using the executor
func (o *User) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Users.Query(
		SelectWhere.Users.UserID.EQ(o.UserID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after UserSlice is retrieved from the database
func (o UserSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Users.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Users.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Users.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Users.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o UserSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("users", "user_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o UserSlice) copyMatchingRows(from ...*User) {
	for i, old := range o {
		for _, new := range from {
			if new.UserID != old.UserID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o UserSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Users.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *User:
				o.copyMatchingRows(retrieved)
			case []*User:
				o.copyMatchingRows(retrieved...)
			case UserSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a User or a slice of User
				// then run the AfterUpdateHooks on the slice
				_, err = Users.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o UserSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Users.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *User:
				o.copyMatchingRows(retrieved)
			case []*User:
				o.copyMatchingRows(retrieved...)
			case UserSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a User or a slice of User
				// then run the AfterDeleteHooks on the slice
				_, err = Users.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o UserSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals UserSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Users.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o UserSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Users.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o UserSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Users.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type userJoins[Q dialect.Joinable] struct {
	typ                            string
	RemovedByUserComments          modAs[Q, commentColumns]
	AssignedUserComplianceReports  modAs[Q, complianceReportColumns]
	CorrelationAudits              modAs[Q, correlationAuditColumns]
	IdentityMappings               modAs[Q, identityMappingColumns]
	KeyUsageAudits                 modAs[Q, keyUsageAuditColumns]
	ModeratorUserModerationActions modAs[Q, moderationActionColumns]
	TargetUserModerationActions    modAs[Q, moderationActionColumns]
	RemovedByUserPosts             modAs[Q, postColumns]
	Pseudonyms                     modAs[Q, pseudonymColumns]
	ResolvedByUserReports          modAs[Q, reportColumns]
	CreatedByRoleKeys              modAs[Q, roleKeyColumns]
	AddedByUserSubforumModerators  modAs[Q, subforumModeratorColumns]
	SubforumModerators             modAs[Q, subforumModeratorColumns]
	CreatedByUserSubforums         modAs[Q, subforumColumns]
	UpdatedBySystemSettings        modAs[Q, systemSettingColumns]
	BannedByUserUserBans           modAs[Q, userBanColumns]
	BannedUserUserBans             modAs[Q, userBanColumns]
	BlockedUserUserBlocks          modAs[Q, userBlockColumns]
	UserPreference                 modAs[Q, userPreferenceColumns]
}

func (j userJoins[Q]) aliasedAs(alias string) userJoins[Q] {
	return buildUserJoins[Q](buildUserColumns(alias), j.typ)
}

func buildUserJoins[Q dialect.Joinable](cols userColumns, typ string) userJoins[Q] {
	return userJoins[Q]{
		typ: typ,
		RemovedByUserComments: modAs[Q, commentColumns]{
			c: CommentColumns,
			f: func(to commentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Comments.Name().As(to.Alias())).On(
						to.RemovedByUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		AssignedUserComplianceReports: modAs[Q, complianceReportColumns]{
			c: ComplianceReportColumns,
			f: func(to complianceReportColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ComplianceReports.Name().As(to.Alias())).On(
						to.AssignedUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		CorrelationAudits: modAs[Q, correlationAuditColumns]{
			c: CorrelationAuditColumns,
			f: func(to correlationAuditColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CorrelationAudits.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		IdentityMappings: modAs[Q, identityMappingColumns]{
			c: IdentityMappingColumns,
			f: func(to identityMappingColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, IdentityMappings.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		KeyUsageAudits: modAs[Q, keyUsageAuditColumns]{
			c: KeyUsageAuditColumns,
			f: func(to keyUsageAuditColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, KeyUsageAudits.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		ModeratorUserModerationActions: modAs[Q, moderationActionColumns]{
			c: ModerationActionColumns,
			f: func(to moderationActionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ModerationActions.Name().As(to.Alias())).On(
						to.ModeratorUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		TargetUserModerationActions: modAs[Q, moderationActionColumns]{
			c: ModerationActionColumns,
			f: func(to moderationActionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ModerationActions.Name().As(to.Alias())).On(
						to.TargetUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		RemovedByUserPosts: modAs[Q, postColumns]{
			c: PostColumns,
			f: func(to postColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Posts.Name().As(to.Alias())).On(
						to.RemovedByUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		Pseudonyms: modAs[Q, pseudonymColumns]{
			c: PseudonymColumns,
			f: func(to pseudonymColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pseudonyms.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		ResolvedByUserReports: modAs[Q, reportColumns]{
			c: ReportColumns,
			f: func(to reportColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Reports.Name().As(to.Alias())).On(
						to.ResolvedByUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		CreatedByRoleKeys: modAs[Q, roleKeyColumns]{
			c: RoleKeyColumns,
			f: func(to roleKeyColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, RoleKeys.Name().As(to.Alias())).On(
						to.CreatedBy.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		AddedByUserSubforumModerators: modAs[Q, subforumModeratorColumns]{
			c: SubforumModeratorColumns,
			f: func(to subforumModeratorColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, SubforumModerators.Name().As(to.Alias())).On(
						to.AddedByUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		SubforumModerators: modAs[Q, subforumModeratorColumns]{
			c: SubforumModeratorColumns,
			f: func(to subforumModeratorColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, SubforumModerators.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		CreatedByUserSubforums: modAs[Q, subforumColumns]{
			c: SubforumColumns,
			f: func(to subforumColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Subforums.Name().As(to.Alias())).On(
						to.CreatedByUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		UpdatedBySystemSettings: modAs[Q, systemSettingColumns]{
			c: SystemSettingColumns,
			f: func(to systemSettingColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, SystemSettings.Name().As(to.Alias())).On(
						to.UpdatedBy.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		BannedByUserUserBans: modAs[Q, userBanColumns]{
			c: UserBanColumns,
			f: func(to userBanColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserBans.Name().As(to.Alias())).On(
						to.BannedByUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		BannedUserUserBans: modAs[Q, userBanColumns]{
			c: UserBanColumns,
			f: func(to userBanColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserBans.Name().As(to.Alias())).On(
						to.BannedUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		BlockedUserUserBlocks: modAs[Q, userBlockColumns]{
			c: UserBlockColumns,
			f: func(to userBlockColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserBlocks.Name().As(to.Alias())).On(
						to.BlockedUserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
		UserPreference: modAs[Q, userPreferenceColumns]{
			c: UserPreferenceColumns,
			f: func(to userPreferenceColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserPreferences.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
	}
}

// RemovedByUserComments starts a query for related objects on comments
func (o *User) RemovedByUserComments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	return Comments.Query(append(mods,
		sm.Where(CommentColumns.RemovedByUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) RemovedByUserComments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return Comments.Query(append(mods,
		sm.Where(psql.Group(CommentColumns.RemovedByUserID).OP("IN", PKArgExpr)),
	)...)
}

// AssignedUserComplianceReports starts a query for related objects on compliance_reports
func (o *User) AssignedUserComplianceReports(mods ...bob.Mod[*dialect.SelectQuery]) ComplianceReportsQuery {
	return ComplianceReports.Query(append(mods,
		sm.Where(ComplianceReportColumns.AssignedUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) AssignedUserComplianceReports(mods ...bob.Mod[*dialect.SelectQuery]) ComplianceReportsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return ComplianceReports.Query(append(mods,
		sm.Where(psql.Group(ComplianceReportColumns.AssignedUserID).OP("IN", PKArgExpr)),
	)...)
}

// CorrelationAudits starts a query for related objects on correlation_audit
func (o *User) CorrelationAudits(mods ...bob.Mod[*dialect.SelectQuery]) CorrelationAuditsQuery {
	return CorrelationAudits.Query(append(mods,
		sm.Where(CorrelationAuditColumns.UserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) CorrelationAudits(mods ...bob.Mod[*dialect.SelectQuery]) CorrelationAuditsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return CorrelationAudits.Query(append(mods,
		sm.Where(psql.Group(CorrelationAuditColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// IdentityMappings starts a query for related objects on identity_mappings
func (o *User) IdentityMappings(mods ...bob.Mod[*dialect.SelectQuery]) IdentityMappingsQuery {
	return IdentityMappings.Query(append(mods,
		sm.Where(IdentityMappingColumns.UserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) IdentityMappings(mods ...bob.Mod[*dialect.SelectQuery]) IdentityMappingsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return IdentityMappings.Query(append(mods,
		sm.Where(psql.Group(IdentityMappingColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// KeyUsageAudits starts a query for related objects on key_usage_audit
func (o *User) KeyUsageAudits(mods ...bob.Mod[*dialect.SelectQuery]) KeyUsageAuditsQuery {
	return KeyUsageAudits.Query(append(mods,
		sm.Where(KeyUsageAuditColumns.UserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) KeyUsageAudits(mods ...bob.Mod[*dialect.SelectQuery]) KeyUsageAuditsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return KeyUsageAudits.Query(append(mods,
		sm.Where(psql.Group(KeyUsageAuditColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// ModeratorUserModerationActions starts a query for related objects on moderation_actions
func (o *User) ModeratorUserModerationActions(mods ...bob.Mod[*dialect.SelectQuery]) ModerationActionsQuery {
	return ModerationActions.Query(append(mods,
		sm.Where(ModerationActionColumns.ModeratorUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) ModeratorUserModerationActions(mods ...bob.Mod[*dialect.SelectQuery]) ModerationActionsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return ModerationActions.Query(append(mods,
		sm.Where(psql.Group(ModerationActionColumns.ModeratorUserID).OP("IN", PKArgExpr)),
	)...)
}

// TargetUserModerationActions starts a query for related objects on moderation_actions
func (o *User) TargetUserModerationActions(mods ...bob.Mod[*dialect.SelectQuery]) ModerationActionsQuery {
	return ModerationActions.Query(append(mods,
		sm.Where(ModerationActionColumns.TargetUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) TargetUserModerationActions(mods ...bob.Mod[*dialect.SelectQuery]) ModerationActionsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return ModerationActions.Query(append(mods,
		sm.Where(psql.Group(ModerationActionColumns.TargetUserID).OP("IN", PKArgExpr)),
	)...)
}

// RemovedByUserPosts starts a query for related objects on posts
func (o *User) RemovedByUserPosts(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	return Posts.Query(append(mods,
		sm.Where(PostColumns.RemovedByUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) RemovedByUserPosts(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return Posts.Query(append(mods,
		sm.Where(psql.Group(PostColumns.RemovedByUserID).OP("IN", PKArgExpr)),
	)...)
}

// Pseudonyms starts a query for related objects on pseudonyms
func (o *User) Pseudonyms(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	return Pseudonyms.Query(append(mods,
		sm.Where(PseudonymColumns.UserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) Pseudonyms(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return Pseudonyms.Query(append(mods,
		sm.Where(psql.Group(PseudonymColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// ResolvedByUserReports starts a query for related objects on reports
func (o *User) ResolvedByUserReports(mods ...bob.Mod[*dialect.SelectQuery]) ReportsQuery {
	return Reports.Query(append(mods,
		sm.Where(ReportColumns.ResolvedByUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) ResolvedByUserReports(mods ...bob.Mod[*dialect.SelectQuery]) ReportsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return Reports.Query(append(mods,
		sm.Where(psql.Group(ReportColumns.ResolvedByUserID).OP("IN", PKArgExpr)),
	)...)
}

// CreatedByRoleKeys starts a query for related objects on role_keys
func (o *User) CreatedByRoleKeys(mods ...bob.Mod[*dialect.SelectQuery]) RoleKeysQuery {
	return RoleKeys.Query(append(mods,
		sm.Where(RoleKeyColumns.CreatedBy.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) CreatedByRoleKeys(mods ...bob.Mod[*dialect.SelectQuery]) RoleKeysQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return RoleKeys.Query(append(mods,
		sm.Where(psql.Group(RoleKeyColumns.CreatedBy).OP("IN", PKArgExpr)),
	)...)
}

// AddedByUserSubforumModerators starts a query for related objects on subforum_moderators
func (o *User) AddedByUserSubforumModerators(mods ...bob.Mod[*dialect.SelectQuery]) SubforumModeratorsQuery {
	return SubforumModerators.Query(append(mods,
		sm.Where(SubforumModeratorColumns.AddedByUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) AddedByUserSubforumModerators(mods ...bob.Mod[*dialect.SelectQuery]) SubforumModeratorsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return SubforumModerators.Query(append(mods,
		sm.Where(psql.Group(SubforumModeratorColumns.AddedByUserID).OP("IN", PKArgExpr)),
	)...)
}

// SubforumModerators starts a query for related objects on subforum_moderators
func (o *User) SubforumModerators(mods ...bob.Mod[*dialect.SelectQuery]) SubforumModeratorsQuery {
	return SubforumModerators.Query(append(mods,
		sm.Where(SubforumModeratorColumns.UserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) SubforumModerators(mods ...bob.Mod[*dialect.SelectQuery]) SubforumModeratorsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return SubforumModerators.Query(append(mods,
		sm.Where(psql.Group(SubforumModeratorColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// CreatedByUserSubforums starts a query for related objects on subforums
func (o *User) CreatedByUserSubforums(mods ...bob.Mod[*dialect.SelectQuery]) SubforumsQuery {
	return Subforums.Query(append(mods,
		sm.Where(SubforumColumns.CreatedByUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) CreatedByUserSubforums(mods ...bob.Mod[*dialect.SelectQuery]) SubforumsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return Subforums.Query(append(mods,
		sm.Where(psql.Group(SubforumColumns.CreatedByUserID).OP("IN", PKArgExpr)),
	)...)
}

// UpdatedBySystemSettings starts a query for related objects on system_settings
func (o *User) UpdatedBySystemSettings(mods ...bob.Mod[*dialect.SelectQuery]) SystemSettingsQuery {
	return SystemSettings.Query(append(mods,
		sm.Where(SystemSettingColumns.UpdatedBy.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) UpdatedBySystemSettings(mods ...bob.Mod[*dialect.SelectQuery]) SystemSettingsQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return SystemSettings.Query(append(mods,
		sm.Where(psql.Group(SystemSettingColumns.UpdatedBy).OP("IN", PKArgExpr)),
	)...)
}

// BannedByUserUserBans starts a query for related objects on user_bans
func (o *User) BannedByUserUserBans(mods ...bob.Mod[*dialect.SelectQuery]) UserBansQuery {
	return UserBans.Query(append(mods,
		sm.Where(UserBanColumns.BannedByUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) BannedByUserUserBans(mods ...bob.Mod[*dialect.SelectQuery]) UserBansQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return UserBans.Query(append(mods,
		sm.Where(psql.Group(UserBanColumns.BannedByUserID).OP("IN", PKArgExpr)),
	)...)
}

// BannedUserUserBans starts a query for related objects on user_bans
func (o *User) BannedUserUserBans(mods ...bob.Mod[*dialect.SelectQuery]) UserBansQuery {
	return UserBans.Query(append(mods,
		sm.Where(UserBanColumns.BannedUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) BannedUserUserBans(mods ...bob.Mod[*dialect.SelectQuery]) UserBansQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return UserBans.Query(append(mods,
		sm.Where(psql.Group(UserBanColumns.BannedUserID).OP("IN", PKArgExpr)),
	)...)
}

// BlockedUserUserBlocks starts a query for related objects on user_blocks
func (o *User) BlockedUserUserBlocks(mods ...bob.Mod[*dialect.SelectQuery]) UserBlocksQuery {
	return UserBlocks.Query(append(mods,
		sm.Where(UserBlockColumns.BlockedUserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) BlockedUserUserBlocks(mods ...bob.Mod[*dialect.SelectQuery]) UserBlocksQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return UserBlocks.Query(append(mods,
		sm.Where(psql.Group(UserBlockColumns.BlockedUserID).OP("IN", PKArgExpr)),
	)...)
}

// UserPreference starts a query for related objects on user_preferences
func (o *User) UserPreference(mods ...bob.Mod[*dialect.SelectQuery]) UserPreferencesQuery {
	return UserPreferences.Query(append(mods,
		sm.Where(UserPreferenceColumns.UserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os UserSlice) UserPreference(mods ...bob.Mod[*dialect.SelectQuery]) UserPreferencesQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return UserPreferences.Query(append(mods,
		sm.Where(psql.Group(UserPreferenceColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

func (o *User) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "RemovedByUserComments":
		rels, ok := retrieved.(CommentSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.RemovedByUserComments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.RemovedByUserUser = o
			}
		}
		return nil
	case "AssignedUserComplianceReports":
		rels, ok := retrieved.(ComplianceReportSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.AssignedUserComplianceReports = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.AssignedUserUser = o
			}
		}
		return nil
	case "CorrelationAudits":
		rels, ok := retrieved.(CorrelationAuditSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CorrelationAudits = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "IdentityMappings":
		rels, ok := retrieved.(IdentityMappingSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.IdentityMappings = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "KeyUsageAudits":
		rels, ok := retrieved.(KeyUsageAuditSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.KeyUsageAudits = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "ModeratorUserModerationActions":
		rels, ok := retrieved.(ModerationActionSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.ModeratorUserModerationActions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ModeratorUserUser = o
			}
		}
		return nil
	case "TargetUserModerationActions":
		rels, ok := retrieved.(ModerationActionSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.TargetUserModerationActions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.TargetUserUser = o
			}
		}
		return nil
	case "RemovedByUserPosts":
		rels, ok := retrieved.(PostSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.RemovedByUserPosts = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.RemovedByUserUser = o
			}
		}
		return nil
	case "Pseudonyms":
		rels, ok := retrieved.(PseudonymSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.Pseudonyms = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "ResolvedByUserReports":
		rels, ok := retrieved.(ReportSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.ResolvedByUserReports = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ResolvedByUserUser = o
			}
		}
		return nil
	case "CreatedByRoleKeys":
		rels, ok := retrieved.(RoleKeySlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CreatedByRoleKeys = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.CreatedByUser = o
			}
		}
		return nil
	case "AddedByUserSubforumModerators":
		rels, ok := retrieved.(SubforumModeratorSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.AddedByUserSubforumModerators = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.AddedByUserUser = o
			}
		}
		return nil
	case "SubforumModerators":
		rels, ok := retrieved.(SubforumModeratorSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.SubforumModerators = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "CreatedByUserSubforums":
		rels, ok := retrieved.(SubforumSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CreatedByUserSubforums = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.CreatedByUserUser = o
			}
		}
		return nil
	case "UpdatedBySystemSettings":
		rels, ok := retrieved.(SystemSettingSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.UpdatedBySystemSettings = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.UpdatedByUser = o
			}
		}
		return nil
	case "BannedByUserUserBans":
		rels, ok := retrieved.(UserBanSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.BannedByUserUserBans = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.BannedByUserUser = o
			}
		}
		return nil
	case "BannedUserUserBans":
		rels, ok := retrieved.(UserBanSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.BannedUserUserBans = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.BannedUserUser = o
			}
		}
		return nil
	case "BlockedUserUserBlocks":
		rels, ok := retrieved.(UserBlockSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.BlockedUserUserBlocks = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.BlockedUserUser = o
			}
		}
		return nil
	case "UserPreference":
		rel, ok := retrieved.(*UserPreference)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.UserPreference = rel

		if rel != nil {
			rel.R.User = o
		}
		return nil
	default:
		return fmt.Errorf("user has no relationship %q", name)
	}
}

type userPreloader struct {
	UserPreference func(...psql.PreloadOption) psql.Preloader
}

func buildUserPreloader() userPreloader {
	return userPreloader{
		UserPreference: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*UserPreference, UserPreferenceSlice](orm.Relationship{
				Name: "UserPreference",
				Sides: []orm.RelSide{
					{
						From: TableNames.Users,
						To:   TableNames.UserPreferences,
						FromColumns: []string{
							ColumnNames.Users.UserID,
						},
						ToColumns: []string{
							ColumnNames.UserPreferences.UserID,
						},
					},
				},
			}, UserPreferences.Columns().Names(), opts...)
		},
	}
}

type userThenLoader[Q orm.Loadable] struct {
	RemovedByUserComments          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	AssignedUserComplianceReports  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CorrelationAudits              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	IdentityMappings               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	KeyUsageAudits                 func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ModeratorUserModerationActions func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	TargetUserModerationActions    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RemovedByUserPosts             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pseudonyms                     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ResolvedByUserReports          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CreatedByRoleKeys              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	AddedByUserSubforumModerators  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	SubforumModerators             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CreatedByUserSubforums         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	UpdatedBySystemSettings        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	BannedByUserUserBans           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	BannedUserUserBans             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	BlockedUserUserBlocks          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	UserPreference                 func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildUserThenLoader[Q orm.Loadable]() userThenLoader[Q] {
	type RemovedByUserCommentsLoadInterface interface {
		LoadRemovedByUserComments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type AssignedUserComplianceReportsLoadInterface interface {
		LoadAssignedUserComplianceReports(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CorrelationAuditsLoadInterface interface {
		LoadCorrelationAudits(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type IdentityMappingsLoadInterface interface {
		LoadIdentityMappings(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type KeyUsageAuditsLoadInterface interface {
		LoadKeyUsageAudits(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ModeratorUserModerationActionsLoadInterface interface {
		LoadModeratorUserModerationActions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TargetUserModerationActionsLoadInterface interface {
		LoadTargetUserModerationActions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RemovedByUserPostsLoadInterface interface {
		LoadRemovedByUserPosts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PseudonymsLoadInterface interface {
		LoadPseudonyms(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ResolvedByUserReportsLoadInterface interface {
		LoadResolvedByUserReports(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CreatedByRoleKeysLoadInterface interface {
		LoadCreatedByRoleKeys(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type AddedByUserSubforumModeratorsLoadInterface interface {
		LoadAddedByUserSubforumModerators(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SubforumModeratorsLoadInterface interface {
		LoadSubforumModerators(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CreatedByUserSubforumsLoadInterface interface {
		LoadCreatedByUserSubforums(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UpdatedBySystemSettingsLoadInterface interface {
		LoadUpdatedBySystemSettings(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type BannedByUserUserBansLoadInterface interface {
		LoadBannedByUserUserBans(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type BannedUserUserBansLoadInterface interface {
		LoadBannedUserUserBans(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type BlockedUserUserBlocksLoadInterface interface {
		LoadBlockedUserUserBlocks(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserPreferenceLoadInterface interface {
		LoadUserPreference(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return userThenLoader[Q]{
		RemovedByUserComments: thenLoadBuilder[Q](
			"RemovedByUserComments",
			func(ctx context.Context, exec bob.Executor, retrieved RemovedByUserCommentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRemovedByUserComments(ctx, exec, mods...)
			},
		),
		AssignedUserComplianceReports: thenLoadBuilder[Q](
			"AssignedUserComplianceReports",
			func(ctx context.Context, exec bob.Executor, retrieved AssignedUserComplianceReportsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadAssignedUserComplianceReports(ctx, exec, mods...)
			},
		),
		CorrelationAudits: thenLoadBuilder[Q](
			"CorrelationAudits",
			func(ctx context.Context, exec bob.Executor, retrieved CorrelationAuditsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCorrelationAudits(ctx, exec, mods...)
			},
		),
		IdentityMappings: thenLoadBuilder[Q](
			"IdentityMappings",
			func(ctx context.Context, exec bob.Executor, retrieved IdentityMappingsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadIdentityMappings(ctx, exec, mods...)
			},
		),
		KeyUsageAudits: thenLoadBuilder[Q](
			"KeyUsageAudits",
			func(ctx context.Context, exec bob.Executor, retrieved KeyUsageAuditsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadKeyUsageAudits(ctx, exec, mods...)
			},
		),
		ModeratorUserModerationActions: thenLoadBuilder[Q](
			"ModeratorUserModerationActions",
			func(ctx context.Context, exec bob.Executor, retrieved ModeratorUserModerationActionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadModeratorUserModerationActions(ctx, exec, mods...)
			},
		),
		TargetUserModerationActions: thenLoadBuilder[Q](
			"TargetUserModerationActions",
			func(ctx context.Context, exec bob.Executor, retrieved TargetUserModerationActionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadTargetUserModerationActions(ctx, exec, mods...)
			},
		),
		RemovedByUserPosts: thenLoadBuilder[Q](
			"RemovedByUserPosts",
			func(ctx context.Context, exec bob.Executor, retrieved RemovedByUserPostsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRemovedByUserPosts(ctx, exec, mods...)
			},
		),
		Pseudonyms: thenLoadBuilder[Q](
			"Pseudonyms",
			func(ctx context.Context, exec bob.Executor, retrieved PseudonymsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPseudonyms(ctx, exec, mods...)
			},
		),
		ResolvedByUserReports: thenLoadBuilder[Q](
			"ResolvedByUserReports",
			func(ctx context.Context, exec bob.Executor, retrieved ResolvedByUserReportsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadResolvedByUserReports(ctx, exec, mods...)
			},
		),
		CreatedByRoleKeys: thenLoadBuilder[Q](
			"CreatedByRoleKeys",
			func(ctx context.Context, exec bob.Executor, retrieved CreatedByRoleKeysLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCreatedByRoleKeys(ctx, exec, mods...)
			},
		),
		AddedByUserSubforumModerators: thenLoadBuilder[Q](
			"AddedByUserSubforumModerators",
			func(ctx context.Context, exec bob.Executor, retrieved AddedByUserSubforumModeratorsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadAddedByUserSubforumModerators(ctx, exec, mods...)
			},
		),
		SubforumModerators: thenLoadBuilder[Q](
			"SubforumModerators",
			func(ctx context.Context, exec bob.Executor, retrieved SubforumModeratorsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSubforumModerators(ctx, exec, mods...)
			},
		),
		CreatedByUserSubforums: thenLoadBuilder[Q](
			"CreatedByUserSubforums",
			func(ctx context.Context, exec bob.Executor, retrieved CreatedByUserSubforumsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCreatedByUserSubforums(ctx, exec, mods...)
			},
		),
		UpdatedBySystemSettings: thenLoadBuilder[Q](
			"UpdatedBySystemSettings",
			func(ctx context.Context, exec bob.Executor, retrieved UpdatedBySystemSettingsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUpdatedBySystemSettings(ctx, exec, mods...)
			},
		),
		BannedByUserUserBans: thenLoadBuilder[Q](
			"BannedByUserUserBans",
			func(ctx context.Context, exec bob.Executor, retrieved BannedByUserUserBansLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadBannedByUserUserBans(ctx, exec, mods...)
			},
		),
		BannedUserUserBans: thenLoadBuilder[Q](
			"BannedUserUserBans",
			func(ctx context.Context, exec bob.Executor, retrieved BannedUserUserBansLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadBannedUserUserBans(ctx, exec, mods...)
			},
		),
		BlockedUserUserBlocks: thenLoadBuilder[Q](
			"BlockedUserUserBlocks",
			func(ctx context.Context, exec bob.Executor, retrieved BlockedUserUserBlocksLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadBlockedUserUserBlocks(ctx, exec, mods...)
			},
		),
		UserPreference: thenLoadBuilder[Q](
			"UserPreference",
			func(ctx context.Context, exec bob.Executor, retrieved UserPreferenceLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUserPreference(ctx, exec, mods...)
			},
		),
	}
}

// LoadRemovedByUserComments loads the user's RemovedByUserComments into the .R struct
func (o *User) LoadRemovedByUserComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RemovedByUserComments = nil

	related, err := o.RemovedByUserComments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.RemovedByUserUser = o
	}

	o.R.RemovedByUserComments = related
	return nil
}

// LoadRemovedByUserComments loads the user's RemovedByUserComments into the .R struct
func (os UserSlice) LoadRemovedByUserComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	comments, err := os.RemovedByUserComments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.RemovedByUserComments = nil
	}

	for _, o := range os {
		for _, rel := range comments {
			if o.UserID != rel.RemovedByUserID.V {
				continue
			}

			rel.R.RemovedByUserUser = o

			o.R.RemovedByUserComments = append(o.R.RemovedByUserComments, rel)
		}
	}

	return nil
}

// LoadAssignedUserComplianceReports loads the user's AssignedUserComplianceReports into the .R struct
func (o *User) LoadAssignedUserComplianceReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.AssignedUserComplianceReports = nil

	related, err := o.AssignedUserComplianceReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.AssignedUserUser = o
	}

	o.R.AssignedUserComplianceReports = related
	return nil
}

// LoadAssignedUserComplianceReports loads the user's AssignedUserComplianceReports into the .R struct
func (os UserSlice) LoadAssignedUserComplianceReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	complianceReports, err := os.AssignedUserComplianceReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.AssignedUserComplianceReports = nil
	}

	for _, o := range os {
		for _, rel := range complianceReports {
			if o.UserID != rel.AssignedUserID.V {
				continue
			}

			rel.R.AssignedUserUser = o

			o.R.AssignedUserComplianceReports = append(o.R.AssignedUserComplianceReports, rel)
		}
	}

	return nil
}

// LoadCorrelationAudits loads the user's CorrelationAudits into the .R struct
func (o *User) LoadCorrelationAudits(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CorrelationAudits = nil

	related, err := o.CorrelationAudits(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.CorrelationAudits = related
	return nil
}

// LoadCorrelationAudits loads the user's CorrelationAudits into the .R struct
func (os UserSlice) LoadCorrelationAudits(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	correlationAudits, err := os.CorrelationAudits(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CorrelationAudits = nil
	}

	for _, o := range os {
		for _, rel := range correlationAudits {
			if o.UserID != rel.UserID {
				continue
			}

			rel.R.User = o

			o.R.CorrelationAudits = append(o.R.CorrelationAudits, rel)
		}
	}

	return nil
}

// LoadIdentityMappings loads the user's IdentityMappings into the .R struct
func (o *User) LoadIdentityMappings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.IdentityMappings = nil

	related, err := o.IdentityMappings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.IdentityMappings = related
	return nil
}

// LoadIdentityMappings loads the user's IdentityMappings into the .R struct
func (os UserSlice) LoadIdentityMappings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	identityMappings, err := os.IdentityMappings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.IdentityMappings = nil
	}

	for _, o := range os {
		for _, rel := range identityMappings {
			if o.UserID != rel.UserID {
				continue
			}

			rel.R.User = o

			o.R.IdentityMappings = append(o.R.IdentityMappings, rel)
		}
	}

	return nil
}

// LoadKeyUsageAudits loads the user's KeyUsageAudits into the .R struct
func (o *User) LoadKeyUsageAudits(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.KeyUsageAudits = nil

	related, err := o.KeyUsageAudits(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.KeyUsageAudits = related
	return nil
}

// LoadKeyUsageAudits loads the user's KeyUsageAudits into the .R struct
func (os UserSlice) LoadKeyUsageAudits(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	keyUsageAudits, err := os.KeyUsageAudits(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.KeyUsageAudits = nil
	}

	for _, o := range os {
		for _, rel := range keyUsageAudits {
			if o.UserID != rel.UserID {
				continue
			}

			rel.R.User = o

			o.R.KeyUsageAudits = append(o.R.KeyUsageAudits, rel)
		}
	}

	return nil
}

// LoadModeratorUserModerationActions loads the user's ModeratorUserModerationActions into the .R struct
func (o *User) LoadModeratorUserModerationActions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ModeratorUserModerationActions = nil

	related, err := o.ModeratorUserModerationActions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ModeratorUserUser = o
	}

	o.R.ModeratorUserModerationActions = related
	return nil
}

// LoadModeratorUserModerationActions loads the user's ModeratorUserModerationActions into the .R struct
func (os UserSlice) LoadModeratorUserModerationActions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	moderationActions, err := os.ModeratorUserModerationActions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ModeratorUserModerationActions = nil
	}

	for _, o := range os {
		for _, rel := range moderationActions {
			if o.UserID != rel.ModeratorUserID {
				continue
			}

			rel.R.ModeratorUserUser = o

			o.R.ModeratorUserModerationActions = append(o.R.ModeratorUserModerationActions, rel)
		}
	}

	return nil
}

// LoadTargetUserModerationActions loads the user's TargetUserModerationActions into the .R struct
func (o *User) LoadTargetUserModerationActions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.TargetUserModerationActions = nil

	related, err := o.TargetUserModerationActions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.TargetUserUser = o
	}

	o.R.TargetUserModerationActions = related
	return nil
}

// LoadTargetUserModerationActions loads the user's TargetUserModerationActions into the .R struct
func (os UserSlice) LoadTargetUserModerationActions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	moderationActions, err := os.TargetUserModerationActions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.TargetUserModerationActions = nil
	}

	for _, o := range os {
		for _, rel := range moderationActions {
			if o.UserID != rel.TargetUserID.V {
				continue
			}

			rel.R.TargetUserUser = o

			o.R.TargetUserModerationActions = append(o.R.TargetUserModerationActions, rel)
		}
	}

	return nil
}

// LoadRemovedByUserPosts loads the user's RemovedByUserPosts into the .R struct
func (o *User) LoadRemovedByUserPosts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RemovedByUserPosts = nil

	related, err := o.RemovedByUserPosts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.RemovedByUserUser = o
	}

	o.R.RemovedByUserPosts = related
	return nil
}

// LoadRemovedByUserPosts loads the user's RemovedByUserPosts into the .R struct
func (os UserSlice) LoadRemovedByUserPosts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	posts, err := os.RemovedByUserPosts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.RemovedByUserPosts = nil
	}

	for _, o := range os {
		for _, rel := range posts {
			if o.UserID != rel.RemovedByUserID.V {
				continue
			}

			rel.R.RemovedByUserUser = o

			o.R.RemovedByUserPosts = append(o.R.RemovedByUserPosts, rel)
		}
	}

	return nil
}

// LoadPseudonyms loads the user's Pseudonyms into the .R struct
func (o *User) LoadPseudonyms(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Pseudonyms = nil

	related, err := o.Pseudonyms(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.Pseudonyms = related
	return nil
}

// LoadPseudonyms loads the user's Pseudonyms into the .R struct
func (os UserSlice) LoadPseudonyms(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pseudonyms, err := os.Pseudonyms(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Pseudonyms = nil
	}

	for _, o := range os {
		for _, rel := range pseudonyms {
			if o.UserID != rel.UserID {
				continue
			}

			rel.R.User = o

			o.R.Pseudonyms = append(o.R.Pseudonyms, rel)
		}
	}

	return nil
}

// LoadResolvedByUserReports loads the user's ResolvedByUserReports into the .R struct
func (o *User) LoadResolvedByUserReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ResolvedByUserReports = nil

	related, err := o.ResolvedByUserReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ResolvedByUserUser = o
	}

	o.R.ResolvedByUserReports = related
	return nil
}

// LoadResolvedByUserReports loads the user's ResolvedByUserReports into the .R struct
func (os UserSlice) LoadResolvedByUserReports(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	reports, err := os.ResolvedByUserReports(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ResolvedByUserReports = nil
	}

	for _, o := range os {
		for _, rel := range reports {
			if o.UserID != rel.ResolvedByUserID.V {
				continue
			}

			rel.R.ResolvedByUserUser = o

			o.R.ResolvedByUserReports = append(o.R.ResolvedByUserReports, rel)
		}
	}

	return nil
}

// LoadCreatedByRoleKeys loads the user's CreatedByRoleKeys into the .R struct
func (o *User) LoadCreatedByRoleKeys(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CreatedByRoleKeys = nil

	related, err := o.CreatedByRoleKeys(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.CreatedByUser = o
	}

	o.R.CreatedByRoleKeys = related
	return nil
}

// LoadCreatedByRoleKeys loads the user's CreatedByRoleKeys into the .R struct
func (os UserSlice) LoadCreatedByRoleKeys(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	roleKeys, err := os.CreatedByRoleKeys(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CreatedByRoleKeys = nil
	}

	for _, o := range os {
		for _, rel := range roleKeys {
			if o.UserID != rel.CreatedBy {
				continue
			}

			rel.R.CreatedByUser = o

			o.R.CreatedByRoleKeys = append(o.R.CreatedByRoleKeys, rel)
		}
	}

	return nil
}

// LoadAddedByUserSubforumModerators loads the user's AddedByUserSubforumModerators into the .R struct
func (o *User) LoadAddedByUserSubforumModerators(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.AddedByUserSubforumModerators = nil

	related, err := o.AddedByUserSubforumModerators(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.AddedByUserUser = o
	}

	o.R.AddedByUserSubforumModerators = related
	return nil
}

// LoadAddedByUserSubforumModerators loads the user's AddedByUserSubforumModerators into the .R struct
func (os UserSlice) LoadAddedByUserSubforumModerators(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	subforumModerators, err := os.AddedByUserSubforumModerators(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.AddedByUserSubforumModerators = nil
	}

	for _, o := range os {
		for _, rel := range subforumModerators {
			if o.UserID != rel.AddedByUserID.V {
				continue
			}

			rel.R.AddedByUserUser = o

			o.R.AddedByUserSubforumModerators = append(o.R.AddedByUserSubforumModerators, rel)
		}
	}

	return nil
}

// LoadSubforumModerators loads the user's SubforumModerators into the .R struct
func (o *User) LoadSubforumModerators(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.SubforumModerators = nil

	related, err := o.SubforumModerators(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.SubforumModerators = related
	return nil
}

// LoadSubforumModerators loads the user's SubforumModerators into the .R struct
func (os UserSlice) LoadSubforumModerators(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	subforumModerators, err := os.SubforumModerators(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.SubforumModerators = nil
	}

	for _, o := range os {
		for _, rel := range subforumModerators {
			if o.UserID != rel.UserID {
				continue
			}

			rel.R.User = o

			o.R.SubforumModerators = append(o.R.SubforumModerators, rel)
		}
	}

	return nil
}

// LoadCreatedByUserSubforums loads the user's CreatedByUserSubforums into the .R struct
func (o *User) LoadCreatedByUserSubforums(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CreatedByUserSubforums = nil

	related, err := o.CreatedByUserSubforums(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.CreatedByUserUser = o
	}

	o.R.CreatedByUserSubforums = related
	return nil
}

// LoadCreatedByUserSubforums loads the user's CreatedByUserSubforums into the .R struct
func (os UserSlice) LoadCreatedByUserSubforums(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	subforums, err := os.CreatedByUserSubforums(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CreatedByUserSubforums = nil
	}

	for _, o := range os {
		for _, rel := range subforums {
			if o.UserID != rel.CreatedByUserID.V {
				continue
			}

			rel.R.CreatedByUserUser = o

			o.R.CreatedByUserSubforums = append(o.R.CreatedByUserSubforums, rel)
		}
	}

	return nil
}

// LoadUpdatedBySystemSettings loads the user's UpdatedBySystemSettings into the .R struct
func (o *User) LoadUpdatedBySystemSettings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.UpdatedBySystemSettings = nil

	related, err := o.UpdatedBySystemSettings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.UpdatedByUser = o
	}

	o.R.UpdatedBySystemSettings = related
	return nil
}

// LoadUpdatedBySystemSettings loads the user's UpdatedBySystemSettings into the .R struct
func (os UserSlice) LoadUpdatedBySystemSettings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	systemSettings, err := os.UpdatedBySystemSettings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.UpdatedBySystemSettings = nil
	}

	for _, o := range os {
		for _, rel := range systemSettings {
			if o.UserID != rel.UpdatedBy.V {
				continue
			}

			rel.R.UpdatedByUser = o

			o.R.UpdatedBySystemSettings = append(o.R.UpdatedBySystemSettings, rel)
		}
	}

	return nil
}

// LoadBannedByUserUserBans loads the user's BannedByUserUserBans into the .R struct
func (o *User) LoadBannedByUserUserBans(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.BannedByUserUserBans = nil

	related, err := o.BannedByUserUserBans(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.BannedByUserUser = o
	}

	o.R.BannedByUserUserBans = related
	return nil
}

// LoadBannedByUserUserBans loads the user's BannedByUserUserBans into the .R struct
func (os UserSlice) LoadBannedByUserUserBans(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userBans, err := os.BannedByUserUserBans(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.BannedByUserUserBans = nil
	}

	for _, o := range os {
		for _, rel := range userBans {
			if o.UserID != rel.BannedByUserID {
				continue
			}

			rel.R.BannedByUserUser = o

			o.R.BannedByUserUserBans = append(o.R.BannedByUserUserBans, rel)
		}
	}

	return nil
}

// LoadBannedUserUserBans loads the user's BannedUserUserBans into the .R struct
func (o *User) LoadBannedUserUserBans(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.BannedUserUserBans = nil

	related, err := o.BannedUserUserBans(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.BannedUserUser = o
	}

	o.R.BannedUserUserBans = related
	return nil
}

// LoadBannedUserUserBans loads the user's BannedUserUserBans into the .R struct
func (os UserSlice) LoadBannedUserUserBans(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userBans, err := os.BannedUserUserBans(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.BannedUserUserBans = nil
	}

	for _, o := range os {
		for _, rel := range userBans {
			if o.UserID != rel.BannedUserID {
				continue
			}

			rel.R.BannedUserUser = o

			o.R.BannedUserUserBans = append(o.R.BannedUserUserBans, rel)
		}
	}

	return nil
}

// LoadBlockedUserUserBlocks loads the user's BlockedUserUserBlocks into the .R struct
func (o *User) LoadBlockedUserUserBlocks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.BlockedUserUserBlocks = nil

	related, err := o.BlockedUserUserBlocks(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.BlockedUserUser = o
	}

	o.R.BlockedUserUserBlocks = related
	return nil
}

// LoadBlockedUserUserBlocks loads the user's BlockedUserUserBlocks into the .R struct
func (os UserSlice) LoadBlockedUserUserBlocks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userBlocks, err := os.BlockedUserUserBlocks(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.BlockedUserUserBlocks = nil
	}

	for _, o := range os {
		for _, rel := range userBlocks {
			if o.UserID != rel.BlockedUserID.V {
				continue
			}

			rel.R.BlockedUserUser = o

			o.R.BlockedUserUserBlocks = append(o.R.BlockedUserUserBlocks, rel)
		}
	}

	return nil
}

// LoadUserPreference loads the user's UserPreference into the .R struct
func (o *User) LoadUserPreference(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.UserPreference = nil

	related, err := o.UserPreference(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.User = o

	o.R.UserPreference = related
	return nil
}

// LoadUserPreference loads the user's UserPreference into the .R struct
func (os UserSlice) LoadUserPreference(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userPreferences, err := os.UserPreference(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range userPreferences {
			if o.UserID != rel.UserID {
				continue
			}

			rel.R.User = o

			o.R.UserPreference = rel
			break
		}
	}

	return nil
}

func insertUserRemovedByUserComments0(ctx context.Context, exec bob.Executor, comments1 []*CommentSetter, user0 *User) (CommentSlice, error) {
	for i := range comments1 {
		comments1[i].RemovedByUserID = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}()
	}

	ret, err := Comments.Insert(bob.ToMods(comments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserRemovedByUserComments0: %w", err)
	}

	return ret, nil
}

func attachUserRemovedByUserComments0(ctx context.Context, exec bob.Executor, count int, comments1 CommentSlice, user0 *User) (CommentSlice, error) {
	setter := &CommentSetter{
		RemovedByUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}(),
	}

	err := comments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserRemovedByUserComments0: %w", err)
	}

	return comments1, nil
}

func (user0 *User) InsertRemovedByUserComments(ctx context.Context, exec bob.Executor, related ...*CommentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	comments1, err := insertUserRemovedByUserComments0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.RemovedByUserComments = append(user0.R.RemovedByUserComments, comments1...)

	for _, rel := range comments1 {
		rel.R.RemovedByUserUser = user0
	}
	return nil
}

func (user0 *User) AttachRemovedByUserComments(ctx context.Context, exec bob.Executor, related ...*Comment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	comments1 := CommentSlice(related)

	_, err = attachUserRemovedByUserComments0(ctx, exec, len(related), comments1, user0)
	if err != nil {
		return err
	}

	user0.R.RemovedByUserComments = append(user0.R.RemovedByUserComments, comments1...)

	for _, rel := range related {
		rel.R.RemovedByUserUser = user0
	}

	return nil
}

func insertUserAssignedUserComplianceReports0(ctx context.Context, exec bob.Executor, complianceReports1 []*ComplianceReportSetter, user0 *User) (ComplianceReportSlice, error) {
	for i := range complianceReports1 {
		complianceReports1[i].AssignedUserID = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}()
	}

	ret, err := ComplianceReports.Insert(bob.ToMods(complianceReports1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserAssignedUserComplianceReports0: %w", err)
	}

	return ret, nil
}

func attachUserAssignedUserComplianceReports0(ctx context.Context, exec bob.Executor, count int, complianceReports1 ComplianceReportSlice, user0 *User) (ComplianceReportSlice, error) {
	setter := &ComplianceReportSetter{
		AssignedUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}(),
	}

	err := complianceReports1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserAssignedUserComplianceReports0: %w", err)
	}

	return complianceReports1, nil
}

func (user0 *User) InsertAssignedUserComplianceReports(ctx context.Context, exec bob.Executor, related ...*ComplianceReportSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	complianceReports1, err := insertUserAssignedUserComplianceReports0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.AssignedUserComplianceReports = append(user0.R.AssignedUserComplianceReports, complianceReports1...)

	for _, rel := range complianceReports1 {
		rel.R.AssignedUserUser = user0
	}
	return nil
}

func (user0 *User) AttachAssignedUserComplianceReports(ctx context.Context, exec bob.Executor, related ...*ComplianceReport) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	complianceReports1 := ComplianceReportSlice(related)

	_, err = attachUserAssignedUserComplianceReports0(ctx, exec, len(related), complianceReports1, user0)
	if err != nil {
		return err
	}

	user0.R.AssignedUserComplianceReports = append(user0.R.AssignedUserComplianceReports, complianceReports1...)

	for _, rel := range related {
		rel.R.AssignedUserUser = user0
	}

	return nil
}

func insertUserCorrelationAudits0(ctx context.Context, exec bob.Executor, correlationAudits1 []*CorrelationAuditSetter, user0 *User) (CorrelationAuditSlice, error) {
	for i := range correlationAudits1 {
		correlationAudits1[i].UserID = &user0.UserID
	}

	ret, err := CorrelationAudits.Insert(bob.ToMods(correlationAudits1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserCorrelationAudits0: %w", err)
	}

	return ret, nil
}

func attachUserCorrelationAudits0(ctx context.Context, exec bob.Executor, count int, correlationAudits1 CorrelationAuditSlice, user0 *User) (CorrelationAuditSlice, error) {
	setter := &CorrelationAuditSetter{
		UserID: &user0.UserID,
	}

	err := correlationAudits1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserCorrelationAudits0: %w", err)
	}

	return correlationAudits1, nil
}

func (user0 *User) InsertCorrelationAudits(ctx context.Context, exec bob.Executor, related ...*CorrelationAuditSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	correlationAudits1, err := insertUserCorrelationAudits0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CorrelationAudits = append(user0.R.CorrelationAudits, correlationAudits1...)

	for _, rel := range correlationAudits1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachCorrelationAudits(ctx context.Context, exec bob.Executor, related ...*CorrelationAudit) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	correlationAudits1 := CorrelationAuditSlice(related)

	_, err = attachUserCorrelationAudits0(ctx, exec, len(related), correlationAudits1, user0)
	if err != nil {
		return err
	}

	user0.R.CorrelationAudits = append(user0.R.CorrelationAudits, correlationAudits1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserIdentityMappings0(ctx context.Context, exec bob.Executor, identityMappings1 []*IdentityMappingSetter, user0 *User) (IdentityMappingSlice, error) {
	for i := range identityMappings1 {
		identityMappings1[i].UserID = &user0.UserID
	}

	ret, err := IdentityMappings.Insert(bob.ToMods(identityMappings1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserIdentityMappings0: %w", err)
	}

	return ret, nil
}

func attachUserIdentityMappings0(ctx context.Context, exec bob.Executor, count int, identityMappings1 IdentityMappingSlice, user0 *User) (IdentityMappingSlice, error) {
	setter := &IdentityMappingSetter{
		UserID: &user0.UserID,
	}

	err := identityMappings1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserIdentityMappings0: %w", err)
	}

	return identityMappings1, nil
}

func (user0 *User) InsertIdentityMappings(ctx context.Context, exec bob.Executor, related ...*IdentityMappingSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	identityMappings1, err := insertUserIdentityMappings0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.IdentityMappings = append(user0.R.IdentityMappings, identityMappings1...)

	for _, rel := range identityMappings1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachIdentityMappings(ctx context.Context, exec bob.Executor, related ...*IdentityMapping) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	identityMappings1 := IdentityMappingSlice(related)

	_, err = attachUserIdentityMappings0(ctx, exec, len(related), identityMappings1, user0)
	if err != nil {
		return err
	}

	user0.R.IdentityMappings = append(user0.R.IdentityMappings, identityMappings1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserKeyUsageAudits0(ctx context.Context, exec bob.Executor, keyUsageAudits1 []*KeyUsageAuditSetter, user0 *User) (KeyUsageAuditSlice, error) {
	for i := range keyUsageAudits1 {
		keyUsageAudits1[i].UserID = &user0.UserID
	}

	ret, err := KeyUsageAudits.Insert(bob.ToMods(keyUsageAudits1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserKeyUsageAudits0: %w", err)
	}

	return ret, nil
}

func attachUserKeyUsageAudits0(ctx context.Context, exec bob.Executor, count int, keyUsageAudits1 KeyUsageAuditSlice, user0 *User) (KeyUsageAuditSlice, error) {
	setter := &KeyUsageAuditSetter{
		UserID: &user0.UserID,
	}

	err := keyUsageAudits1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserKeyUsageAudits0: %w", err)
	}

	return keyUsageAudits1, nil
}

func (user0 *User) InsertKeyUsageAudits(ctx context.Context, exec bob.Executor, related ...*KeyUsageAuditSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	keyUsageAudits1, err := insertUserKeyUsageAudits0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.KeyUsageAudits = append(user0.R.KeyUsageAudits, keyUsageAudits1...)

	for _, rel := range keyUsageAudits1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachKeyUsageAudits(ctx context.Context, exec bob.Executor, related ...*KeyUsageAudit) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	keyUsageAudits1 := KeyUsageAuditSlice(related)

	_, err = attachUserKeyUsageAudits0(ctx, exec, len(related), keyUsageAudits1, user0)
	if err != nil {
		return err
	}

	user0.R.KeyUsageAudits = append(user0.R.KeyUsageAudits, keyUsageAudits1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserModeratorUserModerationActions0(ctx context.Context, exec bob.Executor, moderationActions1 []*ModerationActionSetter, user0 *User) (ModerationActionSlice, error) {
	for i := range moderationActions1 {
		moderationActions1[i].ModeratorUserID = &user0.UserID
	}

	ret, err := ModerationActions.Insert(bob.ToMods(moderationActions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserModeratorUserModerationActions0: %w", err)
	}

	return ret, nil
}

func attachUserModeratorUserModerationActions0(ctx context.Context, exec bob.Executor, count int, moderationActions1 ModerationActionSlice, user0 *User) (ModerationActionSlice, error) {
	setter := &ModerationActionSetter{
		ModeratorUserID: &user0.UserID,
	}

	err := moderationActions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserModeratorUserModerationActions0: %w", err)
	}

	return moderationActions1, nil
}

func (user0 *User) InsertModeratorUserModerationActions(ctx context.Context, exec bob.Executor, related ...*ModerationActionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	moderationActions1, err := insertUserModeratorUserModerationActions0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.ModeratorUserModerationActions = append(user0.R.ModeratorUserModerationActions, moderationActions1...)

	for _, rel := range moderationActions1 {
		rel.R.ModeratorUserUser = user0
	}
	return nil
}

func (user0 *User) AttachModeratorUserModerationActions(ctx context.Context, exec bob.Executor, related ...*ModerationAction) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	moderationActions1 := ModerationActionSlice(related)

	_, err = attachUserModeratorUserModerationActions0(ctx, exec, len(related), moderationActions1, user0)
	if err != nil {
		return err
	}

	user0.R.ModeratorUserModerationActions = append(user0.R.ModeratorUserModerationActions, moderationActions1...)

	for _, rel := range related {
		rel.R.ModeratorUserUser = user0
	}

	return nil
}

func insertUserTargetUserModerationActions0(ctx context.Context, exec bob.Executor, moderationActions1 []*ModerationActionSetter, user0 *User) (ModerationActionSlice, error) {
	for i := range moderationActions1 {
		moderationActions1[i].TargetUserID = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}()
	}

	ret, err := ModerationActions.Insert(bob.ToMods(moderationActions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserTargetUserModerationActions0: %w", err)
	}

	return ret, nil
}

func attachUserTargetUserModerationActions0(ctx context.Context, exec bob.Executor, count int, moderationActions1 ModerationActionSlice, user0 *User) (ModerationActionSlice, error) {
	setter := &ModerationActionSetter{
		TargetUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}(),
	}

	err := moderationActions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserTargetUserModerationActions0: %w", err)
	}

	return moderationActions1, nil
}

func (user0 *User) InsertTargetUserModerationActions(ctx context.Context, exec bob.Executor, related ...*ModerationActionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	moderationActions1, err := insertUserTargetUserModerationActions0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.TargetUserModerationActions = append(user0.R.TargetUserModerationActions, moderationActions1...)

	for _, rel := range moderationActions1 {
		rel.R.TargetUserUser = user0
	}
	return nil
}

func (user0 *User) AttachTargetUserModerationActions(ctx context.Context, exec bob.Executor, related ...*ModerationAction) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	moderationActions1 := ModerationActionSlice(related)

	_, err = attachUserTargetUserModerationActions0(ctx, exec, len(related), moderationActions1, user0)
	if err != nil {
		return err
	}

	user0.R.TargetUserModerationActions = append(user0.R.TargetUserModerationActions, moderationActions1...)

	for _, rel := range related {
		rel.R.TargetUserUser = user0
	}

	return nil
}

func insertUserRemovedByUserPosts0(ctx context.Context, exec bob.Executor, posts1 []*PostSetter, user0 *User) (PostSlice, error) {
	for i := range posts1 {
		posts1[i].RemovedByUserID = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}()
	}

	ret, err := Posts.Insert(bob.ToMods(posts1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserRemovedByUserPosts0: %w", err)
	}

	return ret, nil
}

func attachUserRemovedByUserPosts0(ctx context.Context, exec bob.Executor, count int, posts1 PostSlice, user0 *User) (PostSlice, error) {
	setter := &PostSetter{
		RemovedByUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}(),
	}

	err := posts1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserRemovedByUserPosts0: %w", err)
	}

	return posts1, nil
}

func (user0 *User) InsertRemovedByUserPosts(ctx context.Context, exec bob.Executor, related ...*PostSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	posts1, err := insertUserRemovedByUserPosts0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.RemovedByUserPosts = append(user0.R.RemovedByUserPosts, posts1...)

	for _, rel := range posts1 {
		rel.R.RemovedByUserUser = user0
	}
	return nil
}

func (user0 *User) AttachRemovedByUserPosts(ctx context.Context, exec bob.Executor, related ...*Post) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	posts1 := PostSlice(related)

	_, err = attachUserRemovedByUserPosts0(ctx, exec, len(related), posts1, user0)
	if err != nil {
		return err
	}

	user0.R.RemovedByUserPosts = append(user0.R.RemovedByUserPosts, posts1...)

	for _, rel := range related {
		rel.R.RemovedByUserUser = user0
	}

	return nil
}

func insertUserPseudonyms0(ctx context.Context, exec bob.Executor, pseudonyms1 []*PseudonymSetter, user0 *User) (PseudonymSlice, error) {
	for i := range pseudonyms1 {
		pseudonyms1[i].UserID = &user0.UserID
	}

	ret, err := Pseudonyms.Insert(bob.ToMods(pseudonyms1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserPseudonyms0: %w", err)
	}

	return ret, nil
}

func attachUserPseudonyms0(ctx context.Context, exec bob.Executor, count int, pseudonyms1 PseudonymSlice, user0 *User) (PseudonymSlice, error) {
	setter := &PseudonymSetter{
		UserID: &user0.UserID,
	}

	err := pseudonyms1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserPseudonyms0: %w", err)
	}

	return pseudonyms1, nil
}

func (user0 *User) InsertPseudonyms(ctx context.Context, exec bob.Executor, related ...*PseudonymSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	pseudonyms1, err := insertUserPseudonyms0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.Pseudonyms = append(user0.R.Pseudonyms, pseudonyms1...)

	for _, rel := range pseudonyms1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachPseudonyms(ctx context.Context, exec bob.Executor, related ...*Pseudonym) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	pseudonyms1 := PseudonymSlice(related)

	_, err = attachUserPseudonyms0(ctx, exec, len(related), pseudonyms1, user0)
	if err != nil {
		return err
	}

	user0.R.Pseudonyms = append(user0.R.Pseudonyms, pseudonyms1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserResolvedByUserReports0(ctx context.Context, exec bob.Executor, reports1 []*ReportSetter, user0 *User) (ReportSlice, error) {
	for i := range reports1 {
		reports1[i].ResolvedByUserID = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}()
	}

	ret, err := Reports.Insert(bob.ToMods(reports1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserResolvedByUserReports0: %w", err)
	}

	return ret, nil
}

func attachUserResolvedByUserReports0(ctx context.Context, exec bob.Executor, count int, reports1 ReportSlice, user0 *User) (ReportSlice, error) {
	setter := &ReportSetter{
		ResolvedByUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}(),
	}

	err := reports1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserResolvedByUserReports0: %w", err)
	}

	return reports1, nil
}

func (user0 *User) InsertResolvedByUserReports(ctx context.Context, exec bob.Executor, related ...*ReportSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	reports1, err := insertUserResolvedByUserReports0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.ResolvedByUserReports = append(user0.R.ResolvedByUserReports, reports1...)

	for _, rel := range reports1 {
		rel.R.ResolvedByUserUser = user0
	}
	return nil
}

func (user0 *User) AttachResolvedByUserReports(ctx context.Context, exec bob.Executor, related ...*Report) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	reports1 := ReportSlice(related)

	_, err = attachUserResolvedByUserReports0(ctx, exec, len(related), reports1, user0)
	if err != nil {
		return err
	}

	user0.R.ResolvedByUserReports = append(user0.R.ResolvedByUserReports, reports1...)

	for _, rel := range related {
		rel.R.ResolvedByUserUser = user0
	}

	return nil
}

func insertUserCreatedByRoleKeys0(ctx context.Context, exec bob.Executor, roleKeys1 []*RoleKeySetter, user0 *User) (RoleKeySlice, error) {
	for i := range roleKeys1 {
		roleKeys1[i].CreatedBy = &user0.UserID
	}

	ret, err := RoleKeys.Insert(bob.ToMods(roleKeys1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserCreatedByRoleKeys0: %w", err)
	}

	return ret, nil
}

func attachUserCreatedByRoleKeys0(ctx context.Context, exec bob.Executor, count int, roleKeys1 RoleKeySlice, user0 *User) (RoleKeySlice, error) {
	setter := &RoleKeySetter{
		CreatedBy: &user0.UserID,
	}

	err := roleKeys1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserCreatedByRoleKeys0: %w", err)
	}

	return roleKeys1, nil
}

func (user0 *User) InsertCreatedByRoleKeys(ctx context.Context, exec bob.Executor, related ...*RoleKeySetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	roleKeys1, err := insertUserCreatedByRoleKeys0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByRoleKeys = append(user0.R.CreatedByRoleKeys, roleKeys1...)

	for _, rel := range roleKeys1 {
		rel.R.CreatedByUser = user0
	}
	return nil
}

func (user0 *User) AttachCreatedByRoleKeys(ctx context.Context, exec bob.Executor, related ...*RoleKey) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	roleKeys1 := RoleKeySlice(related)

	_, err = attachUserCreatedByRoleKeys0(ctx, exec, len(related), roleKeys1, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByRoleKeys = append(user0.R.CreatedByRoleKeys, roleKeys1...)

	for _, rel := range related {
		rel.R.CreatedByUser = user0
	}

	return nil
}

func insertUserAddedByUserSubforumModerators0(ctx context.Context, exec bob.Executor, subforumModerators1 []*SubforumModeratorSetter, user0 *User) (SubforumModeratorSlice, error) {
	for i := range subforumModerators1 {
		subforumModerators1[i].AddedByUserID = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}()
	}

	ret, err := SubforumModerators.Insert(bob.ToMods(subforumModerators1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserAddedByUserSubforumModerators0: %w", err)
	}

	return ret, nil
}

func attachUserAddedByUserSubforumModerators0(ctx context.Context, exec bob.Executor, count int, subforumModerators1 SubforumModeratorSlice, user0 *User) (SubforumModeratorSlice, error) {
	setter := &SubforumModeratorSetter{
		AddedByUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}(),
	}

	err := subforumModerators1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserAddedByUserSubforumModerators0: %w", err)
	}

	return subforumModerators1, nil
}

func (user0 *User) InsertAddedByUserSubforumModerators(ctx context.Context, exec bob.Executor, related ...*SubforumModeratorSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	subforumModerators1, err := insertUserAddedByUserSubforumModerators0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.AddedByUserSubforumModerators = append(user0.R.AddedByUserSubforumModerators, subforumModerators1...)

	for _, rel := range subforumModerators1 {
		rel.R.AddedByUserUser = user0
	}
	return nil
}

func (user0 *User) AttachAddedByUserSubforumModerators(ctx context.Context, exec bob.Executor, related ...*SubforumModerator) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	subforumModerators1 := SubforumModeratorSlice(related)

	_, err = attachUserAddedByUserSubforumModerators0(ctx, exec, len(related), subforumModerators1, user0)
	if err != nil {
		return err
	}

	user0.R.AddedByUserSubforumModerators = append(user0.R.AddedByUserSubforumModerators, subforumModerators1...)

	for _, rel := range related {
		rel.R.AddedByUserUser = user0
	}

	return nil
}

func insertUserSubforumModerators0(ctx context.Context, exec bob.Executor, subforumModerators1 []*SubforumModeratorSetter, user0 *User) (SubforumModeratorSlice, error) {
	for i := range subforumModerators1 {
		subforumModerators1[i].UserID = &user0.UserID
	}

	ret, err := SubforumModerators.Insert(bob.ToMods(subforumModerators1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserSubforumModerators0: %w", err)
	}

	return ret, nil
}

func attachUserSubforumModerators0(ctx context.Context, exec bob.Executor, count int, subforumModerators1 SubforumModeratorSlice, user0 *User) (SubforumModeratorSlice, error) {
	setter := &SubforumModeratorSetter{
		UserID: &user0.UserID,
	}

	err := subforumModerators1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserSubforumModerators0: %w", err)
	}

	return subforumModerators1, nil
}

func (user0 *User) InsertSubforumModerators(ctx context.Context, exec bob.Executor, related ...*SubforumModeratorSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	subforumModerators1, err := insertUserSubforumModerators0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.SubforumModerators = append(user0.R.SubforumModerators, subforumModerators1...)

	for _, rel := range subforumModerators1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachSubforumModerators(ctx context.Context, exec bob.Executor, related ...*SubforumModerator) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	subforumModerators1 := SubforumModeratorSlice(related)

	_, err = attachUserSubforumModerators0(ctx, exec, len(related), subforumModerators1, user0)
	if err != nil {
		return err
	}

	user0.R.SubforumModerators = append(user0.R.SubforumModerators, subforumModerators1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserCreatedByUserSubforums0(ctx context.Context, exec bob.Executor, subforums1 []*SubforumSetter, user0 *User) (SubforumSlice, error) {
	for i := range subforums1 {
		subforums1[i].CreatedByUserID = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}()
	}

	ret, err := Subforums.Insert(bob.ToMods(subforums1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserCreatedByUserSubforums0: %w", err)
	}

	return ret, nil
}

func attachUserCreatedByUserSubforums0(ctx context.Context, exec bob.Executor, count int, subforums1 SubforumSlice, user0 *User) (SubforumSlice, error) {
	setter := &SubforumSetter{
		CreatedByUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}(),
	}

	err := subforums1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserCreatedByUserSubforums0: %w", err)
	}

	return subforums1, nil
}

func (user0 *User) InsertCreatedByUserSubforums(ctx context.Context, exec bob.Executor, related ...*SubforumSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	subforums1, err := insertUserCreatedByUserSubforums0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByUserSubforums = append(user0.R.CreatedByUserSubforums, subforums1...)

	for _, rel := range subforums1 {
		rel.R.CreatedByUserUser = user0
	}
	return nil
}

func (user0 *User) AttachCreatedByUserSubforums(ctx context.Context, exec bob.Executor, related ...*Subforum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	subforums1 := SubforumSlice(related)

	_, err = attachUserCreatedByUserSubforums0(ctx, exec, len(related), subforums1, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByUserSubforums = append(user0.R.CreatedByUserSubforums, subforums1...)

	for _, rel := range related {
		rel.R.CreatedByUserUser = user0
	}

	return nil
}

func insertUserUpdatedBySystemSettings0(ctx context.Context, exec bob.Executor, systemSettings1 []*SystemSettingSetter, user0 *User) (SystemSettingSlice, error) {
	for i := range systemSettings1 {
		systemSettings1[i].UpdatedBy = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}()
	}

	ret, err := SystemSettings.Insert(bob.ToMods(systemSettings1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserUpdatedBySystemSettings0: %w", err)
	}

	return ret, nil
}

func attachUserUpdatedBySystemSettings0(ctx context.Context, exec bob.Executor, count int, systemSettings1 SystemSettingSlice, user0 *User) (SystemSettingSlice, error) {
	setter := &SystemSettingSetter{
		UpdatedBy: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}(),
	}

	err := systemSettings1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserUpdatedBySystemSettings0: %w", err)
	}

	return systemSettings1, nil
}

func (user0 *User) InsertUpdatedBySystemSettings(ctx context.Context, exec bob.Executor, related ...*SystemSettingSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	systemSettings1, err := insertUserUpdatedBySystemSettings0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.UpdatedBySystemSettings = append(user0.R.UpdatedBySystemSettings, systemSettings1...)

	for _, rel := range systemSettings1 {
		rel.R.UpdatedByUser = user0
	}
	return nil
}

func (user0 *User) AttachUpdatedBySystemSettings(ctx context.Context, exec bob.Executor, related ...*SystemSetting) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	systemSettings1 := SystemSettingSlice(related)

	_, err = attachUserUpdatedBySystemSettings0(ctx, exec, len(related), systemSettings1, user0)
	if err != nil {
		return err
	}

	user0.R.UpdatedBySystemSettings = append(user0.R.UpdatedBySystemSettings, systemSettings1...)

	for _, rel := range related {
		rel.R.UpdatedByUser = user0
	}

	return nil
}

func insertUserBannedByUserUserBans0(ctx context.Context, exec bob.Executor, userBans1 []*UserBanSetter, user0 *User) (UserBanSlice, error) {
	for i := range userBans1 {
		userBans1[i].BannedByUserID = &user0.UserID
	}

	ret, err := UserBans.Insert(bob.ToMods(userBans1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserBannedByUserUserBans0: %w", err)
	}

	return ret, nil
}

func attachUserBannedByUserUserBans0(ctx context.Context, exec bob.Executor, count int, userBans1 UserBanSlice, user0 *User) (UserBanSlice, error) {
	setter := &UserBanSetter{
		BannedByUserID: &user0.UserID,
	}

	err := userBans1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserBannedByUserUserBans0: %w", err)
	}

	return userBans1, nil
}

func (user0 *User) InsertBannedByUserUserBans(ctx context.Context, exec bob.Executor, related ...*UserBanSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	userBans1, err := insertUserBannedByUserUserBans0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.BannedByUserUserBans = append(user0.R.BannedByUserUserBans, userBans1...)

	for _, rel := range userBans1 {
		rel.R.BannedByUserUser = user0
	}
	return nil
}

func (user0 *User) AttachBannedByUserUserBans(ctx context.Context, exec bob.Executor, related ...*UserBan) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	userBans1 := UserBanSlice(related)

	_, err = attachUserBannedByUserUserBans0(ctx, exec, len(related), userBans1, user0)
	if err != nil {
		return err
	}

	user0.R.BannedByUserUserBans = append(user0.R.BannedByUserUserBans, userBans1...)

	for _, rel := range related {
		rel.R.BannedByUserUser = user0
	}

	return nil
}

func insertUserBannedUserUserBans0(ctx context.Context, exec bob.Executor, userBans1 []*UserBanSetter, user0 *User) (UserBanSlice, error) {
	for i := range userBans1 {
		userBans1[i].BannedUserID = &user0.UserID
	}

	ret, err := UserBans.Insert(bob.ToMods(userBans1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserBannedUserUserBans0: %w", err)
	}

	return ret, nil
}

func attachUserBannedUserUserBans0(ctx context.Context, exec bob.Executor, count int, userBans1 UserBanSlice, user0 *User) (UserBanSlice, error) {
	setter := &UserBanSetter{
		BannedUserID: &user0.UserID,
	}

	err := userBans1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserBannedUserUserBans0: %w", err)
	}

	return userBans1, nil
}

func (user0 *User) InsertBannedUserUserBans(ctx context.Context, exec bob.Executor, related ...*UserBanSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	userBans1, err := insertUserBannedUserUserBans0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.BannedUserUserBans = append(user0.R.BannedUserUserBans, userBans1...)

	for _, rel := range userBans1 {
		rel.R.BannedUserUser = user0
	}
	return nil
}

func (user0 *User) AttachBannedUserUserBans(ctx context.Context, exec bob.Executor, related ...*UserBan) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	userBans1 := UserBanSlice(related)

	_, err = attachUserBannedUserUserBans0(ctx, exec, len(related), userBans1, user0)
	if err != nil {
		return err
	}

	user0.R.BannedUserUserBans = append(user0.R.BannedUserUserBans, userBans1...)

	for _, rel := range related {
		rel.R.BannedUserUser = user0
	}

	return nil
}

func insertUserBlockedUserUserBlocks0(ctx context.Context, exec bob.Executor, userBlocks1 []*UserBlockSetter, user0 *User) (UserBlockSlice, error) {
	for i := range userBlocks1 {
		userBlocks1[i].BlockedUserID = func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}()
	}

	ret, err := UserBlocks.Insert(bob.ToMods(userBlocks1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserBlockedUserUserBlocks0: %w", err)
	}

	return ret, nil
}

func attachUserBlockedUserUserBlocks0(ctx context.Context, exec bob.Executor, count int, userBlocks1 UserBlockSlice, user0 *User) (UserBlockSlice, error) {
	setter := &UserBlockSetter{
		BlockedUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user0.UserID, Valid: true}
			return &v
		}(),
	}

	err := userBlocks1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserBlockedUserUserBlocks0: %w", err)
	}

	return userBlocks1, nil
}

func (user0 *User) InsertBlockedUserUserBlocks(ctx context.Context, exec bob.Executor, related ...*UserBlockSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	userBlocks1, err := insertUserBlockedUserUserBlocks0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.BlockedUserUserBlocks = append(user0.R.BlockedUserUserBlocks, userBlocks1...)

	for _, rel := range userBlocks1 {
		rel.R.BlockedUserUser = user0
	}
	return nil
}

func (user0 *User) AttachBlockedUserUserBlocks(ctx context.Context, exec bob.Executor, related ...*UserBlock) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	userBlocks1 := UserBlockSlice(related)

	_, err = attachUserBlockedUserUserBlocks0(ctx, exec, len(related), userBlocks1, user0)
	if err != nil {
		return err
	}

	user0.R.BlockedUserUserBlocks = append(user0.R.BlockedUserUserBlocks, userBlocks1...)

	for _, rel := range related {
		rel.R.BlockedUserUser = user0
	}

	return nil
}

func insertUserUserPreference0(ctx context.Context, exec bob.Executor, userPreference1 *UserPreferenceSetter, user0 *User) (*UserPreference, error) {
	userPreference1.UserID = &user0.UserID

	ret, err := UserPreferences.Insert(userPreference1).One(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserUserPreference0: %w", err)
	}

	return ret, nil
}

func attachUserUserPreference0(ctx context.Context, exec bob.Executor, count int, userPreference1 *UserPreference, user0 *User) (*UserPreference, error) {
	setter := &UserPreferenceSetter{
		UserID: &user0.UserID,
	}

	err := userPreference1.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserUserPreference0: %w", err)
	}

	return userPreference1, nil
}

func (user0 *User) InsertUserPreference(ctx context.Context, exec bob.Executor, related *UserPreferenceSetter) error {
	userPreference1, err := insertUserUserPreference0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.UserPreference = userPreference1

	userPreference1.R.User = user0

	return nil
}

func (user0 *User) AttachUserPreference(ctx context.Context, exec bob.Executor, userPreference1 *UserPreference) error {
	var err error

	_, err = attachUserUserPreference0(ctx, exec, 1, userPreference1, user0)
	if err != nil {
		return err
	}

	user0.R.UserPreference = userPreference1

	userPreference1.R.User = user0

	return nil
}
