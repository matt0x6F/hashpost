// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"time"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// Subforum is an object representing the database table.
type Subforum struct {
	SubforumID             int32               `db:"subforum_id,pk" scan:"subforum_id" json:"subforum_id"`
	Name                   string              `db:"name" scan:"name" json:"name"`
	DisplayName            string              `db:"display_name" scan:"display_name" json:"display_name"`
	Description            sql.Null[string]    `db:"description" scan:"description" json:"description"`
	SidebarText            sql.Null[string]    `db:"sidebar_text" scan:"sidebar_text" json:"sidebar_text"`
	RulesText              sql.Null[string]    `db:"rules_text" scan:"rules_text" json:"rules_text"`
	CreatedAt              sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	CreatedByUserID        sql.Null[int64]     `db:"created_by_user_id" scan:"created_by_user_id" json:"created_by_user_id"`
	SubscriberCount        sql.Null[int32]     `db:"subscriber_count" scan:"subscriber_count" json:"subscriber_count"`
	PostCount              sql.Null[int32]     `db:"post_count" scan:"post_count" json:"post_count"`
	IsPrivate              sql.Null[bool]      `db:"is_private" scan:"is_private" json:"is_private"`
	IsRestricted           sql.Null[bool]      `db:"is_restricted" scan:"is_restricted" json:"is_restricted"`
	IsNSFW                 sql.Null[bool]      `db:"is_nsfw" scan:"is_nsfw" json:"is_nsfw"`
	IsQuarantined          sql.Null[bool]      `db:"is_quarantined" scan:"is_quarantined" json:"is_quarantined"`
	AllowImages            sql.Null[bool]      `db:"allow_images" scan:"allow_images" json:"allow_images"`
	AllowVideos            sql.Null[bool]      `db:"allow_videos" scan:"allow_videos" json:"allow_videos"`
	AllowPolls             sql.Null[bool]      `db:"allow_polls" scan:"allow_polls" json:"allow_polls"`
	RequireFlair           sql.Null[bool]      `db:"require_flair" scan:"require_flair" json:"require_flair"`
	MinimumAccountAgeHours sql.Null[int32]     `db:"minimum_account_age_hours" scan:"minimum_account_age_hours" json:"minimum_account_age_hours"`
	MinimumKarmaRequired   sql.Null[int32]     `db:"minimum_karma_required" scan:"minimum_karma_required" json:"minimum_karma_required"`
	UpdatedAt              sql.Null[time.Time] `db:"updated_at" scan:"updated_at" json:"updated_at"`

	R subforumR `db:"-" scan:"rel" json:"rel"`
}

// SubforumSlice is an alias for a slice of pointers to Subforum.
// This should almost always be used instead of []*Subforum.
type SubforumSlice []*Subforum

// Subforums contains methods to work with the subforums table
var Subforums = psql.NewTablex[*Subforum, SubforumSlice, *SubforumSetter]("", "subforums")

// SubforumsQuery is a query on the subforums table
type SubforumsQuery = *psql.ViewQuery[*Subforum, SubforumSlice]

// subforumR is where relationships are stored.
type subforumR struct {
	ModerationActions     ModerationActionSlice     `scan:"ModerationActions" json:"ModerationActions"`         // moderation_actions.moderation_actions_subforum_id_fkey
	Posts                 PostSlice                 `scan:"Posts" json:"Posts"`                                 // posts.posts_subforum_id_fkey
	SubforumModerators    SubforumModeratorSlice    `scan:"SubforumModerators" json:"SubforumModerators"`       // subforum_moderators.subforum_moderators_subforum_id_fkey
	SubforumSubscriptions SubforumSubscriptionSlice `scan:"SubforumSubscriptions" json:"SubforumSubscriptions"` // subforum_subscriptions.subforum_subscriptions_subforum_id_fkey
	CreatedByUserUser     *User                     `scan:"CreatedByUserUser" json:"CreatedByUserUser"`         // subforums.subforums_created_by_user_id_fkey
	UserBans              UserBanSlice              `scan:"UserBans" json:"UserBans"`                           // user_bans.user_bans_subforum_id_fkey
}

type subforumColumnNames struct {
	SubforumID             string
	Name                   string
	DisplayName            string
	Description            string
	SidebarText            string
	RulesText              string
	CreatedAt              string
	CreatedByUserID        string
	SubscriberCount        string
	PostCount              string
	IsPrivate              string
	IsRestricted           string
	IsNSFW                 string
	IsQuarantined          string
	AllowImages            string
	AllowVideos            string
	AllowPolls             string
	RequireFlair           string
	MinimumAccountAgeHours string
	MinimumKarmaRequired   string
	UpdatedAt              string
}

var SubforumColumns = buildSubforumColumns("subforums")

type subforumColumns struct {
	tableAlias             string
	SubforumID             psql.Expression
	Name                   psql.Expression
	DisplayName            psql.Expression
	Description            psql.Expression
	SidebarText            psql.Expression
	RulesText              psql.Expression
	CreatedAt              psql.Expression
	CreatedByUserID        psql.Expression
	SubscriberCount        psql.Expression
	PostCount              psql.Expression
	IsPrivate              psql.Expression
	IsRestricted           psql.Expression
	IsNSFW                 psql.Expression
	IsQuarantined          psql.Expression
	AllowImages            psql.Expression
	AllowVideos            psql.Expression
	AllowPolls             psql.Expression
	RequireFlair           psql.Expression
	MinimumAccountAgeHours psql.Expression
	MinimumKarmaRequired   psql.Expression
	UpdatedAt              psql.Expression
}

func (c subforumColumns) Alias() string {
	return c.tableAlias
}

func (subforumColumns) AliasedAs(alias string) subforumColumns {
	return buildSubforumColumns(alias)
}

func buildSubforumColumns(alias string) subforumColumns {
	return subforumColumns{
		tableAlias:             alias,
		SubforumID:             psql.Quote(alias, "subforum_id"),
		Name:                   psql.Quote(alias, "name"),
		DisplayName:            psql.Quote(alias, "display_name"),
		Description:            psql.Quote(alias, "description"),
		SidebarText:            psql.Quote(alias, "sidebar_text"),
		RulesText:              psql.Quote(alias, "rules_text"),
		CreatedAt:              psql.Quote(alias, "created_at"),
		CreatedByUserID:        psql.Quote(alias, "created_by_user_id"),
		SubscriberCount:        psql.Quote(alias, "subscriber_count"),
		PostCount:              psql.Quote(alias, "post_count"),
		IsPrivate:              psql.Quote(alias, "is_private"),
		IsRestricted:           psql.Quote(alias, "is_restricted"),
		IsNSFW:                 psql.Quote(alias, "is_nsfw"),
		IsQuarantined:          psql.Quote(alias, "is_quarantined"),
		AllowImages:            psql.Quote(alias, "allow_images"),
		AllowVideos:            psql.Quote(alias, "allow_videos"),
		AllowPolls:             psql.Quote(alias, "allow_polls"),
		RequireFlair:           psql.Quote(alias, "require_flair"),
		MinimumAccountAgeHours: psql.Quote(alias, "minimum_account_age_hours"),
		MinimumKarmaRequired:   psql.Quote(alias, "minimum_karma_required"),
		UpdatedAt:              psql.Quote(alias, "updated_at"),
	}
}

type subforumWhere[Q psql.Filterable] struct {
	SubforumID             psql.WhereMod[Q, int32]
	Name                   psql.WhereMod[Q, string]
	DisplayName            psql.WhereMod[Q, string]
	Description            psql.WhereNullMod[Q, string]
	SidebarText            psql.WhereNullMod[Q, string]
	RulesText              psql.WhereNullMod[Q, string]
	CreatedAt              psql.WhereNullMod[Q, time.Time]
	CreatedByUserID        psql.WhereNullMod[Q, int64]
	SubscriberCount        psql.WhereNullMod[Q, int32]
	PostCount              psql.WhereNullMod[Q, int32]
	IsPrivate              psql.WhereNullMod[Q, bool]
	IsRestricted           psql.WhereNullMod[Q, bool]
	IsNSFW                 psql.WhereNullMod[Q, bool]
	IsQuarantined          psql.WhereNullMod[Q, bool]
	AllowImages            psql.WhereNullMod[Q, bool]
	AllowVideos            psql.WhereNullMod[Q, bool]
	AllowPolls             psql.WhereNullMod[Q, bool]
	RequireFlair           psql.WhereNullMod[Q, bool]
	MinimumAccountAgeHours psql.WhereNullMod[Q, int32]
	MinimumKarmaRequired   psql.WhereNullMod[Q, int32]
	UpdatedAt              psql.WhereNullMod[Q, time.Time]
}

func (subforumWhere[Q]) AliasedAs(alias string) subforumWhere[Q] {
	return buildSubforumWhere[Q](buildSubforumColumns(alias))
}

func buildSubforumWhere[Q psql.Filterable](cols subforumColumns) subforumWhere[Q] {
	return subforumWhere[Q]{
		SubforumID:             psql.Where[Q, int32](cols.SubforumID),
		Name:                   psql.Where[Q, string](cols.Name),
		DisplayName:            psql.Where[Q, string](cols.DisplayName),
		Description:            psql.WhereNull[Q, string](cols.Description),
		SidebarText:            psql.WhereNull[Q, string](cols.SidebarText),
		RulesText:              psql.WhereNull[Q, string](cols.RulesText),
		CreatedAt:              psql.WhereNull[Q, time.Time](cols.CreatedAt),
		CreatedByUserID:        psql.WhereNull[Q, int64](cols.CreatedByUserID),
		SubscriberCount:        psql.WhereNull[Q, int32](cols.SubscriberCount),
		PostCount:              psql.WhereNull[Q, int32](cols.PostCount),
		IsPrivate:              psql.WhereNull[Q, bool](cols.IsPrivate),
		IsRestricted:           psql.WhereNull[Q, bool](cols.IsRestricted),
		IsNSFW:                 psql.WhereNull[Q, bool](cols.IsNSFW),
		IsQuarantined:          psql.WhereNull[Q, bool](cols.IsQuarantined),
		AllowImages:            psql.WhereNull[Q, bool](cols.AllowImages),
		AllowVideos:            psql.WhereNull[Q, bool](cols.AllowVideos),
		AllowPolls:             psql.WhereNull[Q, bool](cols.AllowPolls),
		RequireFlair:           psql.WhereNull[Q, bool](cols.RequireFlair),
		MinimumAccountAgeHours: psql.WhereNull[Q, int32](cols.MinimumAccountAgeHours),
		MinimumKarmaRequired:   psql.WhereNull[Q, int32](cols.MinimumKarmaRequired),
		UpdatedAt:              psql.WhereNull[Q, time.Time](cols.UpdatedAt),
	}
}

var SubforumErrors = &subforumErrors{
	ErrUniqueSubforumsPkey: &UniqueConstraintError{
		schema:  "",
		table:   "subforums",
		columns: []string{"subforum_id"},
		s:       "subforums_pkey",
	},

	ErrUniqueSubforumsNameKey: &UniqueConstraintError{
		schema:  "",
		table:   "subforums",
		columns: []string{"name"},
		s:       "subforums_name_key",
	},
}

type subforumErrors struct {
	ErrUniqueSubforumsPkey *UniqueConstraintError

	ErrUniqueSubforumsNameKey *UniqueConstraintError
}

// SubforumSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type SubforumSetter struct {
	SubforumID             *int32               `db:"subforum_id,pk" scan:"subforum_id" json:"subforum_id"`
	Name                   *string              `db:"name" scan:"name" json:"name"`
	DisplayName            *string              `db:"display_name" scan:"display_name" json:"display_name"`
	Description            *sql.Null[string]    `db:"description" scan:"description" json:"description"`
	SidebarText            *sql.Null[string]    `db:"sidebar_text" scan:"sidebar_text" json:"sidebar_text"`
	RulesText              *sql.Null[string]    `db:"rules_text" scan:"rules_text" json:"rules_text"`
	CreatedAt              *sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	CreatedByUserID        *sql.Null[int64]     `db:"created_by_user_id" scan:"created_by_user_id" json:"created_by_user_id"`
	SubscriberCount        *sql.Null[int32]     `db:"subscriber_count" scan:"subscriber_count" json:"subscriber_count"`
	PostCount              *sql.Null[int32]     `db:"post_count" scan:"post_count" json:"post_count"`
	IsPrivate              *sql.Null[bool]      `db:"is_private" scan:"is_private" json:"is_private"`
	IsRestricted           *sql.Null[bool]      `db:"is_restricted" scan:"is_restricted" json:"is_restricted"`
	IsNSFW                 *sql.Null[bool]      `db:"is_nsfw" scan:"is_nsfw" json:"is_nsfw"`
	IsQuarantined          *sql.Null[bool]      `db:"is_quarantined" scan:"is_quarantined" json:"is_quarantined"`
	AllowImages            *sql.Null[bool]      `db:"allow_images" scan:"allow_images" json:"allow_images"`
	AllowVideos            *sql.Null[bool]      `db:"allow_videos" scan:"allow_videos" json:"allow_videos"`
	AllowPolls             *sql.Null[bool]      `db:"allow_polls" scan:"allow_polls" json:"allow_polls"`
	RequireFlair           *sql.Null[bool]      `db:"require_flair" scan:"require_flair" json:"require_flair"`
	MinimumAccountAgeHours *sql.Null[int32]     `db:"minimum_account_age_hours" scan:"minimum_account_age_hours" json:"minimum_account_age_hours"`
	MinimumKarmaRequired   *sql.Null[int32]     `db:"minimum_karma_required" scan:"minimum_karma_required" json:"minimum_karma_required"`
	UpdatedAt              *sql.Null[time.Time] `db:"updated_at" scan:"updated_at" json:"updated_at"`
}

func (s SubforumSetter) SetColumns() []string {
	vals := make([]string, 0, 21)
	if s.SubforumID != nil {
		vals = append(vals, "subforum_id")
	}

	if s.Name != nil {
		vals = append(vals, "name")
	}

	if s.DisplayName != nil {
		vals = append(vals, "display_name")
	}

	if s.Description != nil {
		vals = append(vals, "description")
	}

	if s.SidebarText != nil {
		vals = append(vals, "sidebar_text")
	}

	if s.RulesText != nil {
		vals = append(vals, "rules_text")
	}

	if s.CreatedAt != nil {
		vals = append(vals, "created_at")
	}

	if s.CreatedByUserID != nil {
		vals = append(vals, "created_by_user_id")
	}

	if s.SubscriberCount != nil {
		vals = append(vals, "subscriber_count")
	}

	if s.PostCount != nil {
		vals = append(vals, "post_count")
	}

	if s.IsPrivate != nil {
		vals = append(vals, "is_private")
	}

	if s.IsRestricted != nil {
		vals = append(vals, "is_restricted")
	}

	if s.IsNSFW != nil {
		vals = append(vals, "is_nsfw")
	}

	if s.IsQuarantined != nil {
		vals = append(vals, "is_quarantined")
	}

	if s.AllowImages != nil {
		vals = append(vals, "allow_images")
	}

	if s.AllowVideos != nil {
		vals = append(vals, "allow_videos")
	}

	if s.AllowPolls != nil {
		vals = append(vals, "allow_polls")
	}

	if s.RequireFlair != nil {
		vals = append(vals, "require_flair")
	}

	if s.MinimumAccountAgeHours != nil {
		vals = append(vals, "minimum_account_age_hours")
	}

	if s.MinimumKarmaRequired != nil {
		vals = append(vals, "minimum_karma_required")
	}

	if s.UpdatedAt != nil {
		vals = append(vals, "updated_at")
	}

	return vals
}

func (s SubforumSetter) Overwrite(t *Subforum) {
	if s.SubforumID != nil {
		t.SubforumID = *s.SubforumID
	}
	if s.Name != nil {
		t.Name = *s.Name
	}
	if s.DisplayName != nil {
		t.DisplayName = *s.DisplayName
	}
	if s.Description != nil {
		t.Description = *s.Description
	}
	if s.SidebarText != nil {
		t.SidebarText = *s.SidebarText
	}
	if s.RulesText != nil {
		t.RulesText = *s.RulesText
	}
	if s.CreatedAt != nil {
		t.CreatedAt = *s.CreatedAt
	}
	if s.CreatedByUserID != nil {
		t.CreatedByUserID = *s.CreatedByUserID
	}
	if s.SubscriberCount != nil {
		t.SubscriberCount = *s.SubscriberCount
	}
	if s.PostCount != nil {
		t.PostCount = *s.PostCount
	}
	if s.IsPrivate != nil {
		t.IsPrivate = *s.IsPrivate
	}
	if s.IsRestricted != nil {
		t.IsRestricted = *s.IsRestricted
	}
	if s.IsNSFW != nil {
		t.IsNSFW = *s.IsNSFW
	}
	if s.IsQuarantined != nil {
		t.IsQuarantined = *s.IsQuarantined
	}
	if s.AllowImages != nil {
		t.AllowImages = *s.AllowImages
	}
	if s.AllowVideos != nil {
		t.AllowVideos = *s.AllowVideos
	}
	if s.AllowPolls != nil {
		t.AllowPolls = *s.AllowPolls
	}
	if s.RequireFlair != nil {
		t.RequireFlair = *s.RequireFlair
	}
	if s.MinimumAccountAgeHours != nil {
		t.MinimumAccountAgeHours = *s.MinimumAccountAgeHours
	}
	if s.MinimumKarmaRequired != nil {
		t.MinimumKarmaRequired = *s.MinimumKarmaRequired
	}
	if s.UpdatedAt != nil {
		t.UpdatedAt = *s.UpdatedAt
	}
}

func (s *SubforumSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Subforums.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 21)
		if s.SubforumID != nil {
			vals[0] = psql.Arg(*s.SubforumID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.Name != nil {
			vals[1] = psql.Arg(*s.Name)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.DisplayName != nil {
			vals[2] = psql.Arg(*s.DisplayName)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.Description != nil {
			vals[3] = psql.Arg(*s.Description)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.SidebarText != nil {
			vals[4] = psql.Arg(*s.SidebarText)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.RulesText != nil {
			vals[5] = psql.Arg(*s.RulesText)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt != nil {
			vals[6] = psql.Arg(*s.CreatedAt)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.CreatedByUserID != nil {
			vals[7] = psql.Arg(*s.CreatedByUserID)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.SubscriberCount != nil {
			vals[8] = psql.Arg(*s.SubscriberCount)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.PostCount != nil {
			vals[9] = psql.Arg(*s.PostCount)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.IsPrivate != nil {
			vals[10] = psql.Arg(*s.IsPrivate)
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.IsRestricted != nil {
			vals[11] = psql.Arg(*s.IsRestricted)
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.IsNSFW != nil {
			vals[12] = psql.Arg(*s.IsNSFW)
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.IsQuarantined != nil {
			vals[13] = psql.Arg(*s.IsQuarantined)
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.AllowImages != nil {
			vals[14] = psql.Arg(*s.AllowImages)
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.AllowVideos != nil {
			vals[15] = psql.Arg(*s.AllowVideos)
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if s.AllowPolls != nil {
			vals[16] = psql.Arg(*s.AllowPolls)
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if s.RequireFlair != nil {
			vals[17] = psql.Arg(*s.RequireFlair)
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if s.MinimumAccountAgeHours != nil {
			vals[18] = psql.Arg(*s.MinimumAccountAgeHours)
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if s.MinimumKarmaRequired != nil {
			vals[19] = psql.Arg(*s.MinimumKarmaRequired)
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if s.UpdatedAt != nil {
			vals[20] = psql.Arg(*s.UpdatedAt)
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s SubforumSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s SubforumSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 21)

	if s.SubforumID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "subforum_id")...),
			psql.Arg(s.SubforumID),
		}})
	}

	if s.Name != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "name")...),
			psql.Arg(s.Name),
		}})
	}

	if s.DisplayName != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "display_name")...),
			psql.Arg(s.DisplayName),
		}})
	}

	if s.Description != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "description")...),
			psql.Arg(s.Description),
		}})
	}

	if s.SidebarText != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sidebar_text")...),
			psql.Arg(s.SidebarText),
		}})
	}

	if s.RulesText != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "rules_text")...),
			psql.Arg(s.RulesText),
		}})
	}

	if s.CreatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.CreatedByUserID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_by_user_id")...),
			psql.Arg(s.CreatedByUserID),
		}})
	}

	if s.SubscriberCount != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "subscriber_count")...),
			psql.Arg(s.SubscriberCount),
		}})
	}

	if s.PostCount != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "post_count")...),
			psql.Arg(s.PostCount),
		}})
	}

	if s.IsPrivate != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_private")...),
			psql.Arg(s.IsPrivate),
		}})
	}

	if s.IsRestricted != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_restricted")...),
			psql.Arg(s.IsRestricted),
		}})
	}

	if s.IsNSFW != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_nsfw")...),
			psql.Arg(s.IsNSFW),
		}})
	}

	if s.IsQuarantined != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_quarantined")...),
			psql.Arg(s.IsQuarantined),
		}})
	}

	if s.AllowImages != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "allow_images")...),
			psql.Arg(s.AllowImages),
		}})
	}

	if s.AllowVideos != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "allow_videos")...),
			psql.Arg(s.AllowVideos),
		}})
	}

	if s.AllowPolls != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "allow_polls")...),
			psql.Arg(s.AllowPolls),
		}})
	}

	if s.RequireFlair != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "require_flair")...),
			psql.Arg(s.RequireFlair),
		}})
	}

	if s.MinimumAccountAgeHours != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "minimum_account_age_hours")...),
			psql.Arg(s.MinimumAccountAgeHours),
		}})
	}

	if s.MinimumKarmaRequired != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "minimum_karma_required")...),
			psql.Arg(s.MinimumKarmaRequired),
		}})
	}

	if s.UpdatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated_at")...),
			psql.Arg(s.UpdatedAt),
		}})
	}

	return exprs
}

// FindSubforum retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindSubforum(ctx context.Context, exec bob.Executor, SubforumIDPK int32, cols ...string) (*Subforum, error) {
	if len(cols) == 0 {
		return Subforums.Query(
			SelectWhere.Subforums.SubforumID.EQ(SubforumIDPK),
		).One(ctx, exec)
	}

	return Subforums.Query(
		SelectWhere.Subforums.SubforumID.EQ(SubforumIDPK),
		sm.Columns(Subforums.Columns().Only(cols...)),
	).One(ctx, exec)
}

// SubforumExists checks the presence of a single record by primary key
func SubforumExists(ctx context.Context, exec bob.Executor, SubforumIDPK int32) (bool, error) {
	return Subforums.Query(
		SelectWhere.Subforums.SubforumID.EQ(SubforumIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Subforum is retrieved from the database
func (o *Subforum) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Subforums.AfterSelectHooks.RunHooks(ctx, exec, SubforumSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Subforums.AfterInsertHooks.RunHooks(ctx, exec, SubforumSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Subforums.AfterUpdateHooks.RunHooks(ctx, exec, SubforumSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Subforums.AfterDeleteHooks.RunHooks(ctx, exec, SubforumSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Subforum
func (o *Subforum) primaryKeyVals() bob.Expression {
	return psql.Arg(o.SubforumID)
}

func (o *Subforum) pkEQ() dialect.Expression {
	return psql.Quote("subforums", "subforum_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Subforum
func (o *Subforum) Update(ctx context.Context, exec bob.Executor, s *SubforumSetter) error {
	v, err := Subforums.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Subforum record with an executor
func (o *Subforum) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Subforums.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Subforum using the executor
func (o *Subforum) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Subforums.Query(
		SelectWhere.Subforums.SubforumID.EQ(o.SubforumID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after SubforumSlice is retrieved from the database
func (o SubforumSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Subforums.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Subforums.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Subforums.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Subforums.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o SubforumSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("subforums", "subforum_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o SubforumSlice) copyMatchingRows(from ...*Subforum) {
	for i, old := range o {
		for _, new := range from {
			if new.SubforumID != old.SubforumID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o SubforumSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Subforums.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Subforum:
				o.copyMatchingRows(retrieved)
			case []*Subforum:
				o.copyMatchingRows(retrieved...)
			case SubforumSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Subforum or a slice of Subforum
				// then run the AfterUpdateHooks on the slice
				_, err = Subforums.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o SubforumSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Subforums.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Subforum:
				o.copyMatchingRows(retrieved)
			case []*Subforum:
				o.copyMatchingRows(retrieved...)
			case SubforumSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Subforum or a slice of Subforum
				// then run the AfterDeleteHooks on the slice
				_, err = Subforums.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o SubforumSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals SubforumSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Subforums.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o SubforumSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Subforums.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o SubforumSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Subforums.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type subforumJoins[Q dialect.Joinable] struct {
	typ                   string
	ModerationActions     modAs[Q, moderationActionColumns]
	Posts                 modAs[Q, postColumns]
	SubforumModerators    modAs[Q, subforumModeratorColumns]
	SubforumSubscriptions modAs[Q, subforumSubscriptionColumns]
	CreatedByUserUser     modAs[Q, userColumns]
	UserBans              modAs[Q, userBanColumns]
}

func (j subforumJoins[Q]) aliasedAs(alias string) subforumJoins[Q] {
	return buildSubforumJoins[Q](buildSubforumColumns(alias), j.typ)
}

func buildSubforumJoins[Q dialect.Joinable](cols subforumColumns, typ string) subforumJoins[Q] {
	return subforumJoins[Q]{
		typ: typ,
		ModerationActions: modAs[Q, moderationActionColumns]{
			c: ModerationActionColumns,
			f: func(to moderationActionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ModerationActions.Name().As(to.Alias())).On(
						to.SubforumID.EQ(cols.SubforumID),
					))
				}

				return mods
			},
		},
		Posts: modAs[Q, postColumns]{
			c: PostColumns,
			f: func(to postColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Posts.Name().As(to.Alias())).On(
						to.SubforumID.EQ(cols.SubforumID),
					))
				}

				return mods
			},
		},
		SubforumModerators: modAs[Q, subforumModeratorColumns]{
			c: SubforumModeratorColumns,
			f: func(to subforumModeratorColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, SubforumModerators.Name().As(to.Alias())).On(
						to.SubforumID.EQ(cols.SubforumID),
					))
				}

				return mods
			},
		},
		SubforumSubscriptions: modAs[Q, subforumSubscriptionColumns]{
			c: SubforumSubscriptionColumns,
			f: func(to subforumSubscriptionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, SubforumSubscriptions.Name().As(to.Alias())).On(
						to.SubforumID.EQ(cols.SubforumID),
					))
				}

				return mods
			},
		},
		CreatedByUserUser: modAs[Q, userColumns]{
			c: UserColumns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.CreatedByUserID),
					))
				}

				return mods
			},
		},
		UserBans: modAs[Q, userBanColumns]{
			c: UserBanColumns,
			f: func(to userBanColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserBans.Name().As(to.Alias())).On(
						to.SubforumID.EQ(cols.SubforumID),
					))
				}

				return mods
			},
		},
	}
}

// ModerationActions starts a query for related objects on moderation_actions
func (o *Subforum) ModerationActions(mods ...bob.Mod[*dialect.SelectQuery]) ModerationActionsQuery {
	return ModerationActions.Query(append(mods,
		sm.Where(ModerationActionColumns.SubforumID.EQ(psql.Arg(o.SubforumID))),
	)...)
}

func (os SubforumSlice) ModerationActions(mods ...bob.Mod[*dialect.SelectQuery]) ModerationActionsQuery {
	pkSubforumID := make(pgtypes.Array[int32], len(os))
	for i, o := range os {
		pkSubforumID[i] = o.SubforumID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkSubforumID), "integer[]")),
	))

	return ModerationActions.Query(append(mods,
		sm.Where(psql.Group(ModerationActionColumns.SubforumID).OP("IN", PKArgExpr)),
	)...)
}

// Posts starts a query for related objects on posts
func (o *Subforum) Posts(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	return Posts.Query(append(mods,
		sm.Where(PostColumns.SubforumID.EQ(psql.Arg(o.SubforumID))),
	)...)
}

func (os SubforumSlice) Posts(mods ...bob.Mod[*dialect.SelectQuery]) PostsQuery {
	pkSubforumID := make(pgtypes.Array[int32], len(os))
	for i, o := range os {
		pkSubforumID[i] = o.SubforumID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkSubforumID), "integer[]")),
	))

	return Posts.Query(append(mods,
		sm.Where(psql.Group(PostColumns.SubforumID).OP("IN", PKArgExpr)),
	)...)
}

// SubforumModerators starts a query for related objects on subforum_moderators
func (o *Subforum) SubforumModerators(mods ...bob.Mod[*dialect.SelectQuery]) SubforumModeratorsQuery {
	return SubforumModerators.Query(append(mods,
		sm.Where(SubforumModeratorColumns.SubforumID.EQ(psql.Arg(o.SubforumID))),
	)...)
}

func (os SubforumSlice) SubforumModerators(mods ...bob.Mod[*dialect.SelectQuery]) SubforumModeratorsQuery {
	pkSubforumID := make(pgtypes.Array[int32], len(os))
	for i, o := range os {
		pkSubforumID[i] = o.SubforumID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkSubforumID), "integer[]")),
	))

	return SubforumModerators.Query(append(mods,
		sm.Where(psql.Group(SubforumModeratorColumns.SubforumID).OP("IN", PKArgExpr)),
	)...)
}

// SubforumSubscriptions starts a query for related objects on subforum_subscriptions
func (o *Subforum) SubforumSubscriptions(mods ...bob.Mod[*dialect.SelectQuery]) SubforumSubscriptionsQuery {
	return SubforumSubscriptions.Query(append(mods,
		sm.Where(SubforumSubscriptionColumns.SubforumID.EQ(psql.Arg(o.SubforumID))),
	)...)
}

func (os SubforumSlice) SubforumSubscriptions(mods ...bob.Mod[*dialect.SelectQuery]) SubforumSubscriptionsQuery {
	pkSubforumID := make(pgtypes.Array[int32], len(os))
	for i, o := range os {
		pkSubforumID[i] = o.SubforumID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkSubforumID), "integer[]")),
	))

	return SubforumSubscriptions.Query(append(mods,
		sm.Where(psql.Group(SubforumSubscriptionColumns.SubforumID).OP("IN", PKArgExpr)),
	)...)
}

// CreatedByUserUser starts a query for related objects on users
func (o *Subforum) CreatedByUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(UserColumns.UserID.EQ(psql.Arg(o.CreatedByUserID))),
	)...)
}

func (os SubforumSlice) CreatedByUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkCreatedByUserID := make(pgtypes.Array[sql.Null[int64]], len(os))
	for i, o := range os {
		pkCreatedByUserID[i] = o.CreatedByUserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkCreatedByUserID), "bigint[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(UserColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// UserBans starts a query for related objects on user_bans
func (o *Subforum) UserBans(mods ...bob.Mod[*dialect.SelectQuery]) UserBansQuery {
	return UserBans.Query(append(mods,
		sm.Where(UserBanColumns.SubforumID.EQ(psql.Arg(o.SubforumID))),
	)...)
}

func (os SubforumSlice) UserBans(mods ...bob.Mod[*dialect.SelectQuery]) UserBansQuery {
	pkSubforumID := make(pgtypes.Array[int32], len(os))
	for i, o := range os {
		pkSubforumID[i] = o.SubforumID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkSubforumID), "integer[]")),
	))

	return UserBans.Query(append(mods,
		sm.Where(psql.Group(UserBanColumns.SubforumID).OP("IN", PKArgExpr)),
	)...)
}

func (o *Subforum) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "ModerationActions":
		rels, ok := retrieved.(ModerationActionSlice)
		if !ok {
			return fmt.Errorf("subforum cannot load %T as %q", retrieved, name)
		}

		o.R.ModerationActions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Subforum = o
			}
		}
		return nil
	case "Posts":
		rels, ok := retrieved.(PostSlice)
		if !ok {
			return fmt.Errorf("subforum cannot load %T as %q", retrieved, name)
		}

		o.R.Posts = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Subforum = o
			}
		}
		return nil
	case "SubforumModerators":
		rels, ok := retrieved.(SubforumModeratorSlice)
		if !ok {
			return fmt.Errorf("subforum cannot load %T as %q", retrieved, name)
		}

		o.R.SubforumModerators = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Subforum = o
			}
		}
		return nil
	case "SubforumSubscriptions":
		rels, ok := retrieved.(SubforumSubscriptionSlice)
		if !ok {
			return fmt.Errorf("subforum cannot load %T as %q", retrieved, name)
		}

		o.R.SubforumSubscriptions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Subforum = o
			}
		}
		return nil
	case "CreatedByUserUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("subforum cannot load %T as %q", retrieved, name)
		}

		o.R.CreatedByUserUser = rel

		if rel != nil {
			rel.R.CreatedByUserSubforums = SubforumSlice{o}
		}
		return nil
	case "UserBans":
		rels, ok := retrieved.(UserBanSlice)
		if !ok {
			return fmt.Errorf("subforum cannot load %T as %q", retrieved, name)
		}

		o.R.UserBans = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Subforum = o
			}
		}
		return nil
	default:
		return fmt.Errorf("subforum has no relationship %q", name)
	}
}

type subforumPreloader struct {
	CreatedByUserUser func(...psql.PreloadOption) psql.Preloader
}

func buildSubforumPreloader() subforumPreloader {
	return subforumPreloader{
		CreatedByUserUser: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](orm.Relationship{
				Name: "CreatedByUserUser",
				Sides: []orm.RelSide{
					{
						From: TableNames.Subforums,
						To:   TableNames.Users,
						FromColumns: []string{
							ColumnNames.Subforums.CreatedByUserID,
						},
						ToColumns: []string{
							ColumnNames.Users.UserID,
						},
					},
				},
			}, Users.Columns().Names(), opts...)
		},
	}
}

type subforumThenLoader[Q orm.Loadable] struct {
	ModerationActions     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Posts                 func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	SubforumModerators    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	SubforumSubscriptions func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CreatedByUserUser     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	UserBans              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildSubforumThenLoader[Q orm.Loadable]() subforumThenLoader[Q] {
	type ModerationActionsLoadInterface interface {
		LoadModerationActions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PostsLoadInterface interface {
		LoadPosts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SubforumModeratorsLoadInterface interface {
		LoadSubforumModerators(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SubforumSubscriptionsLoadInterface interface {
		LoadSubforumSubscriptions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CreatedByUserUserLoadInterface interface {
		LoadCreatedByUserUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserBansLoadInterface interface {
		LoadUserBans(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return subforumThenLoader[Q]{
		ModerationActions: thenLoadBuilder[Q](
			"ModerationActions",
			func(ctx context.Context, exec bob.Executor, retrieved ModerationActionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadModerationActions(ctx, exec, mods...)
			},
		),
		Posts: thenLoadBuilder[Q](
			"Posts",
			func(ctx context.Context, exec bob.Executor, retrieved PostsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPosts(ctx, exec, mods...)
			},
		),
		SubforumModerators: thenLoadBuilder[Q](
			"SubforumModerators",
			func(ctx context.Context, exec bob.Executor, retrieved SubforumModeratorsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSubforumModerators(ctx, exec, mods...)
			},
		),
		SubforumSubscriptions: thenLoadBuilder[Q](
			"SubforumSubscriptions",
			func(ctx context.Context, exec bob.Executor, retrieved SubforumSubscriptionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSubforumSubscriptions(ctx, exec, mods...)
			},
		),
		CreatedByUserUser: thenLoadBuilder[Q](
			"CreatedByUserUser",
			func(ctx context.Context, exec bob.Executor, retrieved CreatedByUserUserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCreatedByUserUser(ctx, exec, mods...)
			},
		),
		UserBans: thenLoadBuilder[Q](
			"UserBans",
			func(ctx context.Context, exec bob.Executor, retrieved UserBansLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUserBans(ctx, exec, mods...)
			},
		),
	}
}

// LoadModerationActions loads the subforum's ModerationActions into the .R struct
func (o *Subforum) LoadModerationActions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ModerationActions = nil

	related, err := o.ModerationActions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Subforum = o
	}

	o.R.ModerationActions = related
	return nil
}

// LoadModerationActions loads the subforum's ModerationActions into the .R struct
func (os SubforumSlice) LoadModerationActions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	moderationActions, err := os.ModerationActions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ModerationActions = nil
	}

	for _, o := range os {
		for _, rel := range moderationActions {
			if o.SubforumID != rel.SubforumID.V {
				continue
			}

			rel.R.Subforum = o

			o.R.ModerationActions = append(o.R.ModerationActions, rel)
		}
	}

	return nil
}

// LoadPosts loads the subforum's Posts into the .R struct
func (o *Subforum) LoadPosts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Posts = nil

	related, err := o.Posts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Subforum = o
	}

	o.R.Posts = related
	return nil
}

// LoadPosts loads the subforum's Posts into the .R struct
func (os SubforumSlice) LoadPosts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	posts, err := os.Posts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Posts = nil
	}

	for _, o := range os {
		for _, rel := range posts {
			if o.SubforumID != rel.SubforumID {
				continue
			}

			rel.R.Subforum = o

			o.R.Posts = append(o.R.Posts, rel)
		}
	}

	return nil
}

// LoadSubforumModerators loads the subforum's SubforumModerators into the .R struct
func (o *Subforum) LoadSubforumModerators(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.SubforumModerators = nil

	related, err := o.SubforumModerators(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Subforum = o
	}

	o.R.SubforumModerators = related
	return nil
}

// LoadSubforumModerators loads the subforum's SubforumModerators into the .R struct
func (os SubforumSlice) LoadSubforumModerators(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	subforumModerators, err := os.SubforumModerators(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.SubforumModerators = nil
	}

	for _, o := range os {
		for _, rel := range subforumModerators {
			if o.SubforumID != rel.SubforumID {
				continue
			}

			rel.R.Subforum = o

			o.R.SubforumModerators = append(o.R.SubforumModerators, rel)
		}
	}

	return nil
}

// LoadSubforumSubscriptions loads the subforum's SubforumSubscriptions into the .R struct
func (o *Subforum) LoadSubforumSubscriptions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.SubforumSubscriptions = nil

	related, err := o.SubforumSubscriptions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Subforum = o
	}

	o.R.SubforumSubscriptions = related
	return nil
}

// LoadSubforumSubscriptions loads the subforum's SubforumSubscriptions into the .R struct
func (os SubforumSlice) LoadSubforumSubscriptions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	subforumSubscriptions, err := os.SubforumSubscriptions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.SubforumSubscriptions = nil
	}

	for _, o := range os {
		for _, rel := range subforumSubscriptions {
			if o.SubforumID != rel.SubforumID {
				continue
			}

			rel.R.Subforum = o

			o.R.SubforumSubscriptions = append(o.R.SubforumSubscriptions, rel)
		}
	}

	return nil
}

// LoadCreatedByUserUser loads the subforum's CreatedByUserUser into the .R struct
func (o *Subforum) LoadCreatedByUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CreatedByUserUser = nil

	related, err := o.CreatedByUserUser(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.CreatedByUserSubforums = SubforumSlice{o}

	o.R.CreatedByUserUser = related
	return nil
}

// LoadCreatedByUserUser loads the subforum's CreatedByUserUser into the .R struct
func (os SubforumSlice) LoadCreatedByUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.CreatedByUserUser(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range users {
			if o.CreatedByUserID.V != rel.UserID {
				continue
			}

			rel.R.CreatedByUserSubforums = append(rel.R.CreatedByUserSubforums, o)

			o.R.CreatedByUserUser = rel
			break
		}
	}

	return nil
}

// LoadUserBans loads the subforum's UserBans into the .R struct
func (o *Subforum) LoadUserBans(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.UserBans = nil

	related, err := o.UserBans(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Subforum = o
	}

	o.R.UserBans = related
	return nil
}

// LoadUserBans loads the subforum's UserBans into the .R struct
func (os SubforumSlice) LoadUserBans(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userBans, err := os.UserBans(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.UserBans = nil
	}

	for _, o := range os {
		for _, rel := range userBans {
			if o.SubforumID != rel.SubforumID {
				continue
			}

			rel.R.Subforum = o

			o.R.UserBans = append(o.R.UserBans, rel)
		}
	}

	return nil
}

func insertSubforumModerationActions0(ctx context.Context, exec bob.Executor, moderationActions1 []*ModerationActionSetter, subforum0 *Subforum) (ModerationActionSlice, error) {
	for i := range moderationActions1 {
		moderationActions1[i].SubforumID = func() *sql.Null[int32] {
			v := sql.Null[int32]{V: subforum0.SubforumID, Valid: true}
			return &v
		}()
	}

	ret, err := ModerationActions.Insert(bob.ToMods(moderationActions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertSubforumModerationActions0: %w", err)
	}

	return ret, nil
}

func attachSubforumModerationActions0(ctx context.Context, exec bob.Executor, count int, moderationActions1 ModerationActionSlice, subforum0 *Subforum) (ModerationActionSlice, error) {
	setter := &ModerationActionSetter{
		SubforumID: func() *sql.Null[int32] {
			v := sql.Null[int32]{V: subforum0.SubforumID, Valid: true}
			return &v
		}(),
	}

	err := moderationActions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachSubforumModerationActions0: %w", err)
	}

	return moderationActions1, nil
}

func (subforum0 *Subforum) InsertModerationActions(ctx context.Context, exec bob.Executor, related ...*ModerationActionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	moderationActions1, err := insertSubforumModerationActions0(ctx, exec, related, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.ModerationActions = append(subforum0.R.ModerationActions, moderationActions1...)

	for _, rel := range moderationActions1 {
		rel.R.Subforum = subforum0
	}
	return nil
}

func (subforum0 *Subforum) AttachModerationActions(ctx context.Context, exec bob.Executor, related ...*ModerationAction) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	moderationActions1 := ModerationActionSlice(related)

	_, err = attachSubforumModerationActions0(ctx, exec, len(related), moderationActions1, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.ModerationActions = append(subforum0.R.ModerationActions, moderationActions1...)

	for _, rel := range related {
		rel.R.Subforum = subforum0
	}

	return nil
}

func insertSubforumPosts0(ctx context.Context, exec bob.Executor, posts1 []*PostSetter, subforum0 *Subforum) (PostSlice, error) {
	for i := range posts1 {
		posts1[i].SubforumID = &subforum0.SubforumID
	}

	ret, err := Posts.Insert(bob.ToMods(posts1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertSubforumPosts0: %w", err)
	}

	return ret, nil
}

func attachSubforumPosts0(ctx context.Context, exec bob.Executor, count int, posts1 PostSlice, subforum0 *Subforum) (PostSlice, error) {
	setter := &PostSetter{
		SubforumID: &subforum0.SubforumID,
	}

	err := posts1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachSubforumPosts0: %w", err)
	}

	return posts1, nil
}

func (subforum0 *Subforum) InsertPosts(ctx context.Context, exec bob.Executor, related ...*PostSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	posts1, err := insertSubforumPosts0(ctx, exec, related, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.Posts = append(subforum0.R.Posts, posts1...)

	for _, rel := range posts1 {
		rel.R.Subforum = subforum0
	}
	return nil
}

func (subforum0 *Subforum) AttachPosts(ctx context.Context, exec bob.Executor, related ...*Post) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	posts1 := PostSlice(related)

	_, err = attachSubforumPosts0(ctx, exec, len(related), posts1, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.Posts = append(subforum0.R.Posts, posts1...)

	for _, rel := range related {
		rel.R.Subforum = subforum0
	}

	return nil
}

func insertSubforumSubforumModerators0(ctx context.Context, exec bob.Executor, subforumModerators1 []*SubforumModeratorSetter, subforum0 *Subforum) (SubforumModeratorSlice, error) {
	for i := range subforumModerators1 {
		subforumModerators1[i].SubforumID = &subforum0.SubforumID
	}

	ret, err := SubforumModerators.Insert(bob.ToMods(subforumModerators1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertSubforumSubforumModerators0: %w", err)
	}

	return ret, nil
}

func attachSubforumSubforumModerators0(ctx context.Context, exec bob.Executor, count int, subforumModerators1 SubforumModeratorSlice, subforum0 *Subforum) (SubforumModeratorSlice, error) {
	setter := &SubforumModeratorSetter{
		SubforumID: &subforum0.SubforumID,
	}

	err := subforumModerators1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachSubforumSubforumModerators0: %w", err)
	}

	return subforumModerators1, nil
}

func (subforum0 *Subforum) InsertSubforumModerators(ctx context.Context, exec bob.Executor, related ...*SubforumModeratorSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	subforumModerators1, err := insertSubforumSubforumModerators0(ctx, exec, related, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.SubforumModerators = append(subforum0.R.SubforumModerators, subforumModerators1...)

	for _, rel := range subforumModerators1 {
		rel.R.Subforum = subforum0
	}
	return nil
}

func (subforum0 *Subforum) AttachSubforumModerators(ctx context.Context, exec bob.Executor, related ...*SubforumModerator) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	subforumModerators1 := SubforumModeratorSlice(related)

	_, err = attachSubforumSubforumModerators0(ctx, exec, len(related), subforumModerators1, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.SubforumModerators = append(subforum0.R.SubforumModerators, subforumModerators1...)

	for _, rel := range related {
		rel.R.Subforum = subforum0
	}

	return nil
}

func insertSubforumSubforumSubscriptions0(ctx context.Context, exec bob.Executor, subforumSubscriptions1 []*SubforumSubscriptionSetter, subforum0 *Subforum) (SubforumSubscriptionSlice, error) {
	for i := range subforumSubscriptions1 {
		subforumSubscriptions1[i].SubforumID = &subforum0.SubforumID
	}

	ret, err := SubforumSubscriptions.Insert(bob.ToMods(subforumSubscriptions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertSubforumSubforumSubscriptions0: %w", err)
	}

	return ret, nil
}

func attachSubforumSubforumSubscriptions0(ctx context.Context, exec bob.Executor, count int, subforumSubscriptions1 SubforumSubscriptionSlice, subforum0 *Subforum) (SubforumSubscriptionSlice, error) {
	setter := &SubforumSubscriptionSetter{
		SubforumID: &subforum0.SubforumID,
	}

	err := subforumSubscriptions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachSubforumSubforumSubscriptions0: %w", err)
	}

	return subforumSubscriptions1, nil
}

func (subforum0 *Subforum) InsertSubforumSubscriptions(ctx context.Context, exec bob.Executor, related ...*SubforumSubscriptionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	subforumSubscriptions1, err := insertSubforumSubforumSubscriptions0(ctx, exec, related, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.SubforumSubscriptions = append(subforum0.R.SubforumSubscriptions, subforumSubscriptions1...)

	for _, rel := range subforumSubscriptions1 {
		rel.R.Subforum = subforum0
	}
	return nil
}

func (subforum0 *Subforum) AttachSubforumSubscriptions(ctx context.Context, exec bob.Executor, related ...*SubforumSubscription) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	subforumSubscriptions1 := SubforumSubscriptionSlice(related)

	_, err = attachSubforumSubforumSubscriptions0(ctx, exec, len(related), subforumSubscriptions1, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.SubforumSubscriptions = append(subforum0.R.SubforumSubscriptions, subforumSubscriptions1...)

	for _, rel := range related {
		rel.R.Subforum = subforum0
	}

	return nil
}

func attachSubforumCreatedByUserUser0(ctx context.Context, exec bob.Executor, count int, subforum0 *Subforum, user1 *User) (*Subforum, error) {
	setter := &SubforumSetter{
		CreatedByUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user1.UserID, Valid: true}
			return &v
		}(),
	}

	err := subforum0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachSubforumCreatedByUserUser0: %w", err)
	}

	return subforum0, nil
}

func (subforum0 *Subforum) InsertCreatedByUserUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachSubforumCreatedByUserUser0(ctx, exec, 1, subforum0, user1)
	if err != nil {
		return err
	}

	subforum0.R.CreatedByUserUser = user1

	user1.R.CreatedByUserSubforums = append(user1.R.CreatedByUserSubforums, subforum0)

	return nil
}

func (subforum0 *Subforum) AttachCreatedByUserUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachSubforumCreatedByUserUser0(ctx, exec, 1, subforum0, user1)
	if err != nil {
		return err
	}

	subforum0.R.CreatedByUserUser = user1

	user1.R.CreatedByUserSubforums = append(user1.R.CreatedByUserSubforums, subforum0)

	return nil
}

func insertSubforumUserBans0(ctx context.Context, exec bob.Executor, userBans1 []*UserBanSetter, subforum0 *Subforum) (UserBanSlice, error) {
	for i := range userBans1 {
		userBans1[i].SubforumID = &subforum0.SubforumID
	}

	ret, err := UserBans.Insert(bob.ToMods(userBans1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertSubforumUserBans0: %w", err)
	}

	return ret, nil
}

func attachSubforumUserBans0(ctx context.Context, exec bob.Executor, count int, userBans1 UserBanSlice, subforum0 *Subforum) (UserBanSlice, error) {
	setter := &UserBanSetter{
		SubforumID: &subforum0.SubforumID,
	}

	err := userBans1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachSubforumUserBans0: %w", err)
	}

	return userBans1, nil
}

func (subforum0 *Subforum) InsertUserBans(ctx context.Context, exec bob.Executor, related ...*UserBanSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	userBans1, err := insertSubforumUserBans0(ctx, exec, related, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.UserBans = append(subforum0.R.UserBans, userBans1...)

	for _, rel := range userBans1 {
		rel.R.Subforum = subforum0
	}
	return nil
}

func (subforum0 *Subforum) AttachUserBans(ctx context.Context, exec bob.Executor, related ...*UserBan) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	userBans1 := UserBanSlice(related)

	_, err = attachSubforumUserBans0(ctx, exec, len(related), userBans1, subforum0)
	if err != nil {
		return err
	}

	subforum0.R.UserBans = append(subforum0.R.UserBans, userBans1...)

	for _, rel := range related {
		rel.R.Subforum = subforum0
	}

	return nil
}
