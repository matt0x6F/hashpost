// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// CorrelationAudit is an object representing the database table.
type CorrelationAudit struct {
	AuditID              uuid.UUID                             `db:"audit_id,pk" scan:"audit_id" json:"audit_id"`
	UserID               int64                                 `db:"user_id" scan:"user_id" json:"user_id"`
	PseudonymID          string                                `db:"pseudonym_id" scan:"pseudonym_id" json:"pseudonym_id"`
	AdminUsername        string                                `db:"admin_username" scan:"admin_username" json:"admin_username"`
	RoleUsed             string                                `db:"role_used" scan:"role_used" json:"role_used"`
	RequestedPseudonym   string                                `db:"requested_pseudonym" scan:"requested_pseudonym" json:"requested_pseudonym"`
	RequestedFingerprint sql.Null[string]                      `db:"requested_fingerprint" scan:"requested_fingerprint" json:"requested_fingerprint"`
	Justification        string                                `db:"justification" scan:"justification" json:"justification"`
	CorrelationType      string                                `db:"correlation_type" scan:"correlation_type" json:"correlation_type"`
	CorrelationResult    sql.Null[types.JSON[json.RawMessage]] `db:"correlation_result" scan:"correlation_result" json:"correlation_result"`
	Timestamp            sql.Null[time.Time]                   `db:"timestamp" scan:"timestamp" json:"timestamp"`
	LegalBasis           sql.Null[string]                      `db:"legal_basis" scan:"legal_basis" json:"legal_basis"`
	IncidentID           sql.Null[string]                      `db:"incident_id" scan:"incident_id" json:"incident_id"`
	RequestSource        sql.Null[string]                      `db:"request_source" scan:"request_source" json:"request_source"`
	IPAddress            sql.Null[pgtypes.Inet]                `db:"ip_address" scan:"ip_address" json:"ip_address"`
	UserAgent            sql.Null[string]                      `db:"user_agent" scan:"user_agent" json:"user_agent"`

	R correlationAuditR `db:"-" scan:"rel" json:"rel"`
}

// CorrelationAuditSlice is an alias for a slice of pointers to CorrelationAudit.
// This should almost always be used instead of []*CorrelationAudit.
type CorrelationAuditSlice []*CorrelationAudit

// CorrelationAudits contains methods to work with the correlation_audit table
var CorrelationAudits = psql.NewTablex[*CorrelationAudit, CorrelationAuditSlice, *CorrelationAuditSetter]("", "correlation_audit")

// CorrelationAuditsQuery is a query on the correlation_audit table
type CorrelationAuditsQuery = *psql.ViewQuery[*CorrelationAudit, CorrelationAuditSlice]

// correlationAuditR is where relationships are stored.
type correlationAuditR struct {
	AuditComplianceCorrelations ComplianceCorrelationSlice `scan:"AuditComplianceCorrelations" json:"AuditComplianceCorrelations"` // compliance_correlations.compliance_correlations_audit_id_fkey
	Pseudonym                   *Pseudonym                 `scan:"Pseudonym" json:"Pseudonym"`                                     // correlation_audit.correlation_audit_pseudonym_id_fkey
	User                        *User                      `scan:"User" json:"User"`                                               // correlation_audit.correlation_audit_user_id_fkey
}

type correlationAuditColumnNames struct {
	AuditID              string
	UserID               string
	PseudonymID          string
	AdminUsername        string
	RoleUsed             string
	RequestedPseudonym   string
	RequestedFingerprint string
	Justification        string
	CorrelationType      string
	CorrelationResult    string
	Timestamp            string
	LegalBasis           string
	IncidentID           string
	RequestSource        string
	IPAddress            string
	UserAgent            string
}

var CorrelationAuditColumns = buildCorrelationAuditColumns("correlation_audit")

type correlationAuditColumns struct {
	tableAlias           string
	AuditID              psql.Expression
	UserID               psql.Expression
	PseudonymID          psql.Expression
	AdminUsername        psql.Expression
	RoleUsed             psql.Expression
	RequestedPseudonym   psql.Expression
	RequestedFingerprint psql.Expression
	Justification        psql.Expression
	CorrelationType      psql.Expression
	CorrelationResult    psql.Expression
	Timestamp            psql.Expression
	LegalBasis           psql.Expression
	IncidentID           psql.Expression
	RequestSource        psql.Expression
	IPAddress            psql.Expression
	UserAgent            psql.Expression
}

func (c correlationAuditColumns) Alias() string {
	return c.tableAlias
}

func (correlationAuditColumns) AliasedAs(alias string) correlationAuditColumns {
	return buildCorrelationAuditColumns(alias)
}

func buildCorrelationAuditColumns(alias string) correlationAuditColumns {
	return correlationAuditColumns{
		tableAlias:           alias,
		AuditID:              psql.Quote(alias, "audit_id"),
		UserID:               psql.Quote(alias, "user_id"),
		PseudonymID:          psql.Quote(alias, "pseudonym_id"),
		AdminUsername:        psql.Quote(alias, "admin_username"),
		RoleUsed:             psql.Quote(alias, "role_used"),
		RequestedPseudonym:   psql.Quote(alias, "requested_pseudonym"),
		RequestedFingerprint: psql.Quote(alias, "requested_fingerprint"),
		Justification:        psql.Quote(alias, "justification"),
		CorrelationType:      psql.Quote(alias, "correlation_type"),
		CorrelationResult:    psql.Quote(alias, "correlation_result"),
		Timestamp:            psql.Quote(alias, "timestamp"),
		LegalBasis:           psql.Quote(alias, "legal_basis"),
		IncidentID:           psql.Quote(alias, "incident_id"),
		RequestSource:        psql.Quote(alias, "request_source"),
		IPAddress:            psql.Quote(alias, "ip_address"),
		UserAgent:            psql.Quote(alias, "user_agent"),
	}
}

type correlationAuditWhere[Q psql.Filterable] struct {
	AuditID              psql.WhereMod[Q, uuid.UUID]
	UserID               psql.WhereMod[Q, int64]
	PseudonymID          psql.WhereMod[Q, string]
	AdminUsername        psql.WhereMod[Q, string]
	RoleUsed             psql.WhereMod[Q, string]
	RequestedPseudonym   psql.WhereMod[Q, string]
	RequestedFingerprint psql.WhereNullMod[Q, string]
	Justification        psql.WhereMod[Q, string]
	CorrelationType      psql.WhereMod[Q, string]
	CorrelationResult    psql.WhereNullMod[Q, types.JSON[json.RawMessage]]
	Timestamp            psql.WhereNullMod[Q, time.Time]
	LegalBasis           psql.WhereNullMod[Q, string]
	IncidentID           psql.WhereNullMod[Q, string]
	RequestSource        psql.WhereNullMod[Q, string]
	IPAddress            psql.WhereNullMod[Q, pgtypes.Inet]
	UserAgent            psql.WhereNullMod[Q, string]
}

func (correlationAuditWhere[Q]) AliasedAs(alias string) correlationAuditWhere[Q] {
	return buildCorrelationAuditWhere[Q](buildCorrelationAuditColumns(alias))
}

func buildCorrelationAuditWhere[Q psql.Filterable](cols correlationAuditColumns) correlationAuditWhere[Q] {
	return correlationAuditWhere[Q]{
		AuditID:              psql.Where[Q, uuid.UUID](cols.AuditID),
		UserID:               psql.Where[Q, int64](cols.UserID),
		PseudonymID:          psql.Where[Q, string](cols.PseudonymID),
		AdminUsername:        psql.Where[Q, string](cols.AdminUsername),
		RoleUsed:             psql.Where[Q, string](cols.RoleUsed),
		RequestedPseudonym:   psql.Where[Q, string](cols.RequestedPseudonym),
		RequestedFingerprint: psql.WhereNull[Q, string](cols.RequestedFingerprint),
		Justification:        psql.Where[Q, string](cols.Justification),
		CorrelationType:      psql.Where[Q, string](cols.CorrelationType),
		CorrelationResult:    psql.WhereNull[Q, types.JSON[json.RawMessage]](cols.CorrelationResult),
		Timestamp:            psql.WhereNull[Q, time.Time](cols.Timestamp),
		LegalBasis:           psql.WhereNull[Q, string](cols.LegalBasis),
		IncidentID:           psql.WhereNull[Q, string](cols.IncidentID),
		RequestSource:        psql.WhereNull[Q, string](cols.RequestSource),
		IPAddress:            psql.WhereNull[Q, pgtypes.Inet](cols.IPAddress),
		UserAgent:            psql.WhereNull[Q, string](cols.UserAgent),
	}
}

var CorrelationAuditErrors = &correlationAuditErrors{
	ErrUniqueCorrelationAuditPkey: &UniqueConstraintError{
		schema:  "",
		table:   "correlation_audit",
		columns: []string{"audit_id"},
		s:       "correlation_audit_pkey",
	},
}

type correlationAuditErrors struct {
	ErrUniqueCorrelationAuditPkey *UniqueConstraintError
}

// CorrelationAuditSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type CorrelationAuditSetter struct {
	AuditID              *uuid.UUID                             `db:"audit_id,pk" scan:"audit_id" json:"audit_id"`
	UserID               *int64                                 `db:"user_id" scan:"user_id" json:"user_id"`
	PseudonymID          *string                                `db:"pseudonym_id" scan:"pseudonym_id" json:"pseudonym_id"`
	AdminUsername        *string                                `db:"admin_username" scan:"admin_username" json:"admin_username"`
	RoleUsed             *string                                `db:"role_used" scan:"role_used" json:"role_used"`
	RequestedPseudonym   *string                                `db:"requested_pseudonym" scan:"requested_pseudonym" json:"requested_pseudonym"`
	RequestedFingerprint *sql.Null[string]                      `db:"requested_fingerprint" scan:"requested_fingerprint" json:"requested_fingerprint"`
	Justification        *string                                `db:"justification" scan:"justification" json:"justification"`
	CorrelationType      *string                                `db:"correlation_type" scan:"correlation_type" json:"correlation_type"`
	CorrelationResult    *sql.Null[types.JSON[json.RawMessage]] `db:"correlation_result" scan:"correlation_result" json:"correlation_result"`
	Timestamp            *sql.Null[time.Time]                   `db:"timestamp" scan:"timestamp" json:"timestamp"`
	LegalBasis           *sql.Null[string]                      `db:"legal_basis" scan:"legal_basis" json:"legal_basis"`
	IncidentID           *sql.Null[string]                      `db:"incident_id" scan:"incident_id" json:"incident_id"`
	RequestSource        *sql.Null[string]                      `db:"request_source" scan:"request_source" json:"request_source"`
	IPAddress            *sql.Null[pgtypes.Inet]                `db:"ip_address" scan:"ip_address" json:"ip_address"`
	UserAgent            *sql.Null[string]                      `db:"user_agent" scan:"user_agent" json:"user_agent"`
}

func (s CorrelationAuditSetter) SetColumns() []string {
	vals := make([]string, 0, 16)
	if s.AuditID != nil {
		vals = append(vals, "audit_id")
	}

	if s.UserID != nil {
		vals = append(vals, "user_id")
	}

	if s.PseudonymID != nil {
		vals = append(vals, "pseudonym_id")
	}

	if s.AdminUsername != nil {
		vals = append(vals, "admin_username")
	}

	if s.RoleUsed != nil {
		vals = append(vals, "role_used")
	}

	if s.RequestedPseudonym != nil {
		vals = append(vals, "requested_pseudonym")
	}

	if s.RequestedFingerprint != nil {
		vals = append(vals, "requested_fingerprint")
	}

	if s.Justification != nil {
		vals = append(vals, "justification")
	}

	if s.CorrelationType != nil {
		vals = append(vals, "correlation_type")
	}

	if s.CorrelationResult != nil {
		vals = append(vals, "correlation_result")
	}

	if s.Timestamp != nil {
		vals = append(vals, "timestamp")
	}

	if s.LegalBasis != nil {
		vals = append(vals, "legal_basis")
	}

	if s.IncidentID != nil {
		vals = append(vals, "incident_id")
	}

	if s.RequestSource != nil {
		vals = append(vals, "request_source")
	}

	if s.IPAddress != nil {
		vals = append(vals, "ip_address")
	}

	if s.UserAgent != nil {
		vals = append(vals, "user_agent")
	}

	return vals
}

func (s CorrelationAuditSetter) Overwrite(t *CorrelationAudit) {
	if s.AuditID != nil {
		t.AuditID = *s.AuditID
	}
	if s.UserID != nil {
		t.UserID = *s.UserID
	}
	if s.PseudonymID != nil {
		t.PseudonymID = *s.PseudonymID
	}
	if s.AdminUsername != nil {
		t.AdminUsername = *s.AdminUsername
	}
	if s.RoleUsed != nil {
		t.RoleUsed = *s.RoleUsed
	}
	if s.RequestedPseudonym != nil {
		t.RequestedPseudonym = *s.RequestedPseudonym
	}
	if s.RequestedFingerprint != nil {
		t.RequestedFingerprint = *s.RequestedFingerprint
	}
	if s.Justification != nil {
		t.Justification = *s.Justification
	}
	if s.CorrelationType != nil {
		t.CorrelationType = *s.CorrelationType
	}
	if s.CorrelationResult != nil {
		t.CorrelationResult = *s.CorrelationResult
	}
	if s.Timestamp != nil {
		t.Timestamp = *s.Timestamp
	}
	if s.LegalBasis != nil {
		t.LegalBasis = *s.LegalBasis
	}
	if s.IncidentID != nil {
		t.IncidentID = *s.IncidentID
	}
	if s.RequestSource != nil {
		t.RequestSource = *s.RequestSource
	}
	if s.IPAddress != nil {
		t.IPAddress = *s.IPAddress
	}
	if s.UserAgent != nil {
		t.UserAgent = *s.UserAgent
	}
}

func (s *CorrelationAuditSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return CorrelationAudits.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 16)
		if s.AuditID != nil {
			vals[0] = psql.Arg(*s.AuditID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.UserID != nil {
			vals[1] = psql.Arg(*s.UserID)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.PseudonymID != nil {
			vals[2] = psql.Arg(*s.PseudonymID)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.AdminUsername != nil {
			vals[3] = psql.Arg(*s.AdminUsername)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.RoleUsed != nil {
			vals[4] = psql.Arg(*s.RoleUsed)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.RequestedPseudonym != nil {
			vals[5] = psql.Arg(*s.RequestedPseudonym)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.RequestedFingerprint != nil {
			vals[6] = psql.Arg(*s.RequestedFingerprint)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.Justification != nil {
			vals[7] = psql.Arg(*s.Justification)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.CorrelationType != nil {
			vals[8] = psql.Arg(*s.CorrelationType)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.CorrelationResult != nil {
			vals[9] = psql.Arg(*s.CorrelationResult)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.Timestamp != nil {
			vals[10] = psql.Arg(*s.Timestamp)
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.LegalBasis != nil {
			vals[11] = psql.Arg(*s.LegalBasis)
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.IncidentID != nil {
			vals[12] = psql.Arg(*s.IncidentID)
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.RequestSource != nil {
			vals[13] = psql.Arg(*s.RequestSource)
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.IPAddress != nil {
			vals[14] = psql.Arg(*s.IPAddress)
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.UserAgent != nil {
			vals[15] = psql.Arg(*s.UserAgent)
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s CorrelationAuditSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s CorrelationAuditSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 16)

	if s.AuditID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "audit_id")...),
			psql.Arg(s.AuditID),
		}})
	}

	if s.UserID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "user_id")...),
			psql.Arg(s.UserID),
		}})
	}

	if s.PseudonymID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "pseudonym_id")...),
			psql.Arg(s.PseudonymID),
		}})
	}

	if s.AdminUsername != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "admin_username")...),
			psql.Arg(s.AdminUsername),
		}})
	}

	if s.RoleUsed != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "role_used")...),
			psql.Arg(s.RoleUsed),
		}})
	}

	if s.RequestedPseudonym != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "requested_pseudonym")...),
			psql.Arg(s.RequestedPseudonym),
		}})
	}

	if s.RequestedFingerprint != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "requested_fingerprint")...),
			psql.Arg(s.RequestedFingerprint),
		}})
	}

	if s.Justification != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "justification")...),
			psql.Arg(s.Justification),
		}})
	}

	if s.CorrelationType != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "correlation_type")...),
			psql.Arg(s.CorrelationType),
		}})
	}

	if s.CorrelationResult != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "correlation_result")...),
			psql.Arg(s.CorrelationResult),
		}})
	}

	if s.Timestamp != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "timestamp")...),
			psql.Arg(s.Timestamp),
		}})
	}

	if s.LegalBasis != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "legal_basis")...),
			psql.Arg(s.LegalBasis),
		}})
	}

	if s.IncidentID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "incident_id")...),
			psql.Arg(s.IncidentID),
		}})
	}

	if s.RequestSource != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "request_source")...),
			psql.Arg(s.RequestSource),
		}})
	}

	if s.IPAddress != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "ip_address")...),
			psql.Arg(s.IPAddress),
		}})
	}

	if s.UserAgent != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "user_agent")...),
			psql.Arg(s.UserAgent),
		}})
	}

	return exprs
}

// FindCorrelationAudit retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindCorrelationAudit(ctx context.Context, exec bob.Executor, AuditIDPK uuid.UUID, cols ...string) (*CorrelationAudit, error) {
	if len(cols) == 0 {
		return CorrelationAudits.Query(
			SelectWhere.CorrelationAudits.AuditID.EQ(AuditIDPK),
		).One(ctx, exec)
	}

	return CorrelationAudits.Query(
		SelectWhere.CorrelationAudits.AuditID.EQ(AuditIDPK),
		sm.Columns(CorrelationAudits.Columns().Only(cols...)),
	).One(ctx, exec)
}

// CorrelationAuditExists checks the presence of a single record by primary key
func CorrelationAuditExists(ctx context.Context, exec bob.Executor, AuditIDPK uuid.UUID) (bool, error) {
	return CorrelationAudits.Query(
		SelectWhere.CorrelationAudits.AuditID.EQ(AuditIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after CorrelationAudit is retrieved from the database
func (o *CorrelationAudit) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = CorrelationAudits.AfterSelectHooks.RunHooks(ctx, exec, CorrelationAuditSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = CorrelationAudits.AfterInsertHooks.RunHooks(ctx, exec, CorrelationAuditSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = CorrelationAudits.AfterUpdateHooks.RunHooks(ctx, exec, CorrelationAuditSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = CorrelationAudits.AfterDeleteHooks.RunHooks(ctx, exec, CorrelationAuditSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the CorrelationAudit
func (o *CorrelationAudit) primaryKeyVals() bob.Expression {
	return psql.Arg(o.AuditID)
}

func (o *CorrelationAudit) pkEQ() dialect.Expression {
	return psql.Quote("correlation_audit", "audit_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the CorrelationAudit
func (o *CorrelationAudit) Update(ctx context.Context, exec bob.Executor, s *CorrelationAuditSetter) error {
	v, err := CorrelationAudits.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single CorrelationAudit record with an executor
func (o *CorrelationAudit) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := CorrelationAudits.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the CorrelationAudit using the executor
func (o *CorrelationAudit) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := CorrelationAudits.Query(
		SelectWhere.CorrelationAudits.AuditID.EQ(o.AuditID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after CorrelationAuditSlice is retrieved from the database
func (o CorrelationAuditSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = CorrelationAudits.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = CorrelationAudits.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = CorrelationAudits.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = CorrelationAudits.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o CorrelationAuditSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("correlation_audit", "audit_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o CorrelationAuditSlice) copyMatchingRows(from ...*CorrelationAudit) {
	for i, old := range o {
		for _, new := range from {
			if new.AuditID != old.AuditID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o CorrelationAuditSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return CorrelationAudits.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *CorrelationAudit:
				o.copyMatchingRows(retrieved)
			case []*CorrelationAudit:
				o.copyMatchingRows(retrieved...)
			case CorrelationAuditSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a CorrelationAudit or a slice of CorrelationAudit
				// then run the AfterUpdateHooks on the slice
				_, err = CorrelationAudits.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o CorrelationAuditSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return CorrelationAudits.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *CorrelationAudit:
				o.copyMatchingRows(retrieved)
			case []*CorrelationAudit:
				o.copyMatchingRows(retrieved...)
			case CorrelationAuditSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a CorrelationAudit or a slice of CorrelationAudit
				// then run the AfterDeleteHooks on the slice
				_, err = CorrelationAudits.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o CorrelationAuditSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals CorrelationAuditSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := CorrelationAudits.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o CorrelationAuditSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := CorrelationAudits.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o CorrelationAuditSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := CorrelationAudits.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type correlationAuditJoins[Q dialect.Joinable] struct {
	typ                         string
	AuditComplianceCorrelations modAs[Q, complianceCorrelationColumns]
	Pseudonym                   modAs[Q, pseudonymColumns]
	User                        modAs[Q, userColumns]
}

func (j correlationAuditJoins[Q]) aliasedAs(alias string) correlationAuditJoins[Q] {
	return buildCorrelationAuditJoins[Q](buildCorrelationAuditColumns(alias), j.typ)
}

func buildCorrelationAuditJoins[Q dialect.Joinable](cols correlationAuditColumns, typ string) correlationAuditJoins[Q] {
	return correlationAuditJoins[Q]{
		typ: typ,
		AuditComplianceCorrelations: modAs[Q, complianceCorrelationColumns]{
			c: ComplianceCorrelationColumns,
			f: func(to complianceCorrelationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ComplianceCorrelations.Name().As(to.Alias())).On(
						to.AuditID.EQ(cols.AuditID),
					))
				}

				return mods
			},
		},
		Pseudonym: modAs[Q, pseudonymColumns]{
			c: PseudonymColumns,
			f: func(to pseudonymColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pseudonyms.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		User: modAs[Q, userColumns]{
			c: UserColumns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
	}
}

// AuditComplianceCorrelations starts a query for related objects on compliance_correlations
func (o *CorrelationAudit) AuditComplianceCorrelations(mods ...bob.Mod[*dialect.SelectQuery]) ComplianceCorrelationsQuery {
	return ComplianceCorrelations.Query(append(mods,
		sm.Where(ComplianceCorrelationColumns.AuditID.EQ(psql.Arg(o.AuditID))),
	)...)
}

func (os CorrelationAuditSlice) AuditComplianceCorrelations(mods ...bob.Mod[*dialect.SelectQuery]) ComplianceCorrelationsQuery {
	pkAuditID := make(pgtypes.Array[uuid.UUID], len(os))
	for i, o := range os {
		pkAuditID[i] = o.AuditID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkAuditID), "uuid[]")),
	))

	return ComplianceCorrelations.Query(append(mods,
		sm.Where(psql.Group(ComplianceCorrelationColumns.AuditID).OP("IN", PKArgExpr)),
	)...)
}

// Pseudonym starts a query for related objects on pseudonyms
func (o *CorrelationAudit) Pseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	return Pseudonyms.Query(append(mods,
		sm.Where(PseudonymColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os CorrelationAuditSlice) Pseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Pseudonyms.Query(append(mods,
		sm.Where(psql.Group(PseudonymColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// User starts a query for related objects on users
func (o *CorrelationAudit) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(UserColumns.UserID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os CorrelationAuditSlice) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkUserID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkUserID[i] = o.UserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(UserColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

func (o *CorrelationAudit) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "AuditComplianceCorrelations":
		rels, ok := retrieved.(ComplianceCorrelationSlice)
		if !ok {
			return fmt.Errorf("correlationAudit cannot load %T as %q", retrieved, name)
		}

		o.R.AuditComplianceCorrelations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.AuditCorrelationAudit = o
			}
		}
		return nil
	case "Pseudonym":
		rel, ok := retrieved.(*Pseudonym)
		if !ok {
			return fmt.Errorf("correlationAudit cannot load %T as %q", retrieved, name)
		}

		o.R.Pseudonym = rel

		if rel != nil {
			rel.R.CorrelationAudits = CorrelationAuditSlice{o}
		}
		return nil
	case "User":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("correlationAudit cannot load %T as %q", retrieved, name)
		}

		o.R.User = rel

		if rel != nil {
			rel.R.CorrelationAudits = CorrelationAuditSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("correlationAudit has no relationship %q", name)
	}
}

type correlationAuditPreloader struct {
	Pseudonym func(...psql.PreloadOption) psql.Preloader
	User      func(...psql.PreloadOption) psql.Preloader
}

func buildCorrelationAuditPreloader() correlationAuditPreloader {
	return correlationAuditPreloader{
		Pseudonym: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Pseudonym, PseudonymSlice](orm.Relationship{
				Name: "Pseudonym",
				Sides: []orm.RelSide{
					{
						From: TableNames.CorrelationAudits,
						To:   TableNames.Pseudonyms,
						FromColumns: []string{
							ColumnNames.CorrelationAudits.PseudonymID,
						},
						ToColumns: []string{
							ColumnNames.Pseudonyms.PseudonymID,
						},
					},
				},
			}, Pseudonyms.Columns().Names(), opts...)
		},
		User: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](orm.Relationship{
				Name: "User",
				Sides: []orm.RelSide{
					{
						From: TableNames.CorrelationAudits,
						To:   TableNames.Users,
						FromColumns: []string{
							ColumnNames.CorrelationAudits.UserID,
						},
						ToColumns: []string{
							ColumnNames.Users.UserID,
						},
					},
				},
			}, Users.Columns().Names(), opts...)
		},
	}
}

type correlationAuditThenLoader[Q orm.Loadable] struct {
	AuditComplianceCorrelations func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pseudonym                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	User                        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildCorrelationAuditThenLoader[Q orm.Loadable]() correlationAuditThenLoader[Q] {
	type AuditComplianceCorrelationsLoadInterface interface {
		LoadAuditComplianceCorrelations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PseudonymLoadInterface interface {
		LoadPseudonym(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserLoadInterface interface {
		LoadUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return correlationAuditThenLoader[Q]{
		AuditComplianceCorrelations: thenLoadBuilder[Q](
			"AuditComplianceCorrelations",
			func(ctx context.Context, exec bob.Executor, retrieved AuditComplianceCorrelationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadAuditComplianceCorrelations(ctx, exec, mods...)
			},
		),
		Pseudonym: thenLoadBuilder[Q](
			"Pseudonym",
			func(ctx context.Context, exec bob.Executor, retrieved PseudonymLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPseudonym(ctx, exec, mods...)
			},
		),
		User: thenLoadBuilder[Q](
			"User",
			func(ctx context.Context, exec bob.Executor, retrieved UserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadAuditComplianceCorrelations loads the correlationAudit's AuditComplianceCorrelations into the .R struct
func (o *CorrelationAudit) LoadAuditComplianceCorrelations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.AuditComplianceCorrelations = nil

	related, err := o.AuditComplianceCorrelations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.AuditCorrelationAudit = o
	}

	o.R.AuditComplianceCorrelations = related
	return nil
}

// LoadAuditComplianceCorrelations loads the correlationAudit's AuditComplianceCorrelations into the .R struct
func (os CorrelationAuditSlice) LoadAuditComplianceCorrelations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	complianceCorrelations, err := os.AuditComplianceCorrelations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.AuditComplianceCorrelations = nil
	}

	for _, o := range os {
		for _, rel := range complianceCorrelations {
			if o.AuditID != rel.AuditID {
				continue
			}

			rel.R.AuditCorrelationAudit = o

			o.R.AuditComplianceCorrelations = append(o.R.AuditComplianceCorrelations, rel)
		}
	}

	return nil
}

// LoadPseudonym loads the correlationAudit's Pseudonym into the .R struct
func (o *CorrelationAudit) LoadPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Pseudonym = nil

	related, err := o.Pseudonym(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.CorrelationAudits = CorrelationAuditSlice{o}

	o.R.Pseudonym = related
	return nil
}

// LoadPseudonym loads the correlationAudit's Pseudonym into the .R struct
func (os CorrelationAuditSlice) LoadPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pseudonyms, err := os.Pseudonym(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range pseudonyms {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.CorrelationAudits = append(rel.R.CorrelationAudits, o)

			o.R.Pseudonym = rel
			break
		}
	}

	return nil
}

// LoadUser loads the correlationAudit's User into the .R struct
func (o *CorrelationAudit) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.User = nil

	related, err := o.User(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.CorrelationAudits = CorrelationAuditSlice{o}

	o.R.User = related
	return nil
}

// LoadUser loads the correlationAudit's User into the .R struct
func (os CorrelationAuditSlice) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.User(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range users {
			if o.UserID != rel.UserID {
				continue
			}

			rel.R.CorrelationAudits = append(rel.R.CorrelationAudits, o)

			o.R.User = rel
			break
		}
	}

	return nil
}

func insertCorrelationAuditAuditComplianceCorrelations0(ctx context.Context, exec bob.Executor, complianceCorrelations1 []*ComplianceCorrelationSetter, correlationAudit0 *CorrelationAudit) (ComplianceCorrelationSlice, error) {
	for i := range complianceCorrelations1 {
		complianceCorrelations1[i].AuditID = &correlationAudit0.AuditID
	}

	ret, err := ComplianceCorrelations.Insert(bob.ToMods(complianceCorrelations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertCorrelationAuditAuditComplianceCorrelations0: %w", err)
	}

	return ret, nil
}

func attachCorrelationAuditAuditComplianceCorrelations0(ctx context.Context, exec bob.Executor, count int, complianceCorrelations1 ComplianceCorrelationSlice, correlationAudit0 *CorrelationAudit) (ComplianceCorrelationSlice, error) {
	setter := &ComplianceCorrelationSetter{
		AuditID: &correlationAudit0.AuditID,
	}

	err := complianceCorrelations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachCorrelationAuditAuditComplianceCorrelations0: %w", err)
	}

	return complianceCorrelations1, nil
}

func (correlationAudit0 *CorrelationAudit) InsertAuditComplianceCorrelations(ctx context.Context, exec bob.Executor, related ...*ComplianceCorrelationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	complianceCorrelations1, err := insertCorrelationAuditAuditComplianceCorrelations0(ctx, exec, related, correlationAudit0)
	if err != nil {
		return err
	}

	correlationAudit0.R.AuditComplianceCorrelations = append(correlationAudit0.R.AuditComplianceCorrelations, complianceCorrelations1...)

	for _, rel := range complianceCorrelations1 {
		rel.R.AuditCorrelationAudit = correlationAudit0
	}
	return nil
}

func (correlationAudit0 *CorrelationAudit) AttachAuditComplianceCorrelations(ctx context.Context, exec bob.Executor, related ...*ComplianceCorrelation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	complianceCorrelations1 := ComplianceCorrelationSlice(related)

	_, err = attachCorrelationAuditAuditComplianceCorrelations0(ctx, exec, len(related), complianceCorrelations1, correlationAudit0)
	if err != nil {
		return err
	}

	correlationAudit0.R.AuditComplianceCorrelations = append(correlationAudit0.R.AuditComplianceCorrelations, complianceCorrelations1...)

	for _, rel := range related {
		rel.R.AuditCorrelationAudit = correlationAudit0
	}

	return nil
}

func attachCorrelationAuditPseudonym0(ctx context.Context, exec bob.Executor, count int, correlationAudit0 *CorrelationAudit, pseudonym1 *Pseudonym) (*CorrelationAudit, error) {
	setter := &CorrelationAuditSetter{
		PseudonymID: &pseudonym1.PseudonymID,
	}

	err := correlationAudit0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachCorrelationAuditPseudonym0: %w", err)
	}

	return correlationAudit0, nil
}

func (correlationAudit0 *CorrelationAudit) InsertPseudonym(ctx context.Context, exec bob.Executor, related *PseudonymSetter) error {
	pseudonym1, err := Pseudonyms.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachCorrelationAuditPseudonym0(ctx, exec, 1, correlationAudit0, pseudonym1)
	if err != nil {
		return err
	}

	correlationAudit0.R.Pseudonym = pseudonym1

	pseudonym1.R.CorrelationAudits = append(pseudonym1.R.CorrelationAudits, correlationAudit0)

	return nil
}

func (correlationAudit0 *CorrelationAudit) AttachPseudonym(ctx context.Context, exec bob.Executor, pseudonym1 *Pseudonym) error {
	var err error

	_, err = attachCorrelationAuditPseudonym0(ctx, exec, 1, correlationAudit0, pseudonym1)
	if err != nil {
		return err
	}

	correlationAudit0.R.Pseudonym = pseudonym1

	pseudonym1.R.CorrelationAudits = append(pseudonym1.R.CorrelationAudits, correlationAudit0)

	return nil
}

func attachCorrelationAuditUser0(ctx context.Context, exec bob.Executor, count int, correlationAudit0 *CorrelationAudit, user1 *User) (*CorrelationAudit, error) {
	setter := &CorrelationAuditSetter{
		UserID: &user1.UserID,
	}

	err := correlationAudit0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachCorrelationAuditUser0: %w", err)
	}

	return correlationAudit0, nil
}

func (correlationAudit0 *CorrelationAudit) InsertUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachCorrelationAuditUser0(ctx, exec, 1, correlationAudit0, user1)
	if err != nil {
		return err
	}

	correlationAudit0.R.User = user1

	user1.R.CorrelationAudits = append(user1.R.CorrelationAudits, correlationAudit0)

	return nil
}

func (correlationAudit0 *CorrelationAudit) AttachUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachCorrelationAuditUser0(ctx, exec, 1, correlationAudit0, user1)
	if err != nil {
		return err
	}

	correlationAudit0.R.User = user1

	user1.R.CorrelationAudits = append(user1.R.CorrelationAudits, correlationAudit0)

	return nil
}
