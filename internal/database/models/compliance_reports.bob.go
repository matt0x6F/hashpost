// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// ComplianceReport is an object representing the database table.
type ComplianceReport struct {
	ReportID            uuid.UUID           `db:"report_id,pk" scan:"report_id" json:"report_id"`
	ReportType          string              `db:"report_type" scan:"report_type" json:"report_type"`
	RequestingAuthority sql.Null[string]    `db:"requesting_authority" scan:"requesting_authority" json:"requesting_authority"`
	RequestID           sql.Null[string]    `db:"request_id" scan:"request_id" json:"request_id"`
	RequestDate         time.Time           `db:"request_date" scan:"request_date" json:"request_date"`
	DueDate             sql.Null[time.Time] `db:"due_date" scan:"due_date" json:"due_date"`
	Status              sql.Null[string]    `db:"status" scan:"status" json:"status"`
	ScopeDescription    string              `db:"scope_description" scan:"scope_description" json:"scope_description"`
	LegalBasis          sql.Null[string]    `db:"legal_basis" scan:"legal_basis" json:"legal_basis"`
	AssignedUserID      sql.Null[int64]     `db:"assigned_user_id" scan:"assigned_user_id" json:"assigned_user_id"`
	CreatedAt           sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	CompletedAt         sql.Null[time.Time] `db:"completed_at" scan:"completed_at" json:"completed_at"`
	Notes               sql.Null[string]    `db:"notes" scan:"notes" json:"notes"`

	R complianceReportR `db:"-" scan:"rel" json:"rel"`
}

// ComplianceReportSlice is an alias for a slice of pointers to ComplianceReport.
// This should almost always be used instead of []*ComplianceReport.
type ComplianceReportSlice []*ComplianceReport

// ComplianceReports contains methods to work with the compliance_reports table
var ComplianceReports = psql.NewTablex[*ComplianceReport, ComplianceReportSlice, *ComplianceReportSetter]("", "compliance_reports")

// ComplianceReportsQuery is a query on the compliance_reports table
type ComplianceReportsQuery = *psql.ViewQuery[*ComplianceReport, ComplianceReportSlice]

// complianceReportR is where relationships are stored.
type complianceReportR struct {
	ReportComplianceCorrelations ComplianceCorrelationSlice `scan:"ReportComplianceCorrelations" json:"ReportComplianceCorrelations"` // compliance_correlations.compliance_correlations_report_id_fkey
	AssignedUserUser             *User                      `scan:"AssignedUserUser" json:"AssignedUserUser"`                         // compliance_reports.compliance_reports_assigned_user_id_fkey
}

type complianceReportColumnNames struct {
	ReportID            string
	ReportType          string
	RequestingAuthority string
	RequestID           string
	RequestDate         string
	DueDate             string
	Status              string
	ScopeDescription    string
	LegalBasis          string
	AssignedUserID      string
	CreatedAt           string
	CompletedAt         string
	Notes               string
}

var ComplianceReportColumns = buildComplianceReportColumns("compliance_reports")

type complianceReportColumns struct {
	tableAlias          string
	ReportID            psql.Expression
	ReportType          psql.Expression
	RequestingAuthority psql.Expression
	RequestID           psql.Expression
	RequestDate         psql.Expression
	DueDate             psql.Expression
	Status              psql.Expression
	ScopeDescription    psql.Expression
	LegalBasis          psql.Expression
	AssignedUserID      psql.Expression
	CreatedAt           psql.Expression
	CompletedAt         psql.Expression
	Notes               psql.Expression
}

func (c complianceReportColumns) Alias() string {
	return c.tableAlias
}

func (complianceReportColumns) AliasedAs(alias string) complianceReportColumns {
	return buildComplianceReportColumns(alias)
}

func buildComplianceReportColumns(alias string) complianceReportColumns {
	return complianceReportColumns{
		tableAlias:          alias,
		ReportID:            psql.Quote(alias, "report_id"),
		ReportType:          psql.Quote(alias, "report_type"),
		RequestingAuthority: psql.Quote(alias, "requesting_authority"),
		RequestID:           psql.Quote(alias, "request_id"),
		RequestDate:         psql.Quote(alias, "request_date"),
		DueDate:             psql.Quote(alias, "due_date"),
		Status:              psql.Quote(alias, "status"),
		ScopeDescription:    psql.Quote(alias, "scope_description"),
		LegalBasis:          psql.Quote(alias, "legal_basis"),
		AssignedUserID:      psql.Quote(alias, "assigned_user_id"),
		CreatedAt:           psql.Quote(alias, "created_at"),
		CompletedAt:         psql.Quote(alias, "completed_at"),
		Notes:               psql.Quote(alias, "notes"),
	}
}

type complianceReportWhere[Q psql.Filterable] struct {
	ReportID            psql.WhereMod[Q, uuid.UUID]
	ReportType          psql.WhereMod[Q, string]
	RequestingAuthority psql.WhereNullMod[Q, string]
	RequestID           psql.WhereNullMod[Q, string]
	RequestDate         psql.WhereMod[Q, time.Time]
	DueDate             psql.WhereNullMod[Q, time.Time]
	Status              psql.WhereNullMod[Q, string]
	ScopeDescription    psql.WhereMod[Q, string]
	LegalBasis          psql.WhereNullMod[Q, string]
	AssignedUserID      psql.WhereNullMod[Q, int64]
	CreatedAt           psql.WhereNullMod[Q, time.Time]
	CompletedAt         psql.WhereNullMod[Q, time.Time]
	Notes               psql.WhereNullMod[Q, string]
}

func (complianceReportWhere[Q]) AliasedAs(alias string) complianceReportWhere[Q] {
	return buildComplianceReportWhere[Q](buildComplianceReportColumns(alias))
}

func buildComplianceReportWhere[Q psql.Filterable](cols complianceReportColumns) complianceReportWhere[Q] {
	return complianceReportWhere[Q]{
		ReportID:            psql.Where[Q, uuid.UUID](cols.ReportID),
		ReportType:          psql.Where[Q, string](cols.ReportType),
		RequestingAuthority: psql.WhereNull[Q, string](cols.RequestingAuthority),
		RequestID:           psql.WhereNull[Q, string](cols.RequestID),
		RequestDate:         psql.Where[Q, time.Time](cols.RequestDate),
		DueDate:             psql.WhereNull[Q, time.Time](cols.DueDate),
		Status:              psql.WhereNull[Q, string](cols.Status),
		ScopeDescription:    psql.Where[Q, string](cols.ScopeDescription),
		LegalBasis:          psql.WhereNull[Q, string](cols.LegalBasis),
		AssignedUserID:      psql.WhereNull[Q, int64](cols.AssignedUserID),
		CreatedAt:           psql.WhereNull[Q, time.Time](cols.CreatedAt),
		CompletedAt:         psql.WhereNull[Q, time.Time](cols.CompletedAt),
		Notes:               psql.WhereNull[Q, string](cols.Notes),
	}
}

var ComplianceReportErrors = &complianceReportErrors{
	ErrUniqueComplianceReportsPkey: &UniqueConstraintError{
		schema:  "",
		table:   "compliance_reports",
		columns: []string{"report_id"},
		s:       "compliance_reports_pkey",
	},
}

type complianceReportErrors struct {
	ErrUniqueComplianceReportsPkey *UniqueConstraintError
}

// ComplianceReportSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type ComplianceReportSetter struct {
	ReportID            *uuid.UUID           `db:"report_id,pk" scan:"report_id" json:"report_id"`
	ReportType          *string              `db:"report_type" scan:"report_type" json:"report_type"`
	RequestingAuthority *sql.Null[string]    `db:"requesting_authority" scan:"requesting_authority" json:"requesting_authority"`
	RequestID           *sql.Null[string]    `db:"request_id" scan:"request_id" json:"request_id"`
	RequestDate         *time.Time           `db:"request_date" scan:"request_date" json:"request_date"`
	DueDate             *sql.Null[time.Time] `db:"due_date" scan:"due_date" json:"due_date"`
	Status              *sql.Null[string]    `db:"status" scan:"status" json:"status"`
	ScopeDescription    *string              `db:"scope_description" scan:"scope_description" json:"scope_description"`
	LegalBasis          *sql.Null[string]    `db:"legal_basis" scan:"legal_basis" json:"legal_basis"`
	AssignedUserID      *sql.Null[int64]     `db:"assigned_user_id" scan:"assigned_user_id" json:"assigned_user_id"`
	CreatedAt           *sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	CompletedAt         *sql.Null[time.Time] `db:"completed_at" scan:"completed_at" json:"completed_at"`
	Notes               *sql.Null[string]    `db:"notes" scan:"notes" json:"notes"`
}

func (s ComplianceReportSetter) SetColumns() []string {
	vals := make([]string, 0, 13)
	if s.ReportID != nil {
		vals = append(vals, "report_id")
	}

	if s.ReportType != nil {
		vals = append(vals, "report_type")
	}

	if s.RequestingAuthority != nil {
		vals = append(vals, "requesting_authority")
	}

	if s.RequestID != nil {
		vals = append(vals, "request_id")
	}

	if s.RequestDate != nil {
		vals = append(vals, "request_date")
	}

	if s.DueDate != nil {
		vals = append(vals, "due_date")
	}

	if s.Status != nil {
		vals = append(vals, "status")
	}

	if s.ScopeDescription != nil {
		vals = append(vals, "scope_description")
	}

	if s.LegalBasis != nil {
		vals = append(vals, "legal_basis")
	}

	if s.AssignedUserID != nil {
		vals = append(vals, "assigned_user_id")
	}

	if s.CreatedAt != nil {
		vals = append(vals, "created_at")
	}

	if s.CompletedAt != nil {
		vals = append(vals, "completed_at")
	}

	if s.Notes != nil {
		vals = append(vals, "notes")
	}

	return vals
}

func (s ComplianceReportSetter) Overwrite(t *ComplianceReport) {
	if s.ReportID != nil {
		t.ReportID = *s.ReportID
	}
	if s.ReportType != nil {
		t.ReportType = *s.ReportType
	}
	if s.RequestingAuthority != nil {
		t.RequestingAuthority = *s.RequestingAuthority
	}
	if s.RequestID != nil {
		t.RequestID = *s.RequestID
	}
	if s.RequestDate != nil {
		t.RequestDate = *s.RequestDate
	}
	if s.DueDate != nil {
		t.DueDate = *s.DueDate
	}
	if s.Status != nil {
		t.Status = *s.Status
	}
	if s.ScopeDescription != nil {
		t.ScopeDescription = *s.ScopeDescription
	}
	if s.LegalBasis != nil {
		t.LegalBasis = *s.LegalBasis
	}
	if s.AssignedUserID != nil {
		t.AssignedUserID = *s.AssignedUserID
	}
	if s.CreatedAt != nil {
		t.CreatedAt = *s.CreatedAt
	}
	if s.CompletedAt != nil {
		t.CompletedAt = *s.CompletedAt
	}
	if s.Notes != nil {
		t.Notes = *s.Notes
	}
}

func (s *ComplianceReportSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return ComplianceReports.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 13)
		if s.ReportID != nil {
			vals[0] = psql.Arg(*s.ReportID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.ReportType != nil {
			vals[1] = psql.Arg(*s.ReportType)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.RequestingAuthority != nil {
			vals[2] = psql.Arg(*s.RequestingAuthority)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.RequestID != nil {
			vals[3] = psql.Arg(*s.RequestID)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.RequestDate != nil {
			vals[4] = psql.Arg(*s.RequestDate)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.DueDate != nil {
			vals[5] = psql.Arg(*s.DueDate)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.Status != nil {
			vals[6] = psql.Arg(*s.Status)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.ScopeDescription != nil {
			vals[7] = psql.Arg(*s.ScopeDescription)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.LegalBasis != nil {
			vals[8] = psql.Arg(*s.LegalBasis)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.AssignedUserID != nil {
			vals[9] = psql.Arg(*s.AssignedUserID)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt != nil {
			vals[10] = psql.Arg(*s.CreatedAt)
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.CompletedAt != nil {
			vals[11] = psql.Arg(*s.CompletedAt)
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.Notes != nil {
			vals[12] = psql.Arg(*s.Notes)
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s ComplianceReportSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s ComplianceReportSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 13)

	if s.ReportID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "report_id")...),
			psql.Arg(s.ReportID),
		}})
	}

	if s.ReportType != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "report_type")...),
			psql.Arg(s.ReportType),
		}})
	}

	if s.RequestingAuthority != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "requesting_authority")...),
			psql.Arg(s.RequestingAuthority),
		}})
	}

	if s.RequestID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "request_id")...),
			psql.Arg(s.RequestID),
		}})
	}

	if s.RequestDate != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "request_date")...),
			psql.Arg(s.RequestDate),
		}})
	}

	if s.DueDate != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "due_date")...),
			psql.Arg(s.DueDate),
		}})
	}

	if s.Status != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "status")...),
			psql.Arg(s.Status),
		}})
	}

	if s.ScopeDescription != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "scope_description")...),
			psql.Arg(s.ScopeDescription),
		}})
	}

	if s.LegalBasis != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "legal_basis")...),
			psql.Arg(s.LegalBasis),
		}})
	}

	if s.AssignedUserID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "assigned_user_id")...),
			psql.Arg(s.AssignedUserID),
		}})
	}

	if s.CreatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.CompletedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "completed_at")...),
			psql.Arg(s.CompletedAt),
		}})
	}

	if s.Notes != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "notes")...),
			psql.Arg(s.Notes),
		}})
	}

	return exprs
}

// FindComplianceReport retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindComplianceReport(ctx context.Context, exec bob.Executor, ReportIDPK uuid.UUID, cols ...string) (*ComplianceReport, error) {
	if len(cols) == 0 {
		return ComplianceReports.Query(
			SelectWhere.ComplianceReports.ReportID.EQ(ReportIDPK),
		).One(ctx, exec)
	}

	return ComplianceReports.Query(
		SelectWhere.ComplianceReports.ReportID.EQ(ReportIDPK),
		sm.Columns(ComplianceReports.Columns().Only(cols...)),
	).One(ctx, exec)
}

// ComplianceReportExists checks the presence of a single record by primary key
func ComplianceReportExists(ctx context.Context, exec bob.Executor, ReportIDPK uuid.UUID) (bool, error) {
	return ComplianceReports.Query(
		SelectWhere.ComplianceReports.ReportID.EQ(ReportIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after ComplianceReport is retrieved from the database
func (o *ComplianceReport) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = ComplianceReports.AfterSelectHooks.RunHooks(ctx, exec, ComplianceReportSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = ComplianceReports.AfterInsertHooks.RunHooks(ctx, exec, ComplianceReportSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = ComplianceReports.AfterUpdateHooks.RunHooks(ctx, exec, ComplianceReportSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = ComplianceReports.AfterDeleteHooks.RunHooks(ctx, exec, ComplianceReportSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the ComplianceReport
func (o *ComplianceReport) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ReportID)
}

func (o *ComplianceReport) pkEQ() dialect.Expression {
	return psql.Quote("compliance_reports", "report_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the ComplianceReport
func (o *ComplianceReport) Update(ctx context.Context, exec bob.Executor, s *ComplianceReportSetter) error {
	v, err := ComplianceReports.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single ComplianceReport record with an executor
func (o *ComplianceReport) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := ComplianceReports.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the ComplianceReport using the executor
func (o *ComplianceReport) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := ComplianceReports.Query(
		SelectWhere.ComplianceReports.ReportID.EQ(o.ReportID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after ComplianceReportSlice is retrieved from the database
func (o ComplianceReportSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = ComplianceReports.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = ComplianceReports.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = ComplianceReports.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = ComplianceReports.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o ComplianceReportSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("compliance_reports", "report_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o ComplianceReportSlice) copyMatchingRows(from ...*ComplianceReport) {
	for i, old := range o {
		for _, new := range from {
			if new.ReportID != old.ReportID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o ComplianceReportSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return ComplianceReports.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *ComplianceReport:
				o.copyMatchingRows(retrieved)
			case []*ComplianceReport:
				o.copyMatchingRows(retrieved...)
			case ComplianceReportSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a ComplianceReport or a slice of ComplianceReport
				// then run the AfterUpdateHooks on the slice
				_, err = ComplianceReports.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o ComplianceReportSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return ComplianceReports.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *ComplianceReport:
				o.copyMatchingRows(retrieved)
			case []*ComplianceReport:
				o.copyMatchingRows(retrieved...)
			case ComplianceReportSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a ComplianceReport or a slice of ComplianceReport
				// then run the AfterDeleteHooks on the slice
				_, err = ComplianceReports.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o ComplianceReportSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals ComplianceReportSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := ComplianceReports.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o ComplianceReportSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := ComplianceReports.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o ComplianceReportSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := ComplianceReports.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type complianceReportJoins[Q dialect.Joinable] struct {
	typ                          string
	ReportComplianceCorrelations modAs[Q, complianceCorrelationColumns]
	AssignedUserUser             modAs[Q, userColumns]
}

func (j complianceReportJoins[Q]) aliasedAs(alias string) complianceReportJoins[Q] {
	return buildComplianceReportJoins[Q](buildComplianceReportColumns(alias), j.typ)
}

func buildComplianceReportJoins[Q dialect.Joinable](cols complianceReportColumns, typ string) complianceReportJoins[Q] {
	return complianceReportJoins[Q]{
		typ: typ,
		ReportComplianceCorrelations: modAs[Q, complianceCorrelationColumns]{
			c: ComplianceCorrelationColumns,
			f: func(to complianceCorrelationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ComplianceCorrelations.Name().As(to.Alias())).On(
						to.ReportID.EQ(cols.ReportID),
					))
				}

				return mods
			},
		},
		AssignedUserUser: modAs[Q, userColumns]{
			c: UserColumns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.AssignedUserID),
					))
				}

				return mods
			},
		},
	}
}

// ReportComplianceCorrelations starts a query for related objects on compliance_correlations
func (o *ComplianceReport) ReportComplianceCorrelations(mods ...bob.Mod[*dialect.SelectQuery]) ComplianceCorrelationsQuery {
	return ComplianceCorrelations.Query(append(mods,
		sm.Where(ComplianceCorrelationColumns.ReportID.EQ(psql.Arg(o.ReportID))),
	)...)
}

func (os ComplianceReportSlice) ReportComplianceCorrelations(mods ...bob.Mod[*dialect.SelectQuery]) ComplianceCorrelationsQuery {
	pkReportID := make(pgtypes.Array[uuid.UUID], len(os))
	for i, o := range os {
		pkReportID[i] = o.ReportID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkReportID), "uuid[]")),
	))

	return ComplianceCorrelations.Query(append(mods,
		sm.Where(psql.Group(ComplianceCorrelationColumns.ReportID).OP("IN", PKArgExpr)),
	)...)
}

// AssignedUserUser starts a query for related objects on users
func (o *ComplianceReport) AssignedUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(UserColumns.UserID.EQ(psql.Arg(o.AssignedUserID))),
	)...)
}

func (os ComplianceReportSlice) AssignedUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkAssignedUserID := make(pgtypes.Array[sql.Null[int64]], len(os))
	for i, o := range os {
		pkAssignedUserID[i] = o.AssignedUserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkAssignedUserID), "bigint[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(UserColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

func (o *ComplianceReport) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "ReportComplianceCorrelations":
		rels, ok := retrieved.(ComplianceCorrelationSlice)
		if !ok {
			return fmt.Errorf("complianceReport cannot load %T as %q", retrieved, name)
		}

		o.R.ReportComplianceCorrelations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ReportComplianceReport = o
			}
		}
		return nil
	case "AssignedUserUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("complianceReport cannot load %T as %q", retrieved, name)
		}

		o.R.AssignedUserUser = rel

		if rel != nil {
			rel.R.AssignedUserComplianceReports = ComplianceReportSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("complianceReport has no relationship %q", name)
	}
}

type complianceReportPreloader struct {
	AssignedUserUser func(...psql.PreloadOption) psql.Preloader
}

func buildComplianceReportPreloader() complianceReportPreloader {
	return complianceReportPreloader{
		AssignedUserUser: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](orm.Relationship{
				Name: "AssignedUserUser",
				Sides: []orm.RelSide{
					{
						From: TableNames.ComplianceReports,
						To:   TableNames.Users,
						FromColumns: []string{
							ColumnNames.ComplianceReports.AssignedUserID,
						},
						ToColumns: []string{
							ColumnNames.Users.UserID,
						},
					},
				},
			}, Users.Columns().Names(), opts...)
		},
	}
}

type complianceReportThenLoader[Q orm.Loadable] struct {
	ReportComplianceCorrelations func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	AssignedUserUser             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildComplianceReportThenLoader[Q orm.Loadable]() complianceReportThenLoader[Q] {
	type ReportComplianceCorrelationsLoadInterface interface {
		LoadReportComplianceCorrelations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type AssignedUserUserLoadInterface interface {
		LoadAssignedUserUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return complianceReportThenLoader[Q]{
		ReportComplianceCorrelations: thenLoadBuilder[Q](
			"ReportComplianceCorrelations",
			func(ctx context.Context, exec bob.Executor, retrieved ReportComplianceCorrelationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadReportComplianceCorrelations(ctx, exec, mods...)
			},
		),
		AssignedUserUser: thenLoadBuilder[Q](
			"AssignedUserUser",
			func(ctx context.Context, exec bob.Executor, retrieved AssignedUserUserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadAssignedUserUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadReportComplianceCorrelations loads the complianceReport's ReportComplianceCorrelations into the .R struct
func (o *ComplianceReport) LoadReportComplianceCorrelations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ReportComplianceCorrelations = nil

	related, err := o.ReportComplianceCorrelations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ReportComplianceReport = o
	}

	o.R.ReportComplianceCorrelations = related
	return nil
}

// LoadReportComplianceCorrelations loads the complianceReport's ReportComplianceCorrelations into the .R struct
func (os ComplianceReportSlice) LoadReportComplianceCorrelations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	complianceCorrelations, err := os.ReportComplianceCorrelations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ReportComplianceCorrelations = nil
	}

	for _, o := range os {
		for _, rel := range complianceCorrelations {
			if o.ReportID != rel.ReportID {
				continue
			}

			rel.R.ReportComplianceReport = o

			o.R.ReportComplianceCorrelations = append(o.R.ReportComplianceCorrelations, rel)
		}
	}

	return nil
}

// LoadAssignedUserUser loads the complianceReport's AssignedUserUser into the .R struct
func (o *ComplianceReport) LoadAssignedUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.AssignedUserUser = nil

	related, err := o.AssignedUserUser(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.AssignedUserComplianceReports = ComplianceReportSlice{o}

	o.R.AssignedUserUser = related
	return nil
}

// LoadAssignedUserUser loads the complianceReport's AssignedUserUser into the .R struct
func (os ComplianceReportSlice) LoadAssignedUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.AssignedUserUser(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range users {
			if o.AssignedUserID.V != rel.UserID {
				continue
			}

			rel.R.AssignedUserComplianceReports = append(rel.R.AssignedUserComplianceReports, o)

			o.R.AssignedUserUser = rel
			break
		}
	}

	return nil
}

func insertComplianceReportReportComplianceCorrelations0(ctx context.Context, exec bob.Executor, complianceCorrelations1 []*ComplianceCorrelationSetter, complianceReport0 *ComplianceReport) (ComplianceCorrelationSlice, error) {
	for i := range complianceCorrelations1 {
		complianceCorrelations1[i].ReportID = &complianceReport0.ReportID
	}

	ret, err := ComplianceCorrelations.Insert(bob.ToMods(complianceCorrelations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertComplianceReportReportComplianceCorrelations0: %w", err)
	}

	return ret, nil
}

func attachComplianceReportReportComplianceCorrelations0(ctx context.Context, exec bob.Executor, count int, complianceCorrelations1 ComplianceCorrelationSlice, complianceReport0 *ComplianceReport) (ComplianceCorrelationSlice, error) {
	setter := &ComplianceCorrelationSetter{
		ReportID: &complianceReport0.ReportID,
	}

	err := complianceCorrelations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachComplianceReportReportComplianceCorrelations0: %w", err)
	}

	return complianceCorrelations1, nil
}

func (complianceReport0 *ComplianceReport) InsertReportComplianceCorrelations(ctx context.Context, exec bob.Executor, related ...*ComplianceCorrelationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	complianceCorrelations1, err := insertComplianceReportReportComplianceCorrelations0(ctx, exec, related, complianceReport0)
	if err != nil {
		return err
	}

	complianceReport0.R.ReportComplianceCorrelations = append(complianceReport0.R.ReportComplianceCorrelations, complianceCorrelations1...)

	for _, rel := range complianceCorrelations1 {
		rel.R.ReportComplianceReport = complianceReport0
	}
	return nil
}

func (complianceReport0 *ComplianceReport) AttachReportComplianceCorrelations(ctx context.Context, exec bob.Executor, related ...*ComplianceCorrelation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	complianceCorrelations1 := ComplianceCorrelationSlice(related)

	_, err = attachComplianceReportReportComplianceCorrelations0(ctx, exec, len(related), complianceCorrelations1, complianceReport0)
	if err != nil {
		return err
	}

	complianceReport0.R.ReportComplianceCorrelations = append(complianceReport0.R.ReportComplianceCorrelations, complianceCorrelations1...)

	for _, rel := range related {
		rel.R.ReportComplianceReport = complianceReport0
	}

	return nil
}

func attachComplianceReportAssignedUserUser0(ctx context.Context, exec bob.Executor, count int, complianceReport0 *ComplianceReport, user1 *User) (*ComplianceReport, error) {
	setter := &ComplianceReportSetter{
		AssignedUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user1.UserID, Valid: true}
			return &v
		}(),
	}

	err := complianceReport0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachComplianceReportAssignedUserUser0: %w", err)
	}

	return complianceReport0, nil
}

func (complianceReport0 *ComplianceReport) InsertAssignedUserUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachComplianceReportAssignedUserUser0(ctx, exec, 1, complianceReport0, user1)
	if err != nil {
		return err
	}

	complianceReport0.R.AssignedUserUser = user1

	user1.R.AssignedUserComplianceReports = append(user1.R.AssignedUserComplianceReports, complianceReport0)

	return nil
}

func (complianceReport0 *ComplianceReport) AttachAssignedUserUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachComplianceReportAssignedUserUser0(ctx, exec, 1, complianceReport0, user1)
	if err != nil {
		return err
	}

	complianceReport0.R.AssignedUserUser = user1

	user1.R.AssignedUserComplianceReports = append(user1.R.AssignedUserComplianceReports, complianceReport0)

	return nil
}
