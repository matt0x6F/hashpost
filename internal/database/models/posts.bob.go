// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"time"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// Post is an object representing the database table.
type Post struct {
	PostID               int64               `db:"post_id,pk" scan:"post_id" json:"post_id"`
	SubforumID           int32               `db:"subforum_id" scan:"subforum_id" json:"subforum_id"`
	Title                string              `db:"title" scan:"title" json:"title"`
	Content              sql.Null[string]    `db:"content" scan:"content" json:"content"`
	PostType             string              `db:"post_type" scan:"post_type" json:"post_type"`
	URL                  sql.Null[string]    `db:"url" scan:"url" json:"url"`
	IsSelfPost           sql.Null[bool]      `db:"is_self_post" scan:"is_self_post" json:"is_self_post"`
	IsNSFW               sql.Null[bool]      `db:"is_nsfw" scan:"is_nsfw" json:"is_nsfw"`
	IsSpoiler            sql.Null[bool]      `db:"is_spoiler" scan:"is_spoiler" json:"is_spoiler"`
	IsLocked             sql.Null[bool]      `db:"is_locked" scan:"is_locked" json:"is_locked"`
	IsStickied           sql.Null[bool]      `db:"is_stickied" scan:"is_stickied" json:"is_stickied"`
	IsArchived           sql.Null[bool]      `db:"is_archived" scan:"is_archived" json:"is_archived"`
	CreatedAt            sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	UpdatedAt            sql.Null[time.Time] `db:"updated_at" scan:"updated_at" json:"updated_at"`
	Score                sql.Null[int32]     `db:"score" scan:"score" json:"score"`
	Upvotes              sql.Null[int32]     `db:"upvotes" scan:"upvotes" json:"upvotes"`
	Downvotes            sql.Null[int32]     `db:"downvotes" scan:"downvotes" json:"downvotes"`
	CommentCount         sql.Null[int32]     `db:"comment_count" scan:"comment_count" json:"comment_count"`
	ViewCount            sql.Null[int32]     `db:"view_count" scan:"view_count" json:"view_count"`
	IsRemoved            sql.Null[bool]      `db:"is_removed" scan:"is_removed" json:"is_removed"`
	RemovedByUserID      sql.Null[int64]     `db:"removed_by_user_id" scan:"removed_by_user_id" json:"removed_by_user_id"`
	RemovedByPseudonymID sql.Null[string]    `db:"removed_by_pseudonym_id" scan:"removed_by_pseudonym_id" json:"removed_by_pseudonym_id"`
	RemovalReason        sql.Null[string]    `db:"removal_reason" scan:"removal_reason" json:"removal_reason"`
	RemovedAt            sql.Null[time.Time] `db:"removed_at" scan:"removed_at" json:"removed_at"`
	PseudonymID          string              `db:"pseudonym_id" scan:"pseudonym_id" json:"pseudonym_id"`

	R postR `db:"-" scan:"rel" json:"rel"`
}

// PostSlice is an alias for a slice of pointers to Post.
// This should almost always be used instead of []*Post.
type PostSlice []*Post

// Posts contains methods to work with the posts table
var Posts = psql.NewTablex[*Post, PostSlice, *PostSetter]("", "posts")

// PostsQuery is a query on the posts table
type PostsQuery = *psql.ViewQuery[*Post, PostSlice]

// postR is where relationships are stored.
type postR struct {
	Comments                    CommentSlice         `scan:"Comments" json:"Comments"`                                       // comments.comments_post_id_fkey
	MediaAttachments            MediaAttachmentSlice `scan:"MediaAttachments" json:"MediaAttachments"`                       // media_attachments.media_attachments_post_id_fkey
	Poll                        *Poll                `scan:"Poll" json:"Poll"`                                               // polls.polls_post_id_fkey
	Pseudonym                   *Pseudonym           `scan:"Pseudonym" json:"Pseudonym"`                                     // posts.posts_pseudonym_id_fkey
	RemovedByPseudonymPseudonym *Pseudonym           `scan:"RemovedByPseudonymPseudonym" json:"RemovedByPseudonymPseudonym"` // posts.posts_removed_by_pseudonym_id_fkey
	RemovedByUserUser           *User                `scan:"RemovedByUserUser" json:"RemovedByUserUser"`                     // posts.posts_removed_by_user_id_fkey
	Subforum                    *Subforum            `scan:"Subforum" json:"Subforum"`                                       // posts.posts_subforum_id_fkey
}

type postColumnNames struct {
	PostID               string
	SubforumID           string
	Title                string
	Content              string
	PostType             string
	URL                  string
	IsSelfPost           string
	IsNSFW               string
	IsSpoiler            string
	IsLocked             string
	IsStickied           string
	IsArchived           string
	CreatedAt            string
	UpdatedAt            string
	Score                string
	Upvotes              string
	Downvotes            string
	CommentCount         string
	ViewCount            string
	IsRemoved            string
	RemovedByUserID      string
	RemovedByPseudonymID string
	RemovalReason        string
	RemovedAt            string
	PseudonymID          string
}

var PostColumns = buildPostColumns("posts")

type postColumns struct {
	tableAlias           string
	PostID               psql.Expression
	SubforumID           psql.Expression
	Title                psql.Expression
	Content              psql.Expression
	PostType             psql.Expression
	URL                  psql.Expression
	IsSelfPost           psql.Expression
	IsNSFW               psql.Expression
	IsSpoiler            psql.Expression
	IsLocked             psql.Expression
	IsStickied           psql.Expression
	IsArchived           psql.Expression
	CreatedAt            psql.Expression
	UpdatedAt            psql.Expression
	Score                psql.Expression
	Upvotes              psql.Expression
	Downvotes            psql.Expression
	CommentCount         psql.Expression
	ViewCount            psql.Expression
	IsRemoved            psql.Expression
	RemovedByUserID      psql.Expression
	RemovedByPseudonymID psql.Expression
	RemovalReason        psql.Expression
	RemovedAt            psql.Expression
	PseudonymID          psql.Expression
}

func (c postColumns) Alias() string {
	return c.tableAlias
}

func (postColumns) AliasedAs(alias string) postColumns {
	return buildPostColumns(alias)
}

func buildPostColumns(alias string) postColumns {
	return postColumns{
		tableAlias:           alias,
		PostID:               psql.Quote(alias, "post_id"),
		SubforumID:           psql.Quote(alias, "subforum_id"),
		Title:                psql.Quote(alias, "title"),
		Content:              psql.Quote(alias, "content"),
		PostType:             psql.Quote(alias, "post_type"),
		URL:                  psql.Quote(alias, "url"),
		IsSelfPost:           psql.Quote(alias, "is_self_post"),
		IsNSFW:               psql.Quote(alias, "is_nsfw"),
		IsSpoiler:            psql.Quote(alias, "is_spoiler"),
		IsLocked:             psql.Quote(alias, "is_locked"),
		IsStickied:           psql.Quote(alias, "is_stickied"),
		IsArchived:           psql.Quote(alias, "is_archived"),
		CreatedAt:            psql.Quote(alias, "created_at"),
		UpdatedAt:            psql.Quote(alias, "updated_at"),
		Score:                psql.Quote(alias, "score"),
		Upvotes:              psql.Quote(alias, "upvotes"),
		Downvotes:            psql.Quote(alias, "downvotes"),
		CommentCount:         psql.Quote(alias, "comment_count"),
		ViewCount:            psql.Quote(alias, "view_count"),
		IsRemoved:            psql.Quote(alias, "is_removed"),
		RemovedByUserID:      psql.Quote(alias, "removed_by_user_id"),
		RemovedByPseudonymID: psql.Quote(alias, "removed_by_pseudonym_id"),
		RemovalReason:        psql.Quote(alias, "removal_reason"),
		RemovedAt:            psql.Quote(alias, "removed_at"),
		PseudonymID:          psql.Quote(alias, "pseudonym_id"),
	}
}

type postWhere[Q psql.Filterable] struct {
	PostID               psql.WhereMod[Q, int64]
	SubforumID           psql.WhereMod[Q, int32]
	Title                psql.WhereMod[Q, string]
	Content              psql.WhereNullMod[Q, string]
	PostType             psql.WhereMod[Q, string]
	URL                  psql.WhereNullMod[Q, string]
	IsSelfPost           psql.WhereNullMod[Q, bool]
	IsNSFW               psql.WhereNullMod[Q, bool]
	IsSpoiler            psql.WhereNullMod[Q, bool]
	IsLocked             psql.WhereNullMod[Q, bool]
	IsStickied           psql.WhereNullMod[Q, bool]
	IsArchived           psql.WhereNullMod[Q, bool]
	CreatedAt            psql.WhereNullMod[Q, time.Time]
	UpdatedAt            psql.WhereNullMod[Q, time.Time]
	Score                psql.WhereNullMod[Q, int32]
	Upvotes              psql.WhereNullMod[Q, int32]
	Downvotes            psql.WhereNullMod[Q, int32]
	CommentCount         psql.WhereNullMod[Q, int32]
	ViewCount            psql.WhereNullMod[Q, int32]
	IsRemoved            psql.WhereNullMod[Q, bool]
	RemovedByUserID      psql.WhereNullMod[Q, int64]
	RemovedByPseudonymID psql.WhereNullMod[Q, string]
	RemovalReason        psql.WhereNullMod[Q, string]
	RemovedAt            psql.WhereNullMod[Q, time.Time]
	PseudonymID          psql.WhereMod[Q, string]
}

func (postWhere[Q]) AliasedAs(alias string) postWhere[Q] {
	return buildPostWhere[Q](buildPostColumns(alias))
}

func buildPostWhere[Q psql.Filterable](cols postColumns) postWhere[Q] {
	return postWhere[Q]{
		PostID:               psql.Where[Q, int64](cols.PostID),
		SubforumID:           psql.Where[Q, int32](cols.SubforumID),
		Title:                psql.Where[Q, string](cols.Title),
		Content:              psql.WhereNull[Q, string](cols.Content),
		PostType:             psql.Where[Q, string](cols.PostType),
		URL:                  psql.WhereNull[Q, string](cols.URL),
		IsSelfPost:           psql.WhereNull[Q, bool](cols.IsSelfPost),
		IsNSFW:               psql.WhereNull[Q, bool](cols.IsNSFW),
		IsSpoiler:            psql.WhereNull[Q, bool](cols.IsSpoiler),
		IsLocked:             psql.WhereNull[Q, bool](cols.IsLocked),
		IsStickied:           psql.WhereNull[Q, bool](cols.IsStickied),
		IsArchived:           psql.WhereNull[Q, bool](cols.IsArchived),
		CreatedAt:            psql.WhereNull[Q, time.Time](cols.CreatedAt),
		UpdatedAt:            psql.WhereNull[Q, time.Time](cols.UpdatedAt),
		Score:                psql.WhereNull[Q, int32](cols.Score),
		Upvotes:              psql.WhereNull[Q, int32](cols.Upvotes),
		Downvotes:            psql.WhereNull[Q, int32](cols.Downvotes),
		CommentCount:         psql.WhereNull[Q, int32](cols.CommentCount),
		ViewCount:            psql.WhereNull[Q, int32](cols.ViewCount),
		IsRemoved:            psql.WhereNull[Q, bool](cols.IsRemoved),
		RemovedByUserID:      psql.WhereNull[Q, int64](cols.RemovedByUserID),
		RemovedByPseudonymID: psql.WhereNull[Q, string](cols.RemovedByPseudonymID),
		RemovalReason:        psql.WhereNull[Q, string](cols.RemovalReason),
		RemovedAt:            psql.WhereNull[Q, time.Time](cols.RemovedAt),
		PseudonymID:          psql.Where[Q, string](cols.PseudonymID),
	}
}

var PostErrors = &postErrors{
	ErrUniquePostsPkey: &UniqueConstraintError{
		schema:  "",
		table:   "posts",
		columns: []string{"post_id"},
		s:       "posts_pkey",
	},
}

type postErrors struct {
	ErrUniquePostsPkey *UniqueConstraintError
}

// PostSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type PostSetter struct {
	PostID               *int64               `db:"post_id,pk" scan:"post_id" json:"post_id"`
	SubforumID           *int32               `db:"subforum_id" scan:"subforum_id" json:"subforum_id"`
	Title                *string              `db:"title" scan:"title" json:"title"`
	Content              *sql.Null[string]    `db:"content" scan:"content" json:"content"`
	PostType             *string              `db:"post_type" scan:"post_type" json:"post_type"`
	URL                  *sql.Null[string]    `db:"url" scan:"url" json:"url"`
	IsSelfPost           *sql.Null[bool]      `db:"is_self_post" scan:"is_self_post" json:"is_self_post"`
	IsNSFW               *sql.Null[bool]      `db:"is_nsfw" scan:"is_nsfw" json:"is_nsfw"`
	IsSpoiler            *sql.Null[bool]      `db:"is_spoiler" scan:"is_spoiler" json:"is_spoiler"`
	IsLocked             *sql.Null[bool]      `db:"is_locked" scan:"is_locked" json:"is_locked"`
	IsStickied           *sql.Null[bool]      `db:"is_stickied" scan:"is_stickied" json:"is_stickied"`
	IsArchived           *sql.Null[bool]      `db:"is_archived" scan:"is_archived" json:"is_archived"`
	CreatedAt            *sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	UpdatedAt            *sql.Null[time.Time] `db:"updated_at" scan:"updated_at" json:"updated_at"`
	Score                *sql.Null[int32]     `db:"score" scan:"score" json:"score"`
	Upvotes              *sql.Null[int32]     `db:"upvotes" scan:"upvotes" json:"upvotes"`
	Downvotes            *sql.Null[int32]     `db:"downvotes" scan:"downvotes" json:"downvotes"`
	CommentCount         *sql.Null[int32]     `db:"comment_count" scan:"comment_count" json:"comment_count"`
	ViewCount            *sql.Null[int32]     `db:"view_count" scan:"view_count" json:"view_count"`
	IsRemoved            *sql.Null[bool]      `db:"is_removed" scan:"is_removed" json:"is_removed"`
	RemovedByUserID      *sql.Null[int64]     `db:"removed_by_user_id" scan:"removed_by_user_id" json:"removed_by_user_id"`
	RemovedByPseudonymID *sql.Null[string]    `db:"removed_by_pseudonym_id" scan:"removed_by_pseudonym_id" json:"removed_by_pseudonym_id"`
	RemovalReason        *sql.Null[string]    `db:"removal_reason" scan:"removal_reason" json:"removal_reason"`
	RemovedAt            *sql.Null[time.Time] `db:"removed_at" scan:"removed_at" json:"removed_at"`
	PseudonymID          *string              `db:"pseudonym_id" scan:"pseudonym_id" json:"pseudonym_id"`
}

func (s PostSetter) SetColumns() []string {
	vals := make([]string, 0, 25)
	if s.PostID != nil {
		vals = append(vals, "post_id")
	}

	if s.SubforumID != nil {
		vals = append(vals, "subforum_id")
	}

	if s.Title != nil {
		vals = append(vals, "title")
	}

	if s.Content != nil {
		vals = append(vals, "content")
	}

	if s.PostType != nil {
		vals = append(vals, "post_type")
	}

	if s.URL != nil {
		vals = append(vals, "url")
	}

	if s.IsSelfPost != nil {
		vals = append(vals, "is_self_post")
	}

	if s.IsNSFW != nil {
		vals = append(vals, "is_nsfw")
	}

	if s.IsSpoiler != nil {
		vals = append(vals, "is_spoiler")
	}

	if s.IsLocked != nil {
		vals = append(vals, "is_locked")
	}

	if s.IsStickied != nil {
		vals = append(vals, "is_stickied")
	}

	if s.IsArchived != nil {
		vals = append(vals, "is_archived")
	}

	if s.CreatedAt != nil {
		vals = append(vals, "created_at")
	}

	if s.UpdatedAt != nil {
		vals = append(vals, "updated_at")
	}

	if s.Score != nil {
		vals = append(vals, "score")
	}

	if s.Upvotes != nil {
		vals = append(vals, "upvotes")
	}

	if s.Downvotes != nil {
		vals = append(vals, "downvotes")
	}

	if s.CommentCount != nil {
		vals = append(vals, "comment_count")
	}

	if s.ViewCount != nil {
		vals = append(vals, "view_count")
	}

	if s.IsRemoved != nil {
		vals = append(vals, "is_removed")
	}

	if s.RemovedByUserID != nil {
		vals = append(vals, "removed_by_user_id")
	}

	if s.RemovedByPseudonymID != nil {
		vals = append(vals, "removed_by_pseudonym_id")
	}

	if s.RemovalReason != nil {
		vals = append(vals, "removal_reason")
	}

	if s.RemovedAt != nil {
		vals = append(vals, "removed_at")
	}

	if s.PseudonymID != nil {
		vals = append(vals, "pseudonym_id")
	}

	return vals
}

func (s PostSetter) Overwrite(t *Post) {
	if s.PostID != nil {
		t.PostID = *s.PostID
	}
	if s.SubforumID != nil {
		t.SubforumID = *s.SubforumID
	}
	if s.Title != nil {
		t.Title = *s.Title
	}
	if s.Content != nil {
		t.Content = *s.Content
	}
	if s.PostType != nil {
		t.PostType = *s.PostType
	}
	if s.URL != nil {
		t.URL = *s.URL
	}
	if s.IsSelfPost != nil {
		t.IsSelfPost = *s.IsSelfPost
	}
	if s.IsNSFW != nil {
		t.IsNSFW = *s.IsNSFW
	}
	if s.IsSpoiler != nil {
		t.IsSpoiler = *s.IsSpoiler
	}
	if s.IsLocked != nil {
		t.IsLocked = *s.IsLocked
	}
	if s.IsStickied != nil {
		t.IsStickied = *s.IsStickied
	}
	if s.IsArchived != nil {
		t.IsArchived = *s.IsArchived
	}
	if s.CreatedAt != nil {
		t.CreatedAt = *s.CreatedAt
	}
	if s.UpdatedAt != nil {
		t.UpdatedAt = *s.UpdatedAt
	}
	if s.Score != nil {
		t.Score = *s.Score
	}
	if s.Upvotes != nil {
		t.Upvotes = *s.Upvotes
	}
	if s.Downvotes != nil {
		t.Downvotes = *s.Downvotes
	}
	if s.CommentCount != nil {
		t.CommentCount = *s.CommentCount
	}
	if s.ViewCount != nil {
		t.ViewCount = *s.ViewCount
	}
	if s.IsRemoved != nil {
		t.IsRemoved = *s.IsRemoved
	}
	if s.RemovedByUserID != nil {
		t.RemovedByUserID = *s.RemovedByUserID
	}
	if s.RemovedByPseudonymID != nil {
		t.RemovedByPseudonymID = *s.RemovedByPseudonymID
	}
	if s.RemovalReason != nil {
		t.RemovalReason = *s.RemovalReason
	}
	if s.RemovedAt != nil {
		t.RemovedAt = *s.RemovedAt
	}
	if s.PseudonymID != nil {
		t.PseudonymID = *s.PseudonymID
	}
}

func (s *PostSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Posts.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 25)
		if s.PostID != nil {
			vals[0] = psql.Arg(*s.PostID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.SubforumID != nil {
			vals[1] = psql.Arg(*s.SubforumID)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.Title != nil {
			vals[2] = psql.Arg(*s.Title)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.Content != nil {
			vals[3] = psql.Arg(*s.Content)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.PostType != nil {
			vals[4] = psql.Arg(*s.PostType)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.URL != nil {
			vals[5] = psql.Arg(*s.URL)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.IsSelfPost != nil {
			vals[6] = psql.Arg(*s.IsSelfPost)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.IsNSFW != nil {
			vals[7] = psql.Arg(*s.IsNSFW)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.IsSpoiler != nil {
			vals[8] = psql.Arg(*s.IsSpoiler)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.IsLocked != nil {
			vals[9] = psql.Arg(*s.IsLocked)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.IsStickied != nil {
			vals[10] = psql.Arg(*s.IsStickied)
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.IsArchived != nil {
			vals[11] = psql.Arg(*s.IsArchived)
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt != nil {
			vals[12] = psql.Arg(*s.CreatedAt)
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.UpdatedAt != nil {
			vals[13] = psql.Arg(*s.UpdatedAt)
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.Score != nil {
			vals[14] = psql.Arg(*s.Score)
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.Upvotes != nil {
			vals[15] = psql.Arg(*s.Upvotes)
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if s.Downvotes != nil {
			vals[16] = psql.Arg(*s.Downvotes)
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if s.CommentCount != nil {
			vals[17] = psql.Arg(*s.CommentCount)
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if s.ViewCount != nil {
			vals[18] = psql.Arg(*s.ViewCount)
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if s.IsRemoved != nil {
			vals[19] = psql.Arg(*s.IsRemoved)
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if s.RemovedByUserID != nil {
			vals[20] = psql.Arg(*s.RemovedByUserID)
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if s.RemovedByPseudonymID != nil {
			vals[21] = psql.Arg(*s.RemovedByPseudonymID)
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if s.RemovalReason != nil {
			vals[22] = psql.Arg(*s.RemovalReason)
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if s.RemovedAt != nil {
			vals[23] = psql.Arg(*s.RemovedAt)
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if s.PseudonymID != nil {
			vals[24] = psql.Arg(*s.PseudonymID)
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s PostSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s PostSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 25)

	if s.PostID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "post_id")...),
			psql.Arg(s.PostID),
		}})
	}

	if s.SubforumID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "subforum_id")...),
			psql.Arg(s.SubforumID),
		}})
	}

	if s.Title != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "title")...),
			psql.Arg(s.Title),
		}})
	}

	if s.Content != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "content")...),
			psql.Arg(s.Content),
		}})
	}

	if s.PostType != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "post_type")...),
			psql.Arg(s.PostType),
		}})
	}

	if s.URL != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "url")...),
			psql.Arg(s.URL),
		}})
	}

	if s.IsSelfPost != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_self_post")...),
			psql.Arg(s.IsSelfPost),
		}})
	}

	if s.IsNSFW != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_nsfw")...),
			psql.Arg(s.IsNSFW),
		}})
	}

	if s.IsSpoiler != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_spoiler")...),
			psql.Arg(s.IsSpoiler),
		}})
	}

	if s.IsLocked != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_locked")...),
			psql.Arg(s.IsLocked),
		}})
	}

	if s.IsStickied != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_stickied")...),
			psql.Arg(s.IsStickied),
		}})
	}

	if s.IsArchived != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_archived")...),
			psql.Arg(s.IsArchived),
		}})
	}

	if s.CreatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.UpdatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated_at")...),
			psql.Arg(s.UpdatedAt),
		}})
	}

	if s.Score != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "score")...),
			psql.Arg(s.Score),
		}})
	}

	if s.Upvotes != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "upvotes")...),
			psql.Arg(s.Upvotes),
		}})
	}

	if s.Downvotes != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "downvotes")...),
			psql.Arg(s.Downvotes),
		}})
	}

	if s.CommentCount != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comment_count")...),
			psql.Arg(s.CommentCount),
		}})
	}

	if s.ViewCount != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "view_count")...),
			psql.Arg(s.ViewCount),
		}})
	}

	if s.IsRemoved != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_removed")...),
			psql.Arg(s.IsRemoved),
		}})
	}

	if s.RemovedByUserID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "removed_by_user_id")...),
			psql.Arg(s.RemovedByUserID),
		}})
	}

	if s.RemovedByPseudonymID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "removed_by_pseudonym_id")...),
			psql.Arg(s.RemovedByPseudonymID),
		}})
	}

	if s.RemovalReason != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "removal_reason")...),
			psql.Arg(s.RemovalReason),
		}})
	}

	if s.RemovedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "removed_at")...),
			psql.Arg(s.RemovedAt),
		}})
	}

	if s.PseudonymID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "pseudonym_id")...),
			psql.Arg(s.PseudonymID),
		}})
	}

	return exprs
}

// FindPost retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindPost(ctx context.Context, exec bob.Executor, PostIDPK int64, cols ...string) (*Post, error) {
	if len(cols) == 0 {
		return Posts.Query(
			SelectWhere.Posts.PostID.EQ(PostIDPK),
		).One(ctx, exec)
	}

	return Posts.Query(
		SelectWhere.Posts.PostID.EQ(PostIDPK),
		sm.Columns(Posts.Columns().Only(cols...)),
	).One(ctx, exec)
}

// PostExists checks the presence of a single record by primary key
func PostExists(ctx context.Context, exec bob.Executor, PostIDPK int64) (bool, error) {
	return Posts.Query(
		SelectWhere.Posts.PostID.EQ(PostIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Post is retrieved from the database
func (o *Post) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Posts.AfterSelectHooks.RunHooks(ctx, exec, PostSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Posts.AfterInsertHooks.RunHooks(ctx, exec, PostSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Posts.AfterUpdateHooks.RunHooks(ctx, exec, PostSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Posts.AfterDeleteHooks.RunHooks(ctx, exec, PostSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Post
func (o *Post) primaryKeyVals() bob.Expression {
	return psql.Arg(o.PostID)
}

func (o *Post) pkEQ() dialect.Expression {
	return psql.Quote("posts", "post_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Post
func (o *Post) Update(ctx context.Context, exec bob.Executor, s *PostSetter) error {
	v, err := Posts.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Post record with an executor
func (o *Post) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Posts.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Post using the executor
func (o *Post) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Posts.Query(
		SelectWhere.Posts.PostID.EQ(o.PostID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after PostSlice is retrieved from the database
func (o PostSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Posts.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Posts.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Posts.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Posts.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o PostSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("posts", "post_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o PostSlice) copyMatchingRows(from ...*Post) {
	for i, old := range o {
		for _, new := range from {
			if new.PostID != old.PostID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o PostSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Posts.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Post:
				o.copyMatchingRows(retrieved)
			case []*Post:
				o.copyMatchingRows(retrieved...)
			case PostSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Post or a slice of Post
				// then run the AfterUpdateHooks on the slice
				_, err = Posts.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o PostSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Posts.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Post:
				o.copyMatchingRows(retrieved)
			case []*Post:
				o.copyMatchingRows(retrieved...)
			case PostSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Post or a slice of Post
				// then run the AfterDeleteHooks on the slice
				_, err = Posts.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o PostSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals PostSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Posts.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o PostSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Posts.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o PostSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Posts.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type postJoins[Q dialect.Joinable] struct {
	typ                         string
	Comments                    modAs[Q, commentColumns]
	MediaAttachments            modAs[Q, mediaAttachmentColumns]
	Poll                        modAs[Q, pollColumns]
	Pseudonym                   modAs[Q, pseudonymColumns]
	RemovedByPseudonymPseudonym modAs[Q, pseudonymColumns]
	RemovedByUserUser           modAs[Q, userColumns]
	Subforum                    modAs[Q, subforumColumns]
}

func (j postJoins[Q]) aliasedAs(alias string) postJoins[Q] {
	return buildPostJoins[Q](buildPostColumns(alias), j.typ)
}

func buildPostJoins[Q dialect.Joinable](cols postColumns, typ string) postJoins[Q] {
	return postJoins[Q]{
		typ: typ,
		Comments: modAs[Q, commentColumns]{
			c: CommentColumns,
			f: func(to commentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Comments.Name().As(to.Alias())).On(
						to.PostID.EQ(cols.PostID),
					))
				}

				return mods
			},
		},
		MediaAttachments: modAs[Q, mediaAttachmentColumns]{
			c: MediaAttachmentColumns,
			f: func(to mediaAttachmentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, MediaAttachments.Name().As(to.Alias())).On(
						to.PostID.EQ(cols.PostID),
					))
				}

				return mods
			},
		},
		Poll: modAs[Q, pollColumns]{
			c: PollColumns,
			f: func(to pollColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Polls.Name().As(to.Alias())).On(
						to.PostID.EQ(cols.PostID),
					))
				}

				return mods
			},
		},
		Pseudonym: modAs[Q, pseudonymColumns]{
			c: PseudonymColumns,
			f: func(to pseudonymColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pseudonyms.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.PseudonymID),
					))
				}

				return mods
			},
		},
		RemovedByPseudonymPseudonym: modAs[Q, pseudonymColumns]{
			c: PseudonymColumns,
			f: func(to pseudonymColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pseudonyms.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.RemovedByPseudonymID),
					))
				}

				return mods
			},
		},
		RemovedByUserUser: modAs[Q, userColumns]{
			c: UserColumns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.RemovedByUserID),
					))
				}

				return mods
			},
		},
		Subforum: modAs[Q, subforumColumns]{
			c: SubforumColumns,
			f: func(to subforumColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Subforums.Name().As(to.Alias())).On(
						to.SubforumID.EQ(cols.SubforumID),
					))
				}

				return mods
			},
		},
	}
}

// Comments starts a query for related objects on comments
func (o *Post) Comments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	return Comments.Query(append(mods,
		sm.Where(CommentColumns.PostID.EQ(psql.Arg(o.PostID))),
	)...)
}

func (os PostSlice) Comments(mods ...bob.Mod[*dialect.SelectQuery]) CommentsQuery {
	pkPostID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkPostID[i] = o.PostID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPostID), "bigint[]")),
	))

	return Comments.Query(append(mods,
		sm.Where(psql.Group(CommentColumns.PostID).OP("IN", PKArgExpr)),
	)...)
}

// MediaAttachments starts a query for related objects on media_attachments
func (o *Post) MediaAttachments(mods ...bob.Mod[*dialect.SelectQuery]) MediaAttachmentsQuery {
	return MediaAttachments.Query(append(mods,
		sm.Where(MediaAttachmentColumns.PostID.EQ(psql.Arg(o.PostID))),
	)...)
}

func (os PostSlice) MediaAttachments(mods ...bob.Mod[*dialect.SelectQuery]) MediaAttachmentsQuery {
	pkPostID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkPostID[i] = o.PostID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPostID), "bigint[]")),
	))

	return MediaAttachments.Query(append(mods,
		sm.Where(psql.Group(MediaAttachmentColumns.PostID).OP("IN", PKArgExpr)),
	)...)
}

// Poll starts a query for related objects on polls
func (o *Post) Poll(mods ...bob.Mod[*dialect.SelectQuery]) PollsQuery {
	return Polls.Query(append(mods,
		sm.Where(PollColumns.PostID.EQ(psql.Arg(o.PostID))),
	)...)
}

func (os PostSlice) Poll(mods ...bob.Mod[*dialect.SelectQuery]) PollsQuery {
	pkPostID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkPostID[i] = o.PostID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPostID), "bigint[]")),
	))

	return Polls.Query(append(mods,
		sm.Where(psql.Group(PollColumns.PostID).OP("IN", PKArgExpr)),
	)...)
}

// Pseudonym starts a query for related objects on pseudonyms
func (o *Post) Pseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	return Pseudonyms.Query(append(mods,
		sm.Where(PseudonymColumns.PseudonymID.EQ(psql.Arg(o.PseudonymID))),
	)...)
}

func (os PostSlice) Pseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	pkPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkPseudonymID[i] = o.PseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPseudonymID), "character varying[]")),
	))

	return Pseudonyms.Query(append(mods,
		sm.Where(psql.Group(PseudonymColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// RemovedByPseudonymPseudonym starts a query for related objects on pseudonyms
func (o *Post) RemovedByPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	return Pseudonyms.Query(append(mods,
		sm.Where(PseudonymColumns.PseudonymID.EQ(psql.Arg(o.RemovedByPseudonymID))),
	)...)
}

func (os PostSlice) RemovedByPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	pkRemovedByPseudonymID := make(pgtypes.Array[sql.Null[string]], len(os))
	for i, o := range os {
		pkRemovedByPseudonymID[i] = o.RemovedByPseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkRemovedByPseudonymID), "character varying[]")),
	))

	return Pseudonyms.Query(append(mods,
		sm.Where(psql.Group(PseudonymColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// RemovedByUserUser starts a query for related objects on users
func (o *Post) RemovedByUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(UserColumns.UserID.EQ(psql.Arg(o.RemovedByUserID))),
	)...)
}

func (os PostSlice) RemovedByUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkRemovedByUserID := make(pgtypes.Array[sql.Null[int64]], len(os))
	for i, o := range os {
		pkRemovedByUserID[i] = o.RemovedByUserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkRemovedByUserID), "bigint[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(UserColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// Subforum starts a query for related objects on subforums
func (o *Post) Subforum(mods ...bob.Mod[*dialect.SelectQuery]) SubforumsQuery {
	return Subforums.Query(append(mods,
		sm.Where(SubforumColumns.SubforumID.EQ(psql.Arg(o.SubforumID))),
	)...)
}

func (os PostSlice) Subforum(mods ...bob.Mod[*dialect.SelectQuery]) SubforumsQuery {
	pkSubforumID := make(pgtypes.Array[int32], len(os))
	for i, o := range os {
		pkSubforumID[i] = o.SubforumID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkSubforumID), "integer[]")),
	))

	return Subforums.Query(append(mods,
		sm.Where(psql.Group(SubforumColumns.SubforumID).OP("IN", PKArgExpr)),
	)...)
}

func (o *Post) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Comments":
		rels, ok := retrieved.(CommentSlice)
		if !ok {
			return fmt.Errorf("post cannot load %T as %q", retrieved, name)
		}

		o.R.Comments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Post = o
			}
		}
		return nil
	case "MediaAttachments":
		rels, ok := retrieved.(MediaAttachmentSlice)
		if !ok {
			return fmt.Errorf("post cannot load %T as %q", retrieved, name)
		}

		o.R.MediaAttachments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Post = o
			}
		}
		return nil
	case "Poll":
		rel, ok := retrieved.(*Poll)
		if !ok {
			return fmt.Errorf("post cannot load %T as %q", retrieved, name)
		}

		o.R.Poll = rel

		if rel != nil {
			rel.R.Post = o
		}
		return nil
	case "Pseudonym":
		rel, ok := retrieved.(*Pseudonym)
		if !ok {
			return fmt.Errorf("post cannot load %T as %q", retrieved, name)
		}

		o.R.Pseudonym = rel

		if rel != nil {
			rel.R.Posts = PostSlice{o}
		}
		return nil
	case "RemovedByPseudonymPseudonym":
		rel, ok := retrieved.(*Pseudonym)
		if !ok {
			return fmt.Errorf("post cannot load %T as %q", retrieved, name)
		}

		o.R.RemovedByPseudonymPseudonym = rel

		if rel != nil {
			rel.R.RemovedByPseudonymPosts = PostSlice{o}
		}
		return nil
	case "RemovedByUserUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("post cannot load %T as %q", retrieved, name)
		}

		o.R.RemovedByUserUser = rel

		if rel != nil {
			rel.R.RemovedByUserPosts = PostSlice{o}
		}
		return nil
	case "Subforum":
		rel, ok := retrieved.(*Subforum)
		if !ok {
			return fmt.Errorf("post cannot load %T as %q", retrieved, name)
		}

		o.R.Subforum = rel

		if rel != nil {
			rel.R.Posts = PostSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("post has no relationship %q", name)
	}
}

type postPreloader struct {
	Poll                        func(...psql.PreloadOption) psql.Preloader
	Pseudonym                   func(...psql.PreloadOption) psql.Preloader
	RemovedByPseudonymPseudonym func(...psql.PreloadOption) psql.Preloader
	RemovedByUserUser           func(...psql.PreloadOption) psql.Preloader
	Subforum                    func(...psql.PreloadOption) psql.Preloader
}

func buildPostPreloader() postPreloader {
	return postPreloader{
		Poll: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Poll, PollSlice](orm.Relationship{
				Name: "Poll",
				Sides: []orm.RelSide{
					{
						From: TableNames.Posts,
						To:   TableNames.Polls,
						FromColumns: []string{
							ColumnNames.Posts.PostID,
						},
						ToColumns: []string{
							ColumnNames.Polls.PostID,
						},
					},
				},
			}, Polls.Columns().Names(), opts...)
		},
		Pseudonym: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Pseudonym, PseudonymSlice](orm.Relationship{
				Name: "Pseudonym",
				Sides: []orm.RelSide{
					{
						From: TableNames.Posts,
						To:   TableNames.Pseudonyms,
						FromColumns: []string{
							ColumnNames.Posts.PseudonymID,
						},
						ToColumns: []string{
							ColumnNames.Pseudonyms.PseudonymID,
						},
					},
				},
			}, Pseudonyms.Columns().Names(), opts...)
		},
		RemovedByPseudonymPseudonym: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Pseudonym, PseudonymSlice](orm.Relationship{
				Name: "RemovedByPseudonymPseudonym",
				Sides: []orm.RelSide{
					{
						From: TableNames.Posts,
						To:   TableNames.Pseudonyms,
						FromColumns: []string{
							ColumnNames.Posts.RemovedByPseudonymID,
						},
						ToColumns: []string{
							ColumnNames.Pseudonyms.PseudonymID,
						},
					},
				},
			}, Pseudonyms.Columns().Names(), opts...)
		},
		RemovedByUserUser: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](orm.Relationship{
				Name: "RemovedByUserUser",
				Sides: []orm.RelSide{
					{
						From: TableNames.Posts,
						To:   TableNames.Users,
						FromColumns: []string{
							ColumnNames.Posts.RemovedByUserID,
						},
						ToColumns: []string{
							ColumnNames.Users.UserID,
						},
					},
				},
			}, Users.Columns().Names(), opts...)
		},
		Subforum: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Subforum, SubforumSlice](orm.Relationship{
				Name: "Subforum",
				Sides: []orm.RelSide{
					{
						From: TableNames.Posts,
						To:   TableNames.Subforums,
						FromColumns: []string{
							ColumnNames.Posts.SubforumID,
						},
						ToColumns: []string{
							ColumnNames.Subforums.SubforumID,
						},
					},
				},
			}, Subforums.Columns().Names(), opts...)
		},
	}
}

type postThenLoader[Q orm.Loadable] struct {
	Comments                    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	MediaAttachments            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Poll                        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pseudonym                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RemovedByPseudonymPseudonym func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RemovedByUserUser           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Subforum                    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildPostThenLoader[Q orm.Loadable]() postThenLoader[Q] {
	type CommentsLoadInterface interface {
		LoadComments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type MediaAttachmentsLoadInterface interface {
		LoadMediaAttachments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PollLoadInterface interface {
		LoadPoll(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PseudonymLoadInterface interface {
		LoadPseudonym(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RemovedByPseudonymPseudonymLoadInterface interface {
		LoadRemovedByPseudonymPseudonym(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RemovedByUserUserLoadInterface interface {
		LoadRemovedByUserUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SubforumLoadInterface interface {
		LoadSubforum(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return postThenLoader[Q]{
		Comments: thenLoadBuilder[Q](
			"Comments",
			func(ctx context.Context, exec bob.Executor, retrieved CommentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadComments(ctx, exec, mods...)
			},
		),
		MediaAttachments: thenLoadBuilder[Q](
			"MediaAttachments",
			func(ctx context.Context, exec bob.Executor, retrieved MediaAttachmentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadMediaAttachments(ctx, exec, mods...)
			},
		),
		Poll: thenLoadBuilder[Q](
			"Poll",
			func(ctx context.Context, exec bob.Executor, retrieved PollLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPoll(ctx, exec, mods...)
			},
		),
		Pseudonym: thenLoadBuilder[Q](
			"Pseudonym",
			func(ctx context.Context, exec bob.Executor, retrieved PseudonymLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPseudonym(ctx, exec, mods...)
			},
		),
		RemovedByPseudonymPseudonym: thenLoadBuilder[Q](
			"RemovedByPseudonymPseudonym",
			func(ctx context.Context, exec bob.Executor, retrieved RemovedByPseudonymPseudonymLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRemovedByPseudonymPseudonym(ctx, exec, mods...)
			},
		),
		RemovedByUserUser: thenLoadBuilder[Q](
			"RemovedByUserUser",
			func(ctx context.Context, exec bob.Executor, retrieved RemovedByUserUserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRemovedByUserUser(ctx, exec, mods...)
			},
		),
		Subforum: thenLoadBuilder[Q](
			"Subforum",
			func(ctx context.Context, exec bob.Executor, retrieved SubforumLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSubforum(ctx, exec, mods...)
			},
		),
	}
}

// LoadComments loads the post's Comments into the .R struct
func (o *Post) LoadComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Comments = nil

	related, err := o.Comments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Post = o
	}

	o.R.Comments = related
	return nil
}

// LoadComments loads the post's Comments into the .R struct
func (os PostSlice) LoadComments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	comments, err := os.Comments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Comments = nil
	}

	for _, o := range os {
		for _, rel := range comments {
			if o.PostID != rel.PostID {
				continue
			}

			rel.R.Post = o

			o.R.Comments = append(o.R.Comments, rel)
		}
	}

	return nil
}

// LoadMediaAttachments loads the post's MediaAttachments into the .R struct
func (o *Post) LoadMediaAttachments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.MediaAttachments = nil

	related, err := o.MediaAttachments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Post = o
	}

	o.R.MediaAttachments = related
	return nil
}

// LoadMediaAttachments loads the post's MediaAttachments into the .R struct
func (os PostSlice) LoadMediaAttachments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	mediaAttachments, err := os.MediaAttachments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.MediaAttachments = nil
	}

	for _, o := range os {
		for _, rel := range mediaAttachments {
			if o.PostID != rel.PostID {
				continue
			}

			rel.R.Post = o

			o.R.MediaAttachments = append(o.R.MediaAttachments, rel)
		}
	}

	return nil
}

// LoadPoll loads the post's Poll into the .R struct
func (o *Post) LoadPoll(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Poll = nil

	related, err := o.Poll(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Post = o

	o.R.Poll = related
	return nil
}

// LoadPoll loads the post's Poll into the .R struct
func (os PostSlice) LoadPoll(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	polls, err := os.Poll(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range polls {
			if o.PostID != rel.PostID {
				continue
			}

			rel.R.Post = o

			o.R.Poll = rel
			break
		}
	}

	return nil
}

// LoadPseudonym loads the post's Pseudonym into the .R struct
func (o *Post) LoadPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Pseudonym = nil

	related, err := o.Pseudonym(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Posts = PostSlice{o}

	o.R.Pseudonym = related
	return nil
}

// LoadPseudonym loads the post's Pseudonym into the .R struct
func (os PostSlice) LoadPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pseudonyms, err := os.Pseudonym(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range pseudonyms {
			if o.PseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.Posts = append(rel.R.Posts, o)

			o.R.Pseudonym = rel
			break
		}
	}

	return nil
}

// LoadRemovedByPseudonymPseudonym loads the post's RemovedByPseudonymPseudonym into the .R struct
func (o *Post) LoadRemovedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RemovedByPseudonymPseudonym = nil

	related, err := o.RemovedByPseudonymPseudonym(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.RemovedByPseudonymPosts = PostSlice{o}

	o.R.RemovedByPseudonymPseudonym = related
	return nil
}

// LoadRemovedByPseudonymPseudonym loads the post's RemovedByPseudonymPseudonym into the .R struct
func (os PostSlice) LoadRemovedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pseudonyms, err := os.RemovedByPseudonymPseudonym(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range pseudonyms {
			if o.RemovedByPseudonymID.V != rel.PseudonymID {
				continue
			}

			rel.R.RemovedByPseudonymPosts = append(rel.R.RemovedByPseudonymPosts, o)

			o.R.RemovedByPseudonymPseudonym = rel
			break
		}
	}

	return nil
}

// LoadRemovedByUserUser loads the post's RemovedByUserUser into the .R struct
func (o *Post) LoadRemovedByUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RemovedByUserUser = nil

	related, err := o.RemovedByUserUser(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.RemovedByUserPosts = PostSlice{o}

	o.R.RemovedByUserUser = related
	return nil
}

// LoadRemovedByUserUser loads the post's RemovedByUserUser into the .R struct
func (os PostSlice) LoadRemovedByUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.RemovedByUserUser(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range users {
			if o.RemovedByUserID.V != rel.UserID {
				continue
			}

			rel.R.RemovedByUserPosts = append(rel.R.RemovedByUserPosts, o)

			o.R.RemovedByUserUser = rel
			break
		}
	}

	return nil
}

// LoadSubforum loads the post's Subforum into the .R struct
func (o *Post) LoadSubforum(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Subforum = nil

	related, err := o.Subforum(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Posts = PostSlice{o}

	o.R.Subforum = related
	return nil
}

// LoadSubforum loads the post's Subforum into the .R struct
func (os PostSlice) LoadSubforum(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	subforums, err := os.Subforum(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range subforums {
			if o.SubforumID != rel.SubforumID {
				continue
			}

			rel.R.Posts = append(rel.R.Posts, o)

			o.R.Subforum = rel
			break
		}
	}

	return nil
}

func insertPostComments0(ctx context.Context, exec bob.Executor, comments1 []*CommentSetter, post0 *Post) (CommentSlice, error) {
	for i := range comments1 {
		comments1[i].PostID = &post0.PostID
	}

	ret, err := Comments.Insert(bob.ToMods(comments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPostComments0: %w", err)
	}

	return ret, nil
}

func attachPostComments0(ctx context.Context, exec bob.Executor, count int, comments1 CommentSlice, post0 *Post) (CommentSlice, error) {
	setter := &CommentSetter{
		PostID: &post0.PostID,
	}

	err := comments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPostComments0: %w", err)
	}

	return comments1, nil
}

func (post0 *Post) InsertComments(ctx context.Context, exec bob.Executor, related ...*CommentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	comments1, err := insertPostComments0(ctx, exec, related, post0)
	if err != nil {
		return err
	}

	post0.R.Comments = append(post0.R.Comments, comments1...)

	for _, rel := range comments1 {
		rel.R.Post = post0
	}
	return nil
}

func (post0 *Post) AttachComments(ctx context.Context, exec bob.Executor, related ...*Comment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	comments1 := CommentSlice(related)

	_, err = attachPostComments0(ctx, exec, len(related), comments1, post0)
	if err != nil {
		return err
	}

	post0.R.Comments = append(post0.R.Comments, comments1...)

	for _, rel := range related {
		rel.R.Post = post0
	}

	return nil
}

func insertPostMediaAttachments0(ctx context.Context, exec bob.Executor, mediaAttachments1 []*MediaAttachmentSetter, post0 *Post) (MediaAttachmentSlice, error) {
	for i := range mediaAttachments1 {
		mediaAttachments1[i].PostID = &post0.PostID
	}

	ret, err := MediaAttachments.Insert(bob.ToMods(mediaAttachments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPostMediaAttachments0: %w", err)
	}

	return ret, nil
}

func attachPostMediaAttachments0(ctx context.Context, exec bob.Executor, count int, mediaAttachments1 MediaAttachmentSlice, post0 *Post) (MediaAttachmentSlice, error) {
	setter := &MediaAttachmentSetter{
		PostID: &post0.PostID,
	}

	err := mediaAttachments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPostMediaAttachments0: %w", err)
	}

	return mediaAttachments1, nil
}

func (post0 *Post) InsertMediaAttachments(ctx context.Context, exec bob.Executor, related ...*MediaAttachmentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	mediaAttachments1, err := insertPostMediaAttachments0(ctx, exec, related, post0)
	if err != nil {
		return err
	}

	post0.R.MediaAttachments = append(post0.R.MediaAttachments, mediaAttachments1...)

	for _, rel := range mediaAttachments1 {
		rel.R.Post = post0
	}
	return nil
}

func (post0 *Post) AttachMediaAttachments(ctx context.Context, exec bob.Executor, related ...*MediaAttachment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	mediaAttachments1 := MediaAttachmentSlice(related)

	_, err = attachPostMediaAttachments0(ctx, exec, len(related), mediaAttachments1, post0)
	if err != nil {
		return err
	}

	post0.R.MediaAttachments = append(post0.R.MediaAttachments, mediaAttachments1...)

	for _, rel := range related {
		rel.R.Post = post0
	}

	return nil
}

func insertPostPoll0(ctx context.Context, exec bob.Executor, poll1 *PollSetter, post0 *Post) (*Poll, error) {
	poll1.PostID = &post0.PostID

	ret, err := Polls.Insert(poll1).One(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPostPoll0: %w", err)
	}

	return ret, nil
}

func attachPostPoll0(ctx context.Context, exec bob.Executor, count int, poll1 *Poll, post0 *Post) (*Poll, error) {
	setter := &PollSetter{
		PostID: &post0.PostID,
	}

	err := poll1.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachPostPoll0: %w", err)
	}

	return poll1, nil
}

func (post0 *Post) InsertPoll(ctx context.Context, exec bob.Executor, related *PollSetter) error {
	poll1, err := insertPostPoll0(ctx, exec, related, post0)
	if err != nil {
		return err
	}

	post0.R.Poll = poll1

	poll1.R.Post = post0

	return nil
}

func (post0 *Post) AttachPoll(ctx context.Context, exec bob.Executor, poll1 *Poll) error {
	var err error

	_, err = attachPostPoll0(ctx, exec, 1, poll1, post0)
	if err != nil {
		return err
	}

	post0.R.Poll = poll1

	poll1.R.Post = post0

	return nil
}

func attachPostPseudonym0(ctx context.Context, exec bob.Executor, count int, post0 *Post, pseudonym1 *Pseudonym) (*Post, error) {
	setter := &PostSetter{
		PseudonymID: &pseudonym1.PseudonymID,
	}

	err := post0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachPostPseudonym0: %w", err)
	}

	return post0, nil
}

func (post0 *Post) InsertPseudonym(ctx context.Context, exec bob.Executor, related *PseudonymSetter) error {
	pseudonym1, err := Pseudonyms.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachPostPseudonym0(ctx, exec, 1, post0, pseudonym1)
	if err != nil {
		return err
	}

	post0.R.Pseudonym = pseudonym1

	pseudonym1.R.Posts = append(pseudonym1.R.Posts, post0)

	return nil
}

func (post0 *Post) AttachPseudonym(ctx context.Context, exec bob.Executor, pseudonym1 *Pseudonym) error {
	var err error

	_, err = attachPostPseudonym0(ctx, exec, 1, post0, pseudonym1)
	if err != nil {
		return err
	}

	post0.R.Pseudonym = pseudonym1

	pseudonym1.R.Posts = append(pseudonym1.R.Posts, post0)

	return nil
}

func attachPostRemovedByPseudonymPseudonym0(ctx context.Context, exec bob.Executor, count int, post0 *Post, pseudonym1 *Pseudonym) (*Post, error) {
	setter := &PostSetter{
		RemovedByPseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym1.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := post0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachPostRemovedByPseudonymPseudonym0: %w", err)
	}

	return post0, nil
}

func (post0 *Post) InsertRemovedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, related *PseudonymSetter) error {
	pseudonym1, err := Pseudonyms.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachPostRemovedByPseudonymPseudonym0(ctx, exec, 1, post0, pseudonym1)
	if err != nil {
		return err
	}

	post0.R.RemovedByPseudonymPseudonym = pseudonym1

	pseudonym1.R.RemovedByPseudonymPosts = append(pseudonym1.R.RemovedByPseudonymPosts, post0)

	return nil
}

func (post0 *Post) AttachRemovedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, pseudonym1 *Pseudonym) error {
	var err error

	_, err = attachPostRemovedByPseudonymPseudonym0(ctx, exec, 1, post0, pseudonym1)
	if err != nil {
		return err
	}

	post0.R.RemovedByPseudonymPseudonym = pseudonym1

	pseudonym1.R.RemovedByPseudonymPosts = append(pseudonym1.R.RemovedByPseudonymPosts, post0)

	return nil
}

func attachPostRemovedByUserUser0(ctx context.Context, exec bob.Executor, count int, post0 *Post, user1 *User) (*Post, error) {
	setter := &PostSetter{
		RemovedByUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user1.UserID, Valid: true}
			return &v
		}(),
	}

	err := post0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachPostRemovedByUserUser0: %w", err)
	}

	return post0, nil
}

func (post0 *Post) InsertRemovedByUserUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachPostRemovedByUserUser0(ctx, exec, 1, post0, user1)
	if err != nil {
		return err
	}

	post0.R.RemovedByUserUser = user1

	user1.R.RemovedByUserPosts = append(user1.R.RemovedByUserPosts, post0)

	return nil
}

func (post0 *Post) AttachRemovedByUserUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachPostRemovedByUserUser0(ctx, exec, 1, post0, user1)
	if err != nil {
		return err
	}

	post0.R.RemovedByUserUser = user1

	user1.R.RemovedByUserPosts = append(user1.R.RemovedByUserPosts, post0)

	return nil
}

func attachPostSubforum0(ctx context.Context, exec bob.Executor, count int, post0 *Post, subforum1 *Subforum) (*Post, error) {
	setter := &PostSetter{
		SubforumID: &subforum1.SubforumID,
	}

	err := post0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachPostSubforum0: %w", err)
	}

	return post0, nil
}

func (post0 *Post) InsertSubforum(ctx context.Context, exec bob.Executor, related *SubforumSetter) error {
	subforum1, err := Subforums.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachPostSubforum0(ctx, exec, 1, post0, subforum1)
	if err != nil {
		return err
	}

	post0.R.Subforum = subforum1

	subforum1.R.Posts = append(subforum1.R.Posts, post0)

	return nil
}

func (post0 *Post) AttachSubforum(ctx context.Context, exec bob.Executor, subforum1 *Subforum) error {
	var err error

	_, err = attachPostSubforum0(ctx, exec, 1, post0, subforum1)
	if err != nil {
		return err
	}

	post0.R.Subforum = subforum1

	subforum1.R.Posts = append(subforum1.R.Posts, post0)

	return nil
}
