// Code generated by HashPost Generated Code. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"time"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// Report is an object representing the database table.
type Report struct {
	ReportID              int64               `db:"report_id,pk" scan:"report_id" json:"report_id"`
	ReporterPseudonymID   string              `db:"reporter_pseudonym_id" scan:"reporter_pseudonym_id" json:"reporter_pseudonym_id"`
	ContentType           string              `db:"content_type" scan:"content_type" json:"content_type"`
	ContentID             sql.Null[int64]     `db:"content_id" scan:"content_id" json:"content_id"`
	ReportedPseudonymID   sql.Null[string]    `db:"reported_pseudonym_id" scan:"reported_pseudonym_id" json:"reported_pseudonym_id"`
	ReportReason          string              `db:"report_reason" scan:"report_reason" json:"report_reason"`
	ReportDetails         sql.Null[string]    `db:"report_details" scan:"report_details" json:"report_details"`
	CreatedAt             sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	Status                sql.Null[string]    `db:"status" scan:"status" json:"status"`
	ResolvedByUserID      sql.Null[int64]     `db:"resolved_by_user_id" scan:"resolved_by_user_id" json:"resolved_by_user_id"`
	ResolvedByPseudonymID sql.Null[string]    `db:"resolved_by_pseudonym_id" scan:"resolved_by_pseudonym_id" json:"resolved_by_pseudonym_id"`
	ResolutionNotes       sql.Null[string]    `db:"resolution_notes" scan:"resolution_notes" json:"resolution_notes"`
	ResolvedAt            sql.Null[time.Time] `db:"resolved_at" scan:"resolved_at" json:"resolved_at"`

	R reportR `db:"-" scan:"rel" json:"rel"`
}

// ReportSlice is an alias for a slice of pointers to Report.
// This should almost always be used instead of []*Report.
type ReportSlice []*Report

// Reports contains methods to work with the reports table
var Reports = psql.NewTablex[*Report, ReportSlice, *ReportSetter]("", "reports")

// ReportsQuery is a query on the reports table
type ReportsQuery = *psql.ViewQuery[*Report, ReportSlice]

// reportR is where relationships are stored.
type reportR struct {
	ReportedPseudonymPseudonym   *Pseudonym `scan:"ReportedPseudonymPseudonym" json:"ReportedPseudonymPseudonym"`     // reports.reports_reported_pseudonym_id_fkey
	ReporterPseudonymPseudonym   *Pseudonym `scan:"ReporterPseudonymPseudonym" json:"ReporterPseudonymPseudonym"`     // reports.reports_reporter_pseudonym_id_fkey
	ResolvedByPseudonymPseudonym *Pseudonym `scan:"ResolvedByPseudonymPseudonym" json:"ResolvedByPseudonymPseudonym"` // reports.reports_resolved_by_pseudonym_id_fkey
	ResolvedByUserUser           *User      `scan:"ResolvedByUserUser" json:"ResolvedByUserUser"`                     // reports.reports_resolved_by_user_id_fkey
}

type reportColumnNames struct {
	ReportID              string
	ReporterPseudonymID   string
	ContentType           string
	ContentID             string
	ReportedPseudonymID   string
	ReportReason          string
	ReportDetails         string
	CreatedAt             string
	Status                string
	ResolvedByUserID      string
	ResolvedByPseudonymID string
	ResolutionNotes       string
	ResolvedAt            string
}

var ReportColumns = buildReportColumns("reports")

type reportColumns struct {
	tableAlias            string
	ReportID              psql.Expression
	ReporterPseudonymID   psql.Expression
	ContentType           psql.Expression
	ContentID             psql.Expression
	ReportedPseudonymID   psql.Expression
	ReportReason          psql.Expression
	ReportDetails         psql.Expression
	CreatedAt             psql.Expression
	Status                psql.Expression
	ResolvedByUserID      psql.Expression
	ResolvedByPseudonymID psql.Expression
	ResolutionNotes       psql.Expression
	ResolvedAt            psql.Expression
}

func (c reportColumns) Alias() string {
	return c.tableAlias
}

func (reportColumns) AliasedAs(alias string) reportColumns {
	return buildReportColumns(alias)
}

func buildReportColumns(alias string) reportColumns {
	return reportColumns{
		tableAlias:            alias,
		ReportID:              psql.Quote(alias, "report_id"),
		ReporterPseudonymID:   psql.Quote(alias, "reporter_pseudonym_id"),
		ContentType:           psql.Quote(alias, "content_type"),
		ContentID:             psql.Quote(alias, "content_id"),
		ReportedPseudonymID:   psql.Quote(alias, "reported_pseudonym_id"),
		ReportReason:          psql.Quote(alias, "report_reason"),
		ReportDetails:         psql.Quote(alias, "report_details"),
		CreatedAt:             psql.Quote(alias, "created_at"),
		Status:                psql.Quote(alias, "status"),
		ResolvedByUserID:      psql.Quote(alias, "resolved_by_user_id"),
		ResolvedByPseudonymID: psql.Quote(alias, "resolved_by_pseudonym_id"),
		ResolutionNotes:       psql.Quote(alias, "resolution_notes"),
		ResolvedAt:            psql.Quote(alias, "resolved_at"),
	}
}

type reportWhere[Q psql.Filterable] struct {
	ReportID              psql.WhereMod[Q, int64]
	ReporterPseudonymID   psql.WhereMod[Q, string]
	ContentType           psql.WhereMod[Q, string]
	ContentID             psql.WhereNullMod[Q, int64]
	ReportedPseudonymID   psql.WhereNullMod[Q, string]
	ReportReason          psql.WhereMod[Q, string]
	ReportDetails         psql.WhereNullMod[Q, string]
	CreatedAt             psql.WhereNullMod[Q, time.Time]
	Status                psql.WhereNullMod[Q, string]
	ResolvedByUserID      psql.WhereNullMod[Q, int64]
	ResolvedByPseudonymID psql.WhereNullMod[Q, string]
	ResolutionNotes       psql.WhereNullMod[Q, string]
	ResolvedAt            psql.WhereNullMod[Q, time.Time]
}

func (reportWhere[Q]) AliasedAs(alias string) reportWhere[Q] {
	return buildReportWhere[Q](buildReportColumns(alias))
}

func buildReportWhere[Q psql.Filterable](cols reportColumns) reportWhere[Q] {
	return reportWhere[Q]{
		ReportID:              psql.Where[Q, int64](cols.ReportID),
		ReporterPseudonymID:   psql.Where[Q, string](cols.ReporterPseudonymID),
		ContentType:           psql.Where[Q, string](cols.ContentType),
		ContentID:             psql.WhereNull[Q, int64](cols.ContentID),
		ReportedPseudonymID:   psql.WhereNull[Q, string](cols.ReportedPseudonymID),
		ReportReason:          psql.Where[Q, string](cols.ReportReason),
		ReportDetails:         psql.WhereNull[Q, string](cols.ReportDetails),
		CreatedAt:             psql.WhereNull[Q, time.Time](cols.CreatedAt),
		Status:                psql.WhereNull[Q, string](cols.Status),
		ResolvedByUserID:      psql.WhereNull[Q, int64](cols.ResolvedByUserID),
		ResolvedByPseudonymID: psql.WhereNull[Q, string](cols.ResolvedByPseudonymID),
		ResolutionNotes:       psql.WhereNull[Q, string](cols.ResolutionNotes),
		ResolvedAt:            psql.WhereNull[Q, time.Time](cols.ResolvedAt),
	}
}

var ReportErrors = &reportErrors{
	ErrUniqueReportsPkey: &UniqueConstraintError{
		schema:  "",
		table:   "reports",
		columns: []string{"report_id"},
		s:       "reports_pkey",
	},
}

type reportErrors struct {
	ErrUniqueReportsPkey *UniqueConstraintError
}

// ReportSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type ReportSetter struct {
	ReportID              *int64               `db:"report_id,pk" scan:"report_id" json:"report_id"`
	ReporterPseudonymID   *string              `db:"reporter_pseudonym_id" scan:"reporter_pseudonym_id" json:"reporter_pseudonym_id"`
	ContentType           *string              `db:"content_type" scan:"content_type" json:"content_type"`
	ContentID             *sql.Null[int64]     `db:"content_id" scan:"content_id" json:"content_id"`
	ReportedPseudonymID   *sql.Null[string]    `db:"reported_pseudonym_id" scan:"reported_pseudonym_id" json:"reported_pseudonym_id"`
	ReportReason          *string              `db:"report_reason" scan:"report_reason" json:"report_reason"`
	ReportDetails         *sql.Null[string]    `db:"report_details" scan:"report_details" json:"report_details"`
	CreatedAt             *sql.Null[time.Time] `db:"created_at" scan:"created_at" json:"created_at"`
	Status                *sql.Null[string]    `db:"status" scan:"status" json:"status"`
	ResolvedByUserID      *sql.Null[int64]     `db:"resolved_by_user_id" scan:"resolved_by_user_id" json:"resolved_by_user_id"`
	ResolvedByPseudonymID *sql.Null[string]    `db:"resolved_by_pseudonym_id" scan:"resolved_by_pseudonym_id" json:"resolved_by_pseudonym_id"`
	ResolutionNotes       *sql.Null[string]    `db:"resolution_notes" scan:"resolution_notes" json:"resolution_notes"`
	ResolvedAt            *sql.Null[time.Time] `db:"resolved_at" scan:"resolved_at" json:"resolved_at"`
}

func (s ReportSetter) SetColumns() []string {
	vals := make([]string, 0, 13)
	if s.ReportID != nil {
		vals = append(vals, "report_id")
	}

	if s.ReporterPseudonymID != nil {
		vals = append(vals, "reporter_pseudonym_id")
	}

	if s.ContentType != nil {
		vals = append(vals, "content_type")
	}

	if s.ContentID != nil {
		vals = append(vals, "content_id")
	}

	if s.ReportedPseudonymID != nil {
		vals = append(vals, "reported_pseudonym_id")
	}

	if s.ReportReason != nil {
		vals = append(vals, "report_reason")
	}

	if s.ReportDetails != nil {
		vals = append(vals, "report_details")
	}

	if s.CreatedAt != nil {
		vals = append(vals, "created_at")
	}

	if s.Status != nil {
		vals = append(vals, "status")
	}

	if s.ResolvedByUserID != nil {
		vals = append(vals, "resolved_by_user_id")
	}

	if s.ResolvedByPseudonymID != nil {
		vals = append(vals, "resolved_by_pseudonym_id")
	}

	if s.ResolutionNotes != nil {
		vals = append(vals, "resolution_notes")
	}

	if s.ResolvedAt != nil {
		vals = append(vals, "resolved_at")
	}

	return vals
}

func (s ReportSetter) Overwrite(t *Report) {
	if s.ReportID != nil {
		t.ReportID = *s.ReportID
	}
	if s.ReporterPseudonymID != nil {
		t.ReporterPseudonymID = *s.ReporterPseudonymID
	}
	if s.ContentType != nil {
		t.ContentType = *s.ContentType
	}
	if s.ContentID != nil {
		t.ContentID = *s.ContentID
	}
	if s.ReportedPseudonymID != nil {
		t.ReportedPseudonymID = *s.ReportedPseudonymID
	}
	if s.ReportReason != nil {
		t.ReportReason = *s.ReportReason
	}
	if s.ReportDetails != nil {
		t.ReportDetails = *s.ReportDetails
	}
	if s.CreatedAt != nil {
		t.CreatedAt = *s.CreatedAt
	}
	if s.Status != nil {
		t.Status = *s.Status
	}
	if s.ResolvedByUserID != nil {
		t.ResolvedByUserID = *s.ResolvedByUserID
	}
	if s.ResolvedByPseudonymID != nil {
		t.ResolvedByPseudonymID = *s.ResolvedByPseudonymID
	}
	if s.ResolutionNotes != nil {
		t.ResolutionNotes = *s.ResolutionNotes
	}
	if s.ResolvedAt != nil {
		t.ResolvedAt = *s.ResolvedAt
	}
}

func (s *ReportSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Reports.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 13)
		if s.ReportID != nil {
			vals[0] = psql.Arg(*s.ReportID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.ReporterPseudonymID != nil {
			vals[1] = psql.Arg(*s.ReporterPseudonymID)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.ContentType != nil {
			vals[2] = psql.Arg(*s.ContentType)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.ContentID != nil {
			vals[3] = psql.Arg(*s.ContentID)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.ReportedPseudonymID != nil {
			vals[4] = psql.Arg(*s.ReportedPseudonymID)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.ReportReason != nil {
			vals[5] = psql.Arg(*s.ReportReason)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.ReportDetails != nil {
			vals[6] = psql.Arg(*s.ReportDetails)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt != nil {
			vals[7] = psql.Arg(*s.CreatedAt)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.Status != nil {
			vals[8] = psql.Arg(*s.Status)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.ResolvedByUserID != nil {
			vals[9] = psql.Arg(*s.ResolvedByUserID)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.ResolvedByPseudonymID != nil {
			vals[10] = psql.Arg(*s.ResolvedByPseudonymID)
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.ResolutionNotes != nil {
			vals[11] = psql.Arg(*s.ResolutionNotes)
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.ResolvedAt != nil {
			vals[12] = psql.Arg(*s.ResolvedAt)
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s ReportSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s ReportSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 13)

	if s.ReportID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "report_id")...),
			psql.Arg(s.ReportID),
		}})
	}

	if s.ReporterPseudonymID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_pseudonym_id")...),
			psql.Arg(s.ReporterPseudonymID),
		}})
	}

	if s.ContentType != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "content_type")...),
			psql.Arg(s.ContentType),
		}})
	}

	if s.ContentID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "content_id")...),
			psql.Arg(s.ContentID),
		}})
	}

	if s.ReportedPseudonymID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reported_pseudonym_id")...),
			psql.Arg(s.ReportedPseudonymID),
		}})
	}

	if s.ReportReason != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "report_reason")...),
			psql.Arg(s.ReportReason),
		}})
	}

	if s.ReportDetails != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "report_details")...),
			psql.Arg(s.ReportDetails),
		}})
	}

	if s.CreatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.Status != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "status")...),
			psql.Arg(s.Status),
		}})
	}

	if s.ResolvedByUserID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "resolved_by_user_id")...),
			psql.Arg(s.ResolvedByUserID),
		}})
	}

	if s.ResolvedByPseudonymID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "resolved_by_pseudonym_id")...),
			psql.Arg(s.ResolvedByPseudonymID),
		}})
	}

	if s.ResolutionNotes != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "resolution_notes")...),
			psql.Arg(s.ResolutionNotes),
		}})
	}

	if s.ResolvedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "resolved_at")...),
			psql.Arg(s.ResolvedAt),
		}})
	}

	return exprs
}

// FindReport retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindReport(ctx context.Context, exec bob.Executor, ReportIDPK int64, cols ...string) (*Report, error) {
	if len(cols) == 0 {
		return Reports.Query(
			SelectWhere.Reports.ReportID.EQ(ReportIDPK),
		).One(ctx, exec)
	}

	return Reports.Query(
		SelectWhere.Reports.ReportID.EQ(ReportIDPK),
		sm.Columns(Reports.Columns().Only(cols...)),
	).One(ctx, exec)
}

// ReportExists checks the presence of a single record by primary key
func ReportExists(ctx context.Context, exec bob.Executor, ReportIDPK int64) (bool, error) {
	return Reports.Query(
		SelectWhere.Reports.ReportID.EQ(ReportIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Report is retrieved from the database
func (o *Report) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Reports.AfterSelectHooks.RunHooks(ctx, exec, ReportSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Reports.AfterInsertHooks.RunHooks(ctx, exec, ReportSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Reports.AfterUpdateHooks.RunHooks(ctx, exec, ReportSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Reports.AfterDeleteHooks.RunHooks(ctx, exec, ReportSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Report
func (o *Report) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ReportID)
}

func (o *Report) pkEQ() dialect.Expression {
	return psql.Quote("reports", "report_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Report
func (o *Report) Update(ctx context.Context, exec bob.Executor, s *ReportSetter) error {
	v, err := Reports.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Report record with an executor
func (o *Report) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Reports.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Report using the executor
func (o *Report) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Reports.Query(
		SelectWhere.Reports.ReportID.EQ(o.ReportID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after ReportSlice is retrieved from the database
func (o ReportSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Reports.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Reports.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Reports.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Reports.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o ReportSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("reports", "report_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o ReportSlice) copyMatchingRows(from ...*Report) {
	for i, old := range o {
		for _, new := range from {
			if new.ReportID != old.ReportID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o ReportSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Reports.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Report:
				o.copyMatchingRows(retrieved)
			case []*Report:
				o.copyMatchingRows(retrieved...)
			case ReportSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Report or a slice of Report
				// then run the AfterUpdateHooks on the slice
				_, err = Reports.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o ReportSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Reports.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Report:
				o.copyMatchingRows(retrieved)
			case []*Report:
				o.copyMatchingRows(retrieved...)
			case ReportSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Report or a slice of Report
				// then run the AfterDeleteHooks on the slice
				_, err = Reports.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o ReportSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals ReportSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Reports.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o ReportSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Reports.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o ReportSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Reports.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type reportJoins[Q dialect.Joinable] struct {
	typ                          string
	ReportedPseudonymPseudonym   modAs[Q, pseudonymColumns]
	ReporterPseudonymPseudonym   modAs[Q, pseudonymColumns]
	ResolvedByPseudonymPseudonym modAs[Q, pseudonymColumns]
	ResolvedByUserUser           modAs[Q, userColumns]
}

func (j reportJoins[Q]) aliasedAs(alias string) reportJoins[Q] {
	return buildReportJoins[Q](buildReportColumns(alias), j.typ)
}

func buildReportJoins[Q dialect.Joinable](cols reportColumns, typ string) reportJoins[Q] {
	return reportJoins[Q]{
		typ: typ,
		ReportedPseudonymPseudonym: modAs[Q, pseudonymColumns]{
			c: PseudonymColumns,
			f: func(to pseudonymColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pseudonyms.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.ReportedPseudonymID),
					))
				}

				return mods
			},
		},
		ReporterPseudonymPseudonym: modAs[Q, pseudonymColumns]{
			c: PseudonymColumns,
			f: func(to pseudonymColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pseudonyms.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.ReporterPseudonymID),
					))
				}

				return mods
			},
		},
		ResolvedByPseudonymPseudonym: modAs[Q, pseudonymColumns]{
			c: PseudonymColumns,
			f: func(to pseudonymColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pseudonyms.Name().As(to.Alias())).On(
						to.PseudonymID.EQ(cols.ResolvedByPseudonymID),
					))
				}

				return mods
			},
		},
		ResolvedByUserUser: modAs[Q, userColumns]{
			c: UserColumns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ResolvedByUserID),
					))
				}

				return mods
			},
		},
	}
}

// ReportedPseudonymPseudonym starts a query for related objects on pseudonyms
func (o *Report) ReportedPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	return Pseudonyms.Query(append(mods,
		sm.Where(PseudonymColumns.PseudonymID.EQ(psql.Arg(o.ReportedPseudonymID))),
	)...)
}

func (os ReportSlice) ReportedPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	pkReportedPseudonymID := make(pgtypes.Array[sql.Null[string]], len(os))
	for i, o := range os {
		pkReportedPseudonymID[i] = o.ReportedPseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkReportedPseudonymID), "character varying[]")),
	))

	return Pseudonyms.Query(append(mods,
		sm.Where(psql.Group(PseudonymColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// ReporterPseudonymPseudonym starts a query for related objects on pseudonyms
func (o *Report) ReporterPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	return Pseudonyms.Query(append(mods,
		sm.Where(PseudonymColumns.PseudonymID.EQ(psql.Arg(o.ReporterPseudonymID))),
	)...)
}

func (os ReportSlice) ReporterPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	pkReporterPseudonymID := make(pgtypes.Array[string], len(os))
	for i, o := range os {
		pkReporterPseudonymID[i] = o.ReporterPseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkReporterPseudonymID), "character varying[]")),
	))

	return Pseudonyms.Query(append(mods,
		sm.Where(psql.Group(PseudonymColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// ResolvedByPseudonymPseudonym starts a query for related objects on pseudonyms
func (o *Report) ResolvedByPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	return Pseudonyms.Query(append(mods,
		sm.Where(PseudonymColumns.PseudonymID.EQ(psql.Arg(o.ResolvedByPseudonymID))),
	)...)
}

func (os ReportSlice) ResolvedByPseudonymPseudonym(mods ...bob.Mod[*dialect.SelectQuery]) PseudonymsQuery {
	pkResolvedByPseudonymID := make(pgtypes.Array[sql.Null[string]], len(os))
	for i, o := range os {
		pkResolvedByPseudonymID[i] = o.ResolvedByPseudonymID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkResolvedByPseudonymID), "character varying[]")),
	))

	return Pseudonyms.Query(append(mods,
		sm.Where(psql.Group(PseudonymColumns.PseudonymID).OP("IN", PKArgExpr)),
	)...)
}

// ResolvedByUserUser starts a query for related objects on users
func (o *Report) ResolvedByUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(UserColumns.UserID.EQ(psql.Arg(o.ResolvedByUserID))),
	)...)
}

func (os ReportSlice) ResolvedByUserUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkResolvedByUserID := make(pgtypes.Array[sql.Null[int64]], len(os))
	for i, o := range os {
		pkResolvedByUserID[i] = o.ResolvedByUserID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkResolvedByUserID), "bigint[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(UserColumns.UserID).OP("IN", PKArgExpr)),
	)...)
}

func (o *Report) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "ReportedPseudonymPseudonym":
		rel, ok := retrieved.(*Pseudonym)
		if !ok {
			return fmt.Errorf("report cannot load %T as %q", retrieved, name)
		}

		o.R.ReportedPseudonymPseudonym = rel

		if rel != nil {
			rel.R.ReportedPseudonymReports = ReportSlice{o}
		}
		return nil
	case "ReporterPseudonymPseudonym":
		rel, ok := retrieved.(*Pseudonym)
		if !ok {
			return fmt.Errorf("report cannot load %T as %q", retrieved, name)
		}

		o.R.ReporterPseudonymPseudonym = rel

		if rel != nil {
			rel.R.ReporterPseudonymReports = ReportSlice{o}
		}
		return nil
	case "ResolvedByPseudonymPseudonym":
		rel, ok := retrieved.(*Pseudonym)
		if !ok {
			return fmt.Errorf("report cannot load %T as %q", retrieved, name)
		}

		o.R.ResolvedByPseudonymPseudonym = rel

		if rel != nil {
			rel.R.ResolvedByPseudonymReports = ReportSlice{o}
		}
		return nil
	case "ResolvedByUserUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("report cannot load %T as %q", retrieved, name)
		}

		o.R.ResolvedByUserUser = rel

		if rel != nil {
			rel.R.ResolvedByUserReports = ReportSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("report has no relationship %q", name)
	}
}

type reportPreloader struct {
	ReportedPseudonymPseudonym   func(...psql.PreloadOption) psql.Preloader
	ReporterPseudonymPseudonym   func(...psql.PreloadOption) psql.Preloader
	ResolvedByPseudonymPseudonym func(...psql.PreloadOption) psql.Preloader
	ResolvedByUserUser           func(...psql.PreloadOption) psql.Preloader
}

func buildReportPreloader() reportPreloader {
	return reportPreloader{
		ReportedPseudonymPseudonym: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Pseudonym, PseudonymSlice](orm.Relationship{
				Name: "ReportedPseudonymPseudonym",
				Sides: []orm.RelSide{
					{
						From: TableNames.Reports,
						To:   TableNames.Pseudonyms,
						FromColumns: []string{
							ColumnNames.Reports.ReportedPseudonymID,
						},
						ToColumns: []string{
							ColumnNames.Pseudonyms.PseudonymID,
						},
					},
				},
			}, Pseudonyms.Columns().Names(), opts...)
		},
		ReporterPseudonymPseudonym: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Pseudonym, PseudonymSlice](orm.Relationship{
				Name: "ReporterPseudonymPseudonym",
				Sides: []orm.RelSide{
					{
						From: TableNames.Reports,
						To:   TableNames.Pseudonyms,
						FromColumns: []string{
							ColumnNames.Reports.ReporterPseudonymID,
						},
						ToColumns: []string{
							ColumnNames.Pseudonyms.PseudonymID,
						},
					},
				},
			}, Pseudonyms.Columns().Names(), opts...)
		},
		ResolvedByPseudonymPseudonym: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Pseudonym, PseudonymSlice](orm.Relationship{
				Name: "ResolvedByPseudonymPseudonym",
				Sides: []orm.RelSide{
					{
						From: TableNames.Reports,
						To:   TableNames.Pseudonyms,
						FromColumns: []string{
							ColumnNames.Reports.ResolvedByPseudonymID,
						},
						ToColumns: []string{
							ColumnNames.Pseudonyms.PseudonymID,
						},
					},
				},
			}, Pseudonyms.Columns().Names(), opts...)
		},
		ResolvedByUserUser: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](orm.Relationship{
				Name: "ResolvedByUserUser",
				Sides: []orm.RelSide{
					{
						From: TableNames.Reports,
						To:   TableNames.Users,
						FromColumns: []string{
							ColumnNames.Reports.ResolvedByUserID,
						},
						ToColumns: []string{
							ColumnNames.Users.UserID,
						},
					},
				},
			}, Users.Columns().Names(), opts...)
		},
	}
}

type reportThenLoader[Q orm.Loadable] struct {
	ReportedPseudonymPseudonym   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ReporterPseudonymPseudonym   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ResolvedByPseudonymPseudonym func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ResolvedByUserUser           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildReportThenLoader[Q orm.Loadable]() reportThenLoader[Q] {
	type ReportedPseudonymPseudonymLoadInterface interface {
		LoadReportedPseudonymPseudonym(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ReporterPseudonymPseudonymLoadInterface interface {
		LoadReporterPseudonymPseudonym(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ResolvedByPseudonymPseudonymLoadInterface interface {
		LoadResolvedByPseudonymPseudonym(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ResolvedByUserUserLoadInterface interface {
		LoadResolvedByUserUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return reportThenLoader[Q]{
		ReportedPseudonymPseudonym: thenLoadBuilder[Q](
			"ReportedPseudonymPseudonym",
			func(ctx context.Context, exec bob.Executor, retrieved ReportedPseudonymPseudonymLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadReportedPseudonymPseudonym(ctx, exec, mods...)
			},
		),
		ReporterPseudonymPseudonym: thenLoadBuilder[Q](
			"ReporterPseudonymPseudonym",
			func(ctx context.Context, exec bob.Executor, retrieved ReporterPseudonymPseudonymLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadReporterPseudonymPseudonym(ctx, exec, mods...)
			},
		),
		ResolvedByPseudonymPseudonym: thenLoadBuilder[Q](
			"ResolvedByPseudonymPseudonym",
			func(ctx context.Context, exec bob.Executor, retrieved ResolvedByPseudonymPseudonymLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadResolvedByPseudonymPseudonym(ctx, exec, mods...)
			},
		),
		ResolvedByUserUser: thenLoadBuilder[Q](
			"ResolvedByUserUser",
			func(ctx context.Context, exec bob.Executor, retrieved ResolvedByUserUserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadResolvedByUserUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadReportedPseudonymPseudonym loads the report's ReportedPseudonymPseudonym into the .R struct
func (o *Report) LoadReportedPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ReportedPseudonymPseudonym = nil

	related, err := o.ReportedPseudonymPseudonym(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.ReportedPseudonymReports = ReportSlice{o}

	o.R.ReportedPseudonymPseudonym = related
	return nil
}

// LoadReportedPseudonymPseudonym loads the report's ReportedPseudonymPseudonym into the .R struct
func (os ReportSlice) LoadReportedPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pseudonyms, err := os.ReportedPseudonymPseudonym(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range pseudonyms {
			if o.ReportedPseudonymID.V != rel.PseudonymID {
				continue
			}

			rel.R.ReportedPseudonymReports = append(rel.R.ReportedPseudonymReports, o)

			o.R.ReportedPseudonymPseudonym = rel
			break
		}
	}

	return nil
}

// LoadReporterPseudonymPseudonym loads the report's ReporterPseudonymPseudonym into the .R struct
func (o *Report) LoadReporterPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ReporterPseudonymPseudonym = nil

	related, err := o.ReporterPseudonymPseudonym(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.ReporterPseudonymReports = ReportSlice{o}

	o.R.ReporterPseudonymPseudonym = related
	return nil
}

// LoadReporterPseudonymPseudonym loads the report's ReporterPseudonymPseudonym into the .R struct
func (os ReportSlice) LoadReporterPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pseudonyms, err := os.ReporterPseudonymPseudonym(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range pseudonyms {
			if o.ReporterPseudonymID != rel.PseudonymID {
				continue
			}

			rel.R.ReporterPseudonymReports = append(rel.R.ReporterPseudonymReports, o)

			o.R.ReporterPseudonymPseudonym = rel
			break
		}
	}

	return nil
}

// LoadResolvedByPseudonymPseudonym loads the report's ResolvedByPseudonymPseudonym into the .R struct
func (o *Report) LoadResolvedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ResolvedByPseudonymPseudonym = nil

	related, err := o.ResolvedByPseudonymPseudonym(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.ResolvedByPseudonymReports = ReportSlice{o}

	o.R.ResolvedByPseudonymPseudonym = related
	return nil
}

// LoadResolvedByPseudonymPseudonym loads the report's ResolvedByPseudonymPseudonym into the .R struct
func (os ReportSlice) LoadResolvedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pseudonyms, err := os.ResolvedByPseudonymPseudonym(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range pseudonyms {
			if o.ResolvedByPseudonymID.V != rel.PseudonymID {
				continue
			}

			rel.R.ResolvedByPseudonymReports = append(rel.R.ResolvedByPseudonymReports, o)

			o.R.ResolvedByPseudonymPseudonym = rel
			break
		}
	}

	return nil
}

// LoadResolvedByUserUser loads the report's ResolvedByUserUser into the .R struct
func (o *Report) LoadResolvedByUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ResolvedByUserUser = nil

	related, err := o.ResolvedByUserUser(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.ResolvedByUserReports = ReportSlice{o}

	o.R.ResolvedByUserUser = related
	return nil
}

// LoadResolvedByUserUser loads the report's ResolvedByUserUser into the .R struct
func (os ReportSlice) LoadResolvedByUserUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.ResolvedByUserUser(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range users {
			if o.ResolvedByUserID.V != rel.UserID {
				continue
			}

			rel.R.ResolvedByUserReports = append(rel.R.ResolvedByUserReports, o)

			o.R.ResolvedByUserUser = rel
			break
		}
	}

	return nil
}

func attachReportReportedPseudonymPseudonym0(ctx context.Context, exec bob.Executor, count int, report0 *Report, pseudonym1 *Pseudonym) (*Report, error) {
	setter := &ReportSetter{
		ReportedPseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym1.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := report0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachReportReportedPseudonymPseudonym0: %w", err)
	}

	return report0, nil
}

func (report0 *Report) InsertReportedPseudonymPseudonym(ctx context.Context, exec bob.Executor, related *PseudonymSetter) error {
	pseudonym1, err := Pseudonyms.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachReportReportedPseudonymPseudonym0(ctx, exec, 1, report0, pseudonym1)
	if err != nil {
		return err
	}

	report0.R.ReportedPseudonymPseudonym = pseudonym1

	pseudonym1.R.ReportedPseudonymReports = append(pseudonym1.R.ReportedPseudonymReports, report0)

	return nil
}

func (report0 *Report) AttachReportedPseudonymPseudonym(ctx context.Context, exec bob.Executor, pseudonym1 *Pseudonym) error {
	var err error

	_, err = attachReportReportedPseudonymPseudonym0(ctx, exec, 1, report0, pseudonym1)
	if err != nil {
		return err
	}

	report0.R.ReportedPseudonymPseudonym = pseudonym1

	pseudonym1.R.ReportedPseudonymReports = append(pseudonym1.R.ReportedPseudonymReports, report0)

	return nil
}

func attachReportReporterPseudonymPseudonym0(ctx context.Context, exec bob.Executor, count int, report0 *Report, pseudonym1 *Pseudonym) (*Report, error) {
	setter := &ReportSetter{
		ReporterPseudonymID: &pseudonym1.PseudonymID,
	}

	err := report0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachReportReporterPseudonymPseudonym0: %w", err)
	}

	return report0, nil
}

func (report0 *Report) InsertReporterPseudonymPseudonym(ctx context.Context, exec bob.Executor, related *PseudonymSetter) error {
	pseudonym1, err := Pseudonyms.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachReportReporterPseudonymPseudonym0(ctx, exec, 1, report0, pseudonym1)
	if err != nil {
		return err
	}

	report0.R.ReporterPseudonymPseudonym = pseudonym1

	pseudonym1.R.ReporterPseudonymReports = append(pseudonym1.R.ReporterPseudonymReports, report0)

	return nil
}

func (report0 *Report) AttachReporterPseudonymPseudonym(ctx context.Context, exec bob.Executor, pseudonym1 *Pseudonym) error {
	var err error

	_, err = attachReportReporterPseudonymPseudonym0(ctx, exec, 1, report0, pseudonym1)
	if err != nil {
		return err
	}

	report0.R.ReporterPseudonymPseudonym = pseudonym1

	pseudonym1.R.ReporterPseudonymReports = append(pseudonym1.R.ReporterPseudonymReports, report0)

	return nil
}

func attachReportResolvedByPseudonymPseudonym0(ctx context.Context, exec bob.Executor, count int, report0 *Report, pseudonym1 *Pseudonym) (*Report, error) {
	setter := &ReportSetter{
		ResolvedByPseudonymID: func() *sql.Null[string] {
			v := sql.Null[string]{V: pseudonym1.PseudonymID, Valid: true}
			return &v
		}(),
	}

	err := report0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachReportResolvedByPseudonymPseudonym0: %w", err)
	}

	return report0, nil
}

func (report0 *Report) InsertResolvedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, related *PseudonymSetter) error {
	pseudonym1, err := Pseudonyms.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachReportResolvedByPseudonymPseudonym0(ctx, exec, 1, report0, pseudonym1)
	if err != nil {
		return err
	}

	report0.R.ResolvedByPseudonymPseudonym = pseudonym1

	pseudonym1.R.ResolvedByPseudonymReports = append(pseudonym1.R.ResolvedByPseudonymReports, report0)

	return nil
}

func (report0 *Report) AttachResolvedByPseudonymPseudonym(ctx context.Context, exec bob.Executor, pseudonym1 *Pseudonym) error {
	var err error

	_, err = attachReportResolvedByPseudonymPseudonym0(ctx, exec, 1, report0, pseudonym1)
	if err != nil {
		return err
	}

	report0.R.ResolvedByPseudonymPseudonym = pseudonym1

	pseudonym1.R.ResolvedByPseudonymReports = append(pseudonym1.R.ResolvedByPseudonymReports, report0)

	return nil
}

func attachReportResolvedByUserUser0(ctx context.Context, exec bob.Executor, count int, report0 *Report, user1 *User) (*Report, error) {
	setter := &ReportSetter{
		ResolvedByUserID: func() *sql.Null[int64] {
			v := sql.Null[int64]{V: user1.UserID, Valid: true}
			return &v
		}(),
	}

	err := report0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachReportResolvedByUserUser0: %w", err)
	}

	return report0, nil
}

func (report0 *Report) InsertResolvedByUserUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachReportResolvedByUserUser0(ctx, exec, 1, report0, user1)
	if err != nil {
		return err
	}

	report0.R.ResolvedByUserUser = user1

	user1.R.ResolvedByUserReports = append(user1.R.ResolvedByUserReports, report0)

	return nil
}

func (report0 *Report) AttachResolvedByUserUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachReportResolvedByUserUser0(ctx, exec, 1, report0, user1)
	if err != nil {
		return err
	}

	report0.R.ResolvedByUserUser = user1

	user1.R.ResolvedByUserReports = append(user1.R.ResolvedByUserReports, report0)

	return nil
}
