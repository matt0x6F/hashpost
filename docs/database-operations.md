# HashPost Database Operations Guide

## Overview

This document provides operational guidance for managing the HashPost database system, including common operations, maintenance procedures, and best practices for the single-database architecture with role-based access control.

## Database Architecture Overview

HashPost uses a single-database architecture with role-based access control:

- **Single Database**: PostgreSQL database containing all user data, content, and administrative information
- **Role-Based Access**: Different user roles have different capabilities and access levels
- **Privacy Protection**: Real identities are encrypted and only accessible to users with appropriate roles
- **Audit Trail**: All administrative activities are logged for compliance and oversight

## Common Operations

### User Registration Flow

#### 1. Create User with Role-Based Capabilities

```sql
-- Insert new user with default role
INSERT INTO users (
    pseudonym_id,
    display_name,
    email,
    password_hash,
    karma_score,
    created_at,
    bio,
    avatar_url,
    website_url,
    show_karma,
    allow_direct_messages,
    roles,
    capabilities
) VALUES (
    'abc123def456...', -- Generated by IBE system
    'user_display_name',
    'user@example.com',
    'hashed_password',
    0,
    CURRENT_TIMESTAMP,
    'User bio text',
    'https://example.com/avatar.jpg',
    'https://example.com',
    TRUE,
    TRUE,
    '["user"]',
    '["create_content", "vote", "message", "report"]'
);

-- Insert user preferences
INSERT INTO user_preferences (
    user_id,
    timezone,
    language,
    theme,
    email_notifications,
    push_notifications,
    auto_hide_nsfw,
    auto_hide_spoilers
) VALUES (
    LAST_INSERT_ID(),
    'UTC',
    'en',
    'light',
    TRUE,
    TRUE,
    TRUE,
    TRUE
);
```

#### 2. Store Encrypted Identity Mapping

```sql
-- Insert encrypted identity mapping
INSERT INTO identity_mappings (
    fingerprint,
    pseudonym_id,
    encrypted_real_identity,
    encrypted_pseudonym_mapping,
    key_version,
    created_at,
    is_active
) VALUES (
    'a1b2c3d4e5f6...', -- SHA-256 hash of real identity + salt
    'abc123def456...', -- Pseudonym ID
    E'\\xencrypted_email_data...', -- Encrypted email/phone
    E'\\xencrypted_mapping_data...', -- Encrypted mapping
    1,
    CURRENT_TIMESTAMP,
    TRUE
);
```

#### 3. Assign Administrative Role (if needed)

```sql
-- Add admin capabilities to existing user
UPDATE users 
SET 
    roles = JSON_ARRAY_APPEND(roles, '$', 'moderator'),
    capabilities = JSON_MERGE_PRESERVE(
        capabilities, 
        '["moderate_content", "ban_users", "remove_content", "correlate_fingerprints"]'
    ),
    admin_username = 'mod_john',
    admin_password_hash = 'admin_password_hash',
    moderated_subforums = '[{"subforum_id": 1, "role": "moderator"}]',
    admin_scope = 'golang:local_correlation'
WHERE user_id = 123;
```

### Content Creation Flow

#### 1. Create Post

```sql
-- Insert new post
INSERT INTO posts (
    user_id,
    subforum_id,
    title,
    content,
    post_type,
    url,
    is_self_post,
    is_nsfw,
    is_spoiler,
    created_at,
    score,
    upvotes,
    downvotes,
    comment_count,
    view_count
) VALUES (
    123,
    1,
    'Post Title',
    'Post content text...',
    'text',
    NULL,
    TRUE,
    FALSE,
    FALSE,
    CURRENT_TIMESTAMP,
    0,
    0,
    0,
    0,
    0
);

-- Update subforum post count
UPDATE subforums 
SET post_count = post_count + 1 
WHERE subforum_id = 1;
```

#### 2. Create Comment

```sql
-- Insert new comment
INSERT INTO comments (
    post_id,
    parent_comment_id,
    user_id,
    content,
    created_at,
    score,
    upvotes,
    downvotes
) VALUES (
    123,
    NULL, -- Top-level comment
    456,
    'Comment content...',
    CURRENT_TIMESTAMP,
    0,
    0,
    0
);

-- Update post comment count
UPDATE posts 
SET comment_count = comment_count + 1 
WHERE post_id = 123;
```

### Voting Operations

#### 1. Record Vote

```sql
-- Insert or update vote
INSERT INTO votes (
    user_id,
    content_type,
    content_id,
    vote_value,
    created_at
) VALUES (
    123,
    'post',
    456,
    1, -- 1 for upvote, -1 for downvote
    CURRENT_TIMESTAMP
)
ON DUPLICATE KEY UPDATE
    vote_value = VALUES(vote_value),
    updated_at = CURRENT_TIMESTAMP;
```

#### 2. Update Content Score

```sql
-- Update post score (triggered by vote)
UPDATE posts 
SET 
    score = (
        SELECT SUM(vote_value) 
        FROM votes 
        WHERE content_type = 'post' AND content_id = 456
    ),
    upvotes = (
        SELECT COUNT(*) 
        FROM votes 
        WHERE content_type = 'post' AND content_id = 456 AND vote_value = 1
    ),
    downvotes = (
        SELECT COUNT(*) 
        FROM votes 
        WHERE content_type = 'post' AND content_id = 456 AND vote_value = -1
    )
WHERE post_id = 456;
```

### Moderation Operations

#### 1. Report Content

```sql
-- Create report
INSERT INTO reports (
    reporter_user_id,
    content_type,
    content_id,
    reported_user_id,
    report_reason,
    report_details,
    created_at,
    status
) VALUES (
    123,
    'post',
    456,
    789,
    'spam',
    'This post appears to be spam...',
    CURRENT_TIMESTAMP,
    'pending'
);
```

#### 2. Remove Content

```sql
-- Remove post
UPDATE posts 
SET 
    is_removed = TRUE,
    removed_by_user_id = 123,
    removal_reason = 'violates community guidelines',
    removed_at = CURRENT_TIMESTAMP
WHERE post_id = 456;
```

#### 3. Ban User from Subforum

```sql
-- Ban user
INSERT INTO user_bans (
    subforum_id,
    banned_user_id,
    banned_by_user_id,
    ban_reason,
    is_permanent,
    expires_at,
    created_at,
    is_active
) VALUES (
    1,
    789,
    123,
    'Repeated violations of community guidelines',
    FALSE,
    DATE_ADD(CURRENT_TIMESTAMP, INTERVAL 30 DAY),
    CURRENT_TIMESTAMP,
    TRUE
);
```

### Role-Based Correlation Operations

#### 1. Request Fingerprint Correlation (Moderators)

```sql
-- Log correlation request
INSERT INTO correlation_audit (
    user_id,
    pseudonym_id,
    admin_username,
    role_used,
    requested_pseudonym,
    requested_fingerprint,
    justification,
    correlation_type,
    timestamp,
    legal_basis,
    request_source,
    ip_address
) VALUES (
    123,
    'mod_john_pseudonym_id',
    'mod_john',
    'moderator',
    'abc123def456...',
    'a1b2c3d4e5f6...',
    'Investigation of ban evasion in r/golang',
    'fingerprint',
    CURRENT_TIMESTAMP,
    'Platform Terms of Service',
    'manual',
    INET_ATON('192.168.1.1')
);
```

#### 2. Perform Fingerprint-Based Correlation

```sql
-- Find all pseudonyms for a fingerprint within moderator scope
SELECT 
    im.pseudonym_id,
    u.display_name,
    im.created_at,
    COUNT(p.post_id) as posts_in_subforum,
    COUNT(c.comment_id) as comments_in_subforum
FROM identity_mappings im
JOIN users u ON im.pseudonym_id = u.pseudonym_id
LEFT JOIN posts p ON u.user_id = p.user_id AND p.subforum_id = 1
LEFT JOIN comments c ON u.user_id = c.user_id 
    AND c.post_id IN (SELECT post_id FROM posts WHERE subforum_id = 1)
WHERE im.fingerprint = 'a1b2c3d4e5f6...' 
AND im.is_active = TRUE
AND im.created_at > DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 30 DAY)
GROUP BY im.pseudonym_id, u.display_name, im.created_at;
```

#### 3. Request Identity Correlation (Admins)

```sql
-- Log identity correlation request
INSERT INTO correlation_audit (
    user_id,
    pseudonym_id,
    admin_username,
    role_used,
    requested_pseudonym,
    requested_fingerprint,
    justification,
    correlation_type,
    timestamp,
    legal_basis,
    incident_id,
    request_source
) VALUES (
    456,
    'trust_safety_alex_pseudonym_id',
    'trust_safety_alex',
    'trust_safety',
    'abc123def456...',
    'a1b2c3d4e5f6...',
    'Investigation of reported harassment across subforums',
    'identity',
    CURRENT_TIMESTAMP,
    'Platform Terms of Service',
    'harassment_case_123',
    'manual'
);
```

#### 4. Perform Identity-Based Correlation

```sql
-- Find all pseudonyms and real identity for admin correlation
SELECT 
    im.pseudonym_id,
    im.encrypted_real_identity,
    im.encrypted_pseudonym_mapping,
    im.key_version,
    im.created_at,
    u.display_name,
    COUNT(p.post_id) as total_posts,
    COUNT(c.comment_id) as total_comments
FROM identity_mappings im
JOIN users u ON im.pseudonym_id = u.pseudonym_id
LEFT JOIN posts p ON u.user_id = p.user_id
LEFT JOIN comments c ON u.user_id = c.user_id
WHERE im.fingerprint = 'a1b2c3d4e5f6...' 
AND im.is_active = TRUE
GROUP BY im.pseudonym_id, im.encrypted_real_identity, im.encrypted_pseudonym_mapping, im.key_version, im.created_at, u.display_name;
```

## Database Maintenance

### Regular Maintenance Tasks

#### 1. Cleanup Expired Bans

```sql
-- Deactivate expired bans
UPDATE user_bans 
SET is_active = FALSE 
WHERE expires_at < CURRENT_TIMESTAMP 
AND is_active = TRUE 
AND is_permanent = FALSE;
```

#### 2. Archive Old Content

```sql
-- Archive posts older than 1 year with low engagement
UPDATE posts 
SET is_archived = TRUE 
WHERE created_at < DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 1 YEAR)
AND score < 10 
AND comment_count < 5 
AND is_archived = FALSE;
```

#### 3. Cleanup Orphaned Data

```sql
-- Remove orphaned votes
DELETE v FROM votes v
LEFT JOIN posts p ON v.content_type = 'post' AND v.content_id = p.post_id
LEFT JOIN comments c ON v.content_type = 'comment' AND v.content_id = c.comment_id
WHERE p.post_id IS NULL AND c.comment_id IS NULL;
```

#### 4. Update Statistics

```sql
-- Update subforum statistics
UPDATE subforums s
SET 
    subscriber_count = (
        SELECT COUNT(*) 
        FROM subforum_subscriptions ss 
        WHERE ss.subforum_id = s.subforum_id
    ),
    post_count = (
        SELECT COUNT(*) 
        FROM posts p 
        WHERE p.subforum_id = s.subforum_id 
        AND p.is_removed = FALSE
    );
```

#### 5. Role-Based Maintenance

```sql
-- Clean up expired role keys
UPDATE role_keys 
SET is_active = FALSE 
WHERE expires_at < CURRENT_TIMESTAMP 
AND is_active = TRUE;

-- Update user capabilities based on role changes
UPDATE users u
JOIN role_definitions rd ON u.roles @> JSON_ARRAY(rd.role_name)
SET u.capabilities = rd.capabilities
WHERE rd.role_name IN ('moderator', 'subforum_owner', 'trust_safety');
```

### Performance Optimization

#### 1. Index Maintenance

```sql
-- Analyze table statistics
ANALYZE TABLE users;
ANALYZE TABLE posts;
ANALYZE TABLE comments;
ANALYZE TABLE votes;

-- Rebuild fragmented indexes
OPTIMIZE TABLE posts;
OPTIMIZE TABLE comments;
```

#### 2. Partitioning Strategy

For high-traffic tables, consider partitioning:

```sql
-- Partition posts by creation date
CREATE TABLE posts (
    -- ... existing columns ...
) PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

#### 3. Query Optimization

Common optimized queries:

```sql
-- Get top posts for a subforum (optimized)
SELECT 
    p.post_id,
    p.title,
    p.score,
    p.comment_count,
    p.created_at,
    u.display_name
FROM posts p
JOIN users u ON p.user_id = u.user_id
WHERE p.subforum_id = 1 
AND p.is_removed = FALSE
AND p.is_archived = FALSE
ORDER BY p.score DESC, p.created_at DESC
LIMIT 25;

-- Get user's posts with pagination
SELECT 
    p.post_id,
    p.title,
    p.score,
    p.comment_count,
    p.created_at,
    s.name as subforum_name
FROM posts p
JOIN subforums s ON p.subforum_id = s.subforum_id
WHERE p.user_id = 123
AND p.is_removed = FALSE
ORDER BY p.created_at DESC
LIMIT 20 OFFSET 0;

-- Check user permissions for correlation
SELECT 
    u.user_id,
    u.roles,
    u.capabilities,
    rd.correlation_access,
    rd.scope,
    rd.time_window
FROM users u
JOIN role_definitions rd ON u.roles @> JSON_ARRAY(rd.role_name)
WHERE u.user_id = 123
AND u.is_active = TRUE;
```

## Backup and Recovery

### Backup Procedures

#### 1. Full Database Backup

```bash
# Full backup
pg_dump -h localhost -U hashpost_user -d hashpost -F c -f /backups/hashpost_$(date +%Y%m%d_%H%M%S).dump

# Incremental backup (WAL archiving)
pg_basebackup -h localhost -U hashpost_user -D /backups/incremental_$(date +%Y%m%d_%H%M%S) -Ft -z -P
```

#### 2. Encrypted Backup for Sensitive Data

```bash
# Encrypted backup of sensitive tables
pg_dump -h localhost -U hashpost_user -d hashpost -t identity_mappings -t correlation_audit -F c -f /backups/sensitive_$(date +%Y%m%d_%H%M%S).dump
gpg --encrypt --recipient admin@hashpost.com /backups/sensitive_$(date +%Y%m%d_%H%M%S).dump
```

### Recovery Procedures

#### 1. Point-in-Time Recovery

```bash
# Restore to specific point in time
pg_restore -h localhost -U hashpost_user -d hashpost --clean --if-exists /backups/hashpost_20240101_120000.dump
```

#### 2. Sensitive Data Recovery

```bash
# Decrypt and restore sensitive data
gpg --decrypt /backups/sensitive_20240101_120000.dump.gpg | pg_restore -h localhost -U hashpost_user -d hashpost --clean --if-exists
```

## Security Operations

### Key Rotation

#### 1. Role Key Rotation

```sql
-- Create new key version
INSERT INTO role_keys (
    role_name,
    scope,
    key_data,
    key_version,
    capabilities,
    created_at,
    expires_at,
    created_by
) VALUES (
    'moderator',
    'golang:local_correlation',
    E'\\xnew_encrypted_key_data...',
    2,
    '["moderate_content", "ban_users", "remove_content", "correlate_fingerprints"]',
    CURRENT_TIMESTAMP,
    DATE_ADD(CURRENT_TIMESTAMP, INTERVAL 3 MONTH),
    123
);

-- Update identity mappings to use new key version
UPDATE identity_mappings 
SET key_version = 2 
WHERE key_version = 1;
```

#### 2. Audit Key Usage

```sql
-- Monitor key usage patterns
SELECT 
    rk.role_name,
    rk.scope,
    COUNT(kua.usage_id) as usage_count,
    COUNT(CASE WHEN kua.success = TRUE THEN 1 END) as successful_operations,
    COUNT(CASE WHEN kua.success = FALSE THEN 1 END) as failed_operations,
    MIN(kua.timestamp) as first_usage,
    MAX(kua.timestamp) as last_usage
FROM role_keys rk
LEFT JOIN key_usage_audit kua ON rk.key_id = kua.key_id
WHERE rk.is_active = TRUE
GROUP BY rk.key_id, rk.role_name, rk.scope
ORDER BY usage_count DESC;
```

### Access Monitoring

#### 1. Monitor Correlation Patterns

```sql
-- Check for unusual correlation patterns
SELECT 
    u.admin_username,
    ca.role_used,
    COUNT(*) as correlation_count,
    COUNT(DISTINCT ca.requested_pseudonym) as unique_targets,
    MIN(ca.timestamp) as first_correlation,
    MAX(ca.timestamp) as last_correlation
FROM correlation_audit ca
JOIN users u ON ca.user_id = u.user_id
WHERE ca.timestamp > DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 24 HOUR)
GROUP BY ca.user_id, u.admin_username, ca.role_used
HAVING correlation_count > 10
ORDER BY correlation_count DESC;
```

#### 2. Monitor Role Changes

```sql
-- Track role assignments and changes
SELECT 
    u.user_id,
    u.pseudonym_id,
    u.roles,
    u.admin_username,
    u.admin_scope,
    u.created_at,
    u.last_active_at
FROM users u
WHERE u.roles @> JSON_ARRAY('moderator') 
   OR u.roles @> JSON_ARRAY('trust_safety')
   OR u.roles @> JSON_ARRAY('platform_admin')
ORDER BY u.created_at DESC;
```

#### 3. Failed Authentication Monitoring

```sql
-- Monitor failed login attempts (would need to implement login tracking)
SELECT 
    u.admin_username,
    COUNT(*) as failed_attempts,
    MAX(created_at) as last_failed_attempt
FROM login_attempts la
JOIN users u ON la.user_id = u.user_id
WHERE la.success = FALSE
AND la.created_at > DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 24 HOUR)
GROUP BY u.user_id, u.admin_username
HAVING failed_attempts > 3
ORDER BY failed_attempts DESC;
```

## Monitoring and Alerting

### Key Metrics to Monitor

#### 1. Database Performance

```sql
-- Monitor slow queries
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    rows
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 10;

-- Monitor table sizes
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

#### 2. Application Metrics

```sql
-- Monitor user activity
SELECT 
    DATE(created_at) as date,
    COUNT(*) as new_users,
    COUNT(DISTINCT user_id) as active_users
FROM users
WHERE created_at > DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 7 DAY)
GROUP BY DATE(created_at)
ORDER BY date DESC;

-- Monitor content creation
SELECT 
    DATE(created_at) as date,
    COUNT(*) as new_posts,
    COUNT(DISTINCT user_id) as unique_authors
FROM posts
WHERE created_at > DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 7 DAY)
GROUP BY DATE(created_at)
ORDER BY date DESC;

-- Monitor correlation activities
SELECT 
    DATE(timestamp) as date,
    correlation_type,
    role_used,
    COUNT(*) as correlation_count
FROM correlation_audit
WHERE timestamp > DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 7 DAY)
GROUP BY DATE(timestamp), correlation_type, role_used
ORDER BY date DESC;
```

#### 3. Role-Based Metrics

```sql
-- Monitor role distribution
SELECT 
    JSON_EXTRACT(role, '$') as role_name,
    COUNT(*) as user_count
FROM users u,
JSON_TABLE(u.roles, '$[*]' COLUMNS (role VARCHAR(50) PATH '$')) as roles
WHERE u.is_active = TRUE
GROUP BY role_name
ORDER BY user_count DESC;

-- Monitor capability usage
SELECT 
    JSON_EXTRACT(capability, '$') as capability_name,
    COUNT(*) as user_count
FROM users u,
JSON_TABLE(u.capabilities, '$[*]' COLUMNS (capability VARCHAR(50) PATH '$')) as capabilities
WHERE u.is_active = TRUE
GROUP BY capability_name
ORDER BY user_count DESC;
```

### Alerting Thresholds

Set up alerts for:

- Database connection count > 80% of max_connections
- Query response time > 5 seconds
- Failed authentication attempts > 5 per hour
- Correlation requests > 50 per day
- Database disk usage > 85%
- Backup failures
- Key expiration within 7 days
- Role changes for admin users
- Unusual correlation patterns

## Troubleshooting

### Common Issues

#### 1. High Query Response Times

```sql
-- Identify slow queries
SELECT 
    pid,
    now() - pg_stat_activity.query_start AS duration,
    query
FROM pg_stat_activity
WHERE (now() - pg_stat_activity.query_start) > interval '5 minutes';
```

#### 2. Lock Contention

```sql
-- Check for blocking queries
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS current_statement_in_blocking_process
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
    ON (blocking_locks.locktype = blocked_locks.locktype
        AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
        AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
        AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
        AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
        AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
        AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
        AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
        AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
        AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
        AND blocking_locks.pid != blocked_locks.pid)
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

#### 3. Data Integrity Issues

```sql
-- Check for orphaned records
SELECT 'posts without users' as issue, COUNT(*) as count
FROM posts p
LEFT JOIN users u ON p.user_id = u.user_id
WHERE u.user_id IS NULL
UNION ALL
SELECT 'comments without posts' as issue, COUNT(*) as count
FROM comments c
LEFT JOIN posts p ON c.post_id = p.post_id
WHERE p.post_id IS NULL
UNION ALL
SELECT 'votes without content' as issue, COUNT(*) as count
FROM votes v
LEFT JOIN posts p ON v.content_type = 'post' AND v.content_id = p.post_id
LEFT JOIN comments c ON v.content_type = 'comment' AND v.content_id = c.comment_id
WHERE p.post_id IS NULL AND c.comment_id IS NULL;
```

#### 4. Role and Permission Issues

```sql
-- Check for users with invalid roles
SELECT 
    u.user_id,
    u.pseudonym_id,
    u.roles,
    u.capabilities
FROM users u
WHERE NOT EXISTS (
    SELECT 1 FROM role_definitions rd 
    WHERE u.roles @> JSON_ARRAY(rd.role_name)
);

-- Check for capability mismatches
SELECT 
    u.user_id,
    u.pseudonym_id,
    u.roles,
    u.capabilities,
    rd.capabilities as expected_capabilities
FROM users u
JOIN role_definitions rd ON u.roles @> JSON_ARRAY(rd.role_name)
WHERE u.capabilities != rd.capabilities;
```

This operations guide provides comprehensive coverage of database operations for the HashPost platform, ensuring efficient and secure management of the single-user system with role-based access control. 